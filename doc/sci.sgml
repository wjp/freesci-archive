<!DOCTYPE Book PUBLIC "-//Davenport//DTD DocBook V3.0//EN" [
        <!ENTITY lt "<">
        <!ENTITY gt ">">
        <!ENTITY amp "&">
]>



<!-- (set 'font-lock-maximum-size 1024000) C-x e this in EMACS to make it possible to fontify this buffer -->

<Book>

  <Title>The Sierra Creative Interpreter</Title>

  <TitleAbbrev>SCI Documentation</TitleAbbrev>


  <BookInfo>

    <Author>
     <FirstName>Lars</firstname>
     <SurName>Skovlund</surname>
     <AuthorBlurb><Para>
      Lars Skovlund (<Email>skovmanden50@hotmail.com</Email>) contributed information about the
      SCI heap, many of the kernel functions, and wrote the description of SCI ports.
     </Para></AuthorBlurb>
    </Author>


    <Author>
     <FirstName>Christoph</firstname>
     <SurName>Reichenbach</surname>
     <AuthorBlurb><Para>
       Christoph Reichenbach (<Email>jameson@linuxgames.com</Email>)
       maintains this document and the FreeSCI interpreter.
     </Para></AuthorBlurb>
    </Author>


    <Author>
     <Firstname/Ravi/<surname/I./
      <authorblurb><para>
       Ravi (<email/ravi.i@softhome.net/), the SCI Decoding Project's sound specialist,
       contributed information about the
       sound subsystem.
      </para>
      </authorblurb>
    </author>


    <Author>
     <Firstname/Rickard/<surname/Lind/
      <authorblurb><para>
	Rickard (<email/rpl@dd.chalmers.se/) contributed information about the sound SCI01
	resources, and documented the patch.001 format. He also implemented the MT-32 to
	GM MIDI mapper used in FreeSCI.
      </para>
      </authorblurb>
    </author>


    <Author>
     <firstname/Petr/<surname/Vyhnak/
      <authorblurb><para>
	Petr described the deflate-like algorithm required to decompress resources in
	SCI1.1-style games, and the general resource format.
      </para></authorblurb>
    </author>

    <Author>
     <firstname/Dark/<surname/Minister/
      <authorblurb><para>
        Dark Minister, whoever he may be, was the first one to document
        parts of the SCI instruction set, and the Said() system call.
      </para></authorblurb>
    </author>

    <Author>
     <firstname/Francois/<surname/Boyer/
      <authorblurb><para>
        Francos Boyer contributed several detailed descriptions of SCI kernel functions.
      </para></authorblurb>
    </author>

    <Othercredit>
     <FirstName>Carl</firstname>
     <SurName>Muckenhoupt</surname>
     <AuthorBlurb><Para>
      Carl Muckenhoupt (<Email>carl@wurb.com</Email>), author of the original SCI
      decoding utilities for DOS, discovered most of the decompression and graphics
      stuff (picture and view resources) described here.
     </Para></AuthorBlurb>
    </Othercredit>

    <Abstract><Para>
      This book describes the Sierra Creative Interpreter, versions 0.xxx and 1.xxx
      to the extent known to the general public, as well as the
      FreeSCI interpreter for those games.
      Please contact the author if you find that anything is being described
      incorrectly or missing.
      <warning><para>
        This version of the documentation is incomplete and covers only some parts
        of SCI0.
      </para></warning>
    </Para></Abstract>

    <ReleaseInfo/This document is still incomplete and covers almost only SCI0./

    <LegalNotice>
     <Para>
     Copyright (C) 1999, 2000, 2001 by the authors
     </Para>
     <Para>
   Permission is hereby granted, free of charge, to any person obtaining a
   copy of this documentation to deal in the Documentation without restriction,
   including without limitation the rights to use, copy, modify, merge, publish,
   distribute, sublicense, and/or sell copies of the Documentation, and to permit
   persons to whom the Documentation is furnished to do so, subject to the following
   conditions:
</Para>
<Para>
   The above copyright notice and this permission notice shall be included in
   all copies or substantial portions of the Documentation.
</Para><Para>
   THE DOCUMENTATION IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
   THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   CONNECTION WITH THE DOCUMENTATION OR THE USE OR OTHER DEALINGS IN THE DOCUMENTATION.
     </Para><Para>
       The Sierra Creative Interpreter was originally developed by Sierra On-Line, Inc.
       "Sierra On-Line Inc. (TM)" is a registered trademark of Sierra On-Line, Inc.
       "Quest for Glory: So You Want To Be A Hero", "Quest For Glory 2: Trial By Fire"
       and "Space Quest 3: The Pirates of Pestulon" are trademarks of Sierra On-Line, Inc.
     </Para>
    </LegalNotice>

  </BookInfo>

  <Preface>
  <Title/Preface/
   <para>
    Throughout the documentation, the term SCI will be used to describe the original
    Sierra Creative Interpreter, in any version. SCI0 will refer to all games using the
    SCI version 0.xxx, except for those games who use the 'in-between' game engine
    referred to as SCI01 (such as Quest for Glory 2). SCI1 will refer to the interpreter
    version 1.xxx.
    FreeSCI will refer specifically to either implementation details of the FreeSCI
    engine or to extensions of the original SCI engine specific to FreeSCI.
   </para>
   <para>
   I would like to take this opportunity to thank the members of the FreeSCI
   and SCI Decoding Projects and their supporters, as well as Carl Muckenhoupt,
   who took the first steps of SCI decoding, for their valuable help and
   support.
   </para><para>
    Please note that some of the text contributions have been cut, reformatted or
    slightly modified in an attempt to improve the general quality of this document.
   </para>
   </Preface>


 <Chapter>
 <Title/Introduction/
<sect1>
  <Title/The basics/
    <para>
      The Sierra Creative Interpreter is a stack-based virtual machine ("P-Machine"). In addition
      to its roughly 125 basic opcodes, it provides a set of extended functions
      for displaying graphics, playing sound, receiving input, writing and reading
      data to and from the hard disk, and handling complex arithmetical and logical functions.
      In version 0.xxx of the interpreter, Sierra split the game data into nine
      different types of information:
      <simplelist>
	<member>script data: SCI scripts and local data</member>
	<member>vocab data: Parser data and debug information</member>
	<member>patch data: Information pertaining to specific audio output devices</member>
	<member>sound data: MIDI music tracks</member>
	<member>cursor data: Mouse pointer shapes</member>
	<member>view data: Sets of sets of image and hotspot information</member>
	<member>pic data: Background images and metadata</member>
	<member>font data: Bitmap fonts</member>
	<member>text data: Plain text information</member>
      </simplelist>
</para>
<para>
Each game may contain up to 1000 different elements of each data type; these
elements are referred to as "resources". The index numbers of the various
resources need not be in sequence; they are usually assigned arbitrarily.
<footnote><para>With several notable exceptions, such as script 0 and most vocab resources.</para></footnote>
</para>
</sect1>
<sect1>
<title/Resource storage/
<para>
Individual resources can be stored in one of two ways: Either in resource files
(which, surprisingly, are called something like "resource.000" or
"resource.001"), or in external patch files (not to be confused with "patch"
resources). The external files are called something like "pic.100" or
"script.000", and they take precedence over data from resource files.
</para>
<para>
There is also a file called "resource.map", which contains a lookup table for
the individual resources, and another file, "resource.cfg", which contains
configuration information; neither of those is used by FreeSCI.
</para>
<para>
Resource information stored in external patch files is not compressed and
therefore easily readable. It is, however, preceeded by two bytes:
The first byte contains the resource type ORed with 0x80, the purpose of the
second byte is unknown (but it appears to be ignored by the original SCI
version 0 engine).
</para>
<para>
As stated before, external patch files take precedence over resource resource
files. Applying those external files as patches is an option since FreeSCI
version 0.2.2.
</para>
<para>
The resource files, however, are more complicated. Each of them contains a
sequence of resources preceeded by a header; these resources may be compressed.
It is, also, quite common to find resources shared by several resource files.
The reason for this appears to be that that, back when hard disks were rare and hard
to come by, the games had to be playable from floppy disks. To prevent
unneccessary disk-jockeying, common stuff was placed in several resource files,
each of which was then stored on one disk.
</para>
</sect1>

<sect1>
<title/The individual resources: A summary/
<para>
The resource types of SCI0 can be roughly grouped into four sets:
<itemizedlist>
<ListItem><para>Graphics (pic, view, font, cursor)</para></ListItem>
<ListItem><para/Sound (patch, sound)/</ListItem>
<ListItem><para/Logic (script, vocab)/</ListItem>
<ListItem><para/Text/</ListItem>
</itemizedList>

Text resources are nothing more than a series of ASCIIZ strings; but the other
resources deserve further discussion.

</para>
<sect2>
<Title/Graphical resources summarized/
  <para>
    The screen graphics are compromised of the four graphics resources. The
    background pictures are drawn using vector-oriented commands from at least one
    pic resource (several resources may be overlaid). The fact that vector graphics
    were used for SCI0 allows for several interesting picture quality improvements.
    Pic resources also include two additional "screens": The priority screen, which
    marks parts of the pictures with a certain priority, so that other things with
    less priority can be fully or partially covered by them even if they are drawn
    at a later time, and the control screen, which delimits the walking area and
    some special places used by the game logic. FreeSCI uses a fourth auxiliary
    screen for during drawing time (this is a heritage from Carl Muckenhoupt's
    original code).
  </para>
  <para>
    View resources contain most of the games' pixmaps (multi-color bitmaps). Each
    view contains a list of loops, and each loop contains a list of cels. The cels
    themselves contain the actual image information: RLE encoded pixmaps with
    transparency information, and relative offsets.
  </para>
  <para>
    View resources are used for foreground images as well as for background images
    (for example, the "Spielburg" sign in QfG1 (EGA) is stored in a view resource
    and added to the background picture after it is drawn).
  </para>
  <para>
    The cursor resource contains simple bitmaps for drawing the mouse pointer. It
    only allows for black, white, and transparent pixels in SCI0.
  </para>
  <para>
    The fourth graphics resource is font data. It contains bitmapped fonts which
    are used to draw most of the text in the games. Text is used in one of four
    places: Text boxes, Text input fields, the title bar menu, and occasionally
    on-screen.
  </para>
</sect2>
<sect2>
<Title/Sound resources summarized/
<para>
SCI0 uses two types of resources for sound: Patch resources, and sound
resources. Sound resources contain a rather simple header, and music data
stored in a slightly modified version of the MIDI standard.
</para>
<para>
Patch resources contain device-dependant instrument mapping information for the
instruments used in the sound resources. SCI0 sound resources do not adhere to
the General Midi (GM) standard (which was, to my knowledge, written several
years after the first SCI0 game was released), though later SCI versions may do
so.
</para>
</sect2>

<sect2>
<title/Logic resources summarized/
<para>
Whenever the parser needs to look up a word, it looks for it in one of
the vocab resources. This is not the sole purpose of the vocab resources,
though; they provide information required by the debugger, including the help
text for the debugger help menu and the names of the various SCI opcodes
and kernel functions.
</para><para>
Script resources are the heart (or, rather, the brains) of the game. Consqeuently,
they also are its most complex aspects, containing class and object information,
local data, pointer relocation tables, and, of course, SCI bytecode.
</para><para>
To run the game, scripts are loaded on the SCI stack, their pointers are relocated
appropriately, and their functions are executed by a virtual machine. They use a set of 0x7d opcodes,
which may take either 8 or 16 bit parameters (so, effectively, there is twice
the amount of commands). The functions may refer to global data, local temporary
data, local function parameter data, or object data (selectors). They may,
additionally, indirectly refer to "hunk" data, which is stored outside of the
SCI heap. Since the whole design is object oriented, functions may
re-use or overload the functions of their superclasses.
</para>
</sect2>
</sect1>

<sect1>
<title/SCI01 extensions/
<para>
  SCI01 differs only in very few respects: It uses different compression
  algorithms (all of which are supported since FreeSCI 0.2.1), and a
  different type of sound resources, which may contain digitized sound effects
  (PCM data). The basic music data, however, still resembles MIDI data.
</para>
<para>
  Also, scripts are split into two parts when loaded: A dynamic part, which
  resides in the heap as before, and a static part, which is stored externally
  to conserve heap space.
  <footnote>
    <para>
      The background for this is that heap space started running out in Quest for Glory 2.
      In order to compensate for this, changes were made to both the script library and the
      interpreter.
    </para>
  </footnote>
</para>
</sect1>


<sect1>
  <title/SCI1 extensions/
<para>
  SCI1, which is not covered by FreeSCI at the moment, introduces new concepts
  like Palettes, scaled bitmap images and several new compression algorithms.
  In SCI1.0, the resource limit was first increased to 16383
  <footnote>
    <para>
      This <emphasis>appears</emphasis> to be the limit- none of the
      SCI1.0 games I tested used resource numbers beyond 16383
    </para>
  </footnote>
  , and then to 65535 in SCI1. Because of the inherent limitations of the FAT file
  system the primary target OS of Sierra's SCI interpreter was limited to, patch
  file names were altered accordingly, with the resource number (not padded) before
  the dot and a three-letter resource ID behind it; examples are "0.scr" or "100.v56".
</para>
<para>
  The complete list of suffixes is as follows:
  <simplelist>
    <member>80: v56: 256 color views</member>
    <member>81: p56: 256 color background pictures</member>
    <member>82: scr: Scripts (static data)</member>
    <member>83: tex: Texts (apparently deprecated in favor of messages)</member>
    <member>84: snd: Sound data (MIDI music)</member>
    <member>86<footnote><para>Type 0x85 resources are 'memory' resources, which are only used internally.</para></footnote>
      :voc: Vocabulary (not used)</member>
    <member>87: fon: Fonts</member>
    <member>88: cur: Mouse cursors (deprecated in favor of v56-based cursors)</member>
    <member>89: pat: Audio patch files</member>
    <member>8a: bit: Bitmap files (purpose unknown)</member>
    <member>8b: pal: 256 color palette files</member>
    <member>8c: cda: CD Audio resources</member>
    <member>8d: aud: Audio resources (probably sound effects)</member>
    <member>8e: syn: Sync (purpose unknown)</member>
    <member>8f: msg: Message resources: Text plus metadata</member>
    <member>90: map: Map (purpose unknown)</member>
    <member>91: hep: Heap resources: Dynamic script data</member>
  </simplelist>
  Apparently, the script resource split introduced in SCI01 was incorporated into the actual resource layout
  in SCI1.
</sect1>

<sect1><title/Sierra SCI games/
  <para>
     <author><firstname/Paul David/<surname/Doherty/</author>
  </para>
   <sect2><title/SCI0 games/
      <para>
        <informaltable frame="all">
            <tgroup cols="3">
               <thead>
                 <row>
                  <entry/Game name/
                  <entry/Game ID/
                  <entry/Version numbers/
                 </row>
               </thead>
               <tbody>
  <row><entry/Season's Greetings (1988)/<entry/DEMO/<entry/0.000.294/</row>
  <row><entry/Leisure Suit Larry Goes Looking For Love (In Several Wrong Places)/
             <entry/LSL2/<entry/0.000.343, 0.000.409/</row>
  <row><entry/Police Quest 2: The Vengeance/<entry/PQ2/<entry/0.000.395, 0.000.490/</row>
  <row><entry/Space Quest 3: The Pirates of Pestulon/<entry/SQ3/<entry/0.000.453, 0.000.685/</row>
  <row><entry/King's Quest IV: The Perils of Rosella/<entry/KQ4/<entry/0.000.502/</row>
  <row><entry/Fun Seeker's Guide/<entry/emc/<entry/0.000.506/</row>
  <row><entry/Hoyle's Book of Games 1/<entry/cardGames/<entry/0.000.530, 0.000.685/</row>
  <row><entry/Hero's Quest: So you want to be a hero/<entry/HQ/<entry/0.000.566/</row>
  <row><entry/Leisure Suit Larry 3: Passionate Patti In Pursuit Of The Pulsating Pectorals!/
             <entry/LSL3/<entry/0.000.572/</row>
  <row><entry/Quest for Glory I: So you want to be a hero/<entry/Glory/<entry/0.000.629/</row>
  <row><entry/The Colonel's Bequest/<entry/CB1/<entry/0.000.631/</row>
  <row><entry/Codename: Iceman/<entry/iceMan/<entry/0.000.668, 0.000.685/</row>
  <row><entry/Conquest of Camelot/<entry/ARTHUR/<entry/0.000.685/</row>
               </tbody>
           </tgroup>
         </informaltable>
     </para>
    </sect2>

   <sect2><title/SCI01 games/
      <para>
        <informaltable frame="all">
            <tgroup cols="3">
               <thead>
                 <row>
                  <entry/Game name/
                  <entry/Game ID/
                  <entry/Version numbers/
                 </row>
               </thead>
               <tbody>
  <row><entry/King's Quest I: Quest for the crown (SCI remake)/<entry/KQ1/<entry/S.old.010/</row>
  <row><entry/Quest for Glory II: Trial by fire/<entry/Trial/<entry/1.000.072/</row>
  <row><entry/[Christmas greeting card 1990]/<entry/?/<entry/1.000.172, 1.000.174/</row>
               </tbody>
           </tgroup>
         </informaltable>
     </para>
    </sect2>


   <sect2><title/SCI1.0 games/
      <para>
        <informaltable frame="all">
            <tgroup cols="3">
               <thead>
                 <row>
                  <entry/Game name/
                  <entry/Game ID/
                  <entry/Version numbers/
                 </row>
               </thead>
               <tbody>
  <row><entry/Jones in the fast lane (VGA version)/<entry/?/<entry/x.yyy.zzz/</row>
  <row><entry/Conquest of the Longbow/<entry/?/<entry/1.000.168/</row>
  <row><entry/Leisure Suit Larry In The Land Of The Lounge Lizards/
             <entry/?/<entry/1.000.577/</row>
  <row><entry/King's Quest V: Absence makes the heart go yonder (french)/
             <entry/?/<entry/1.000.784/</row>
  <row><entry/Space Qust 1: The Sarien Encounter (VGA remake)/<entry/?/<entry/T.A00.081/</row>
  <row><entry/Leisure Suit Larry 5: Passionate Patti Does A Little Undercover Work/
             <entry/?/<entry/T.A00.169/</row>
  <row><entry/Police Quest 3: The Kindred/<entry/?/<entry/T.A00.178/</row>
               </tbody>
           </tgroup>
         </informaltable>
     </para>
    </sect2>

   <sect2><title/SCI1.1 games/
      <para>
        <informaltable frame="all">
            <tgroup cols="3">
               <thead>
                 <row>
                  <entry/Game name/
                  <entry/Game ID/
                  <entry/Version numbers/
                 </row>
               </thead>
               <tbody>
  <row><entry/Police Quest 1: The Death Angel (VGA remake)/<entry/?/<entry/1.001.029/</row>
  <row><entry/Quest for Glory III: Wages of War (aka Seekers of the Lost City)/
             <entry/?/<entry/1.001.050/</row>
  <row><entry/King's Quest VI: To heir is human (german version)/<entry/?/<entry/1.001.054/</row>
  <row><entry/[Christmas greeting card 1992]/<entry/?/<entry/1.001.055/</row>
  <row><entry/Space Quest IV: Roger Wilco and the Time Rippers/<entry/?/<entry/1.001.064/</row>
  <row><entry/Space Quest V: The Next Mutation/<entry/?/<entry/1.001.068/</row>
  <row><entry/Freddy Pharkas: Frontier Pharmacist (demo)/<entry/?/<entry/1.001.069/</row>
  <row><entry/Laura Bow and the Dagger of Amon Ra/<entry/?/<entry/1.001.072/</row>
  <row><entry/Leisure Suit Larry 6/<entry/?/<entry/1.001.113/</row>
  <row><entry/Quest for Glory 1: So you want to be a hero (VGA remake)/<entry/?/<entry/L.rry.021/</row>
  <row><entry/Quest for Glory 3: Der Lohn des Krieges (german version)/
              <entry/?/<entry/L.rry.083/</row>
  <row><entry/Freddy Pharkas, Frontier Pharmacist/<entry/?/<entry/1.cfs.081/</row>
  <row><entry/King's Quest VI: To heir is human/<entry/?/<entry/1.cfs.158/</row>
               </tbody>
           </tgroup>
         </informaltable>
     </para>
    </sect2>

</sect1>
</chapter>

<chapter>
  <title>Resource files</title>
  <para>
  with major contributions from <author><firstname>Petr</firstname> <surname>Vyhnak</surname></author>
  </para><para>
    In order to allow games to be both distributeable and playable from
    several floppy disks, SCI was designed to support multi-volume data.
    The data itself could therefore be spread into separate files,
    with some of the more common resources present in more than one of
    them. The global index for these files was a "resource.map" file,
    which was read during startup and present on the same disk as the
    interpreter itself. This file contained a linear lookup table that
    mapped resource type/number tuples to a set of resource number/
    offset tuples, which they could subsequently be read from.
  </para>
  <sect1>
    <title>SCI0 resources</title>
    <sect2>
      <title>resource.map</title>
      <para>
	The SCI0 map file format is pretty simple:
	It consists of 6-byte entries, terminated by the sequence 0xffff ffff ffff.
	The first 2 bytes, interpreted as little endian 16 bit integer, encode
	resource type (high 5 bits) and number (low 11 bits). The next 4 bytes
	are a 32 bit LE integer that contains the resource file number in the high 6 bits,
	and the absolute offset within the file in the low 26 bits.
	SCI0 performs a linear search to find the resource; however, multiple entries may
	match the search, since resources may be present more than once (the inverse
	mapping is not injective).
      </para>
    </sect2>
    <sect2>
      <title>resource.nr</title>
      <para>
	SCI0 resource entries start with a four-tuple of little endian 16 bit words,
	which we will call (<literal/id/, <literal/comp_size/, <literal/decomp_size/, <literal/method/).
	<literal>id</literal> has the usual SCI0 semantics (high 5 are the resource type, low 11 are
	  its number). <literal>comp_size</literal> and <literal>decomp_size</literal> are the
	  size of the compressed and the decompressed resource, respectively. The compressed size
	  actually starts counting at the record position of <literal>decomp_size</literal>, so
	  it counts four bytes in addition to the actual content. <literal>method</literal>, finally,
	  is the compression method used to store the data.
      </para>
    </sect2>
  </sect1>
  <sect1>
    <title>SCI1 resources</title>
    <sect2>
      <title>resource.map</title>
      <para>
	The SCI1 resource.map starts with an array of 3-byte structures where the 1st 
	byte is
	the resource type (0x80 ... 0x91) and next 2 bytes (interpreted as little-endian 16 bit integer) represent the absolute offset
	of the resource's lookup table (within resource.map). This first array is terminated by a
	3-byte entry with has 0xFF as a type
	and the offset pointing to the first byte after the last resource type's lookup table.
	SCI1 first goes through this list
	to find the start of list for the correct resource type and remember this 
	offset and the offset from the next entry
	to know where it ends. The resulting interval contains a sorted list of
	6-byte structures, 
	where the first LE 16 bit integer is the resource number, and the next LE 32 bit integer
	contains the resource
	file number in its high 4 bits and the absolute resource offset (in the indicated resource file) in its low 28 bits.
	Because the list is sorted and its length is known, Sierra SCI can use binary search to locate the resource ID it is looking for.
      </para>
    </sect2>
    <sect2>
      <title>resource.nr</title>
      <para>
	Later versions of SCI1 changed the resource file structure slightly:
	The resource header now contains a byte describing the resource's type, and a four-tuple
	(<literal/res_nr/, <literal/comp_size/, <literal/decomp_size/, <literal/method/), where
	<literal>comp_size</literal>, <literal>decomp_size</literal>, and <literal>method</literal> have
	  the same meanings as before (with the exception of <literal>method</literal> referring to different algorithms),
	  while res_nr is simply the resource's number.
      </para>
    </sect2>
  </sect1>
  <sect1>
    <title>Decompression algorithms</title>
    <para>
      The decompression algorithms used in SCI are as follows:
      <table frame="all">
	<title>SCI0 compression algorithms</title>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>method</entry>
	      <entry>algorithm</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>0</entry>
	      <entry>uncompressed</entry>
	    </row>
	    <row>
	      <entry>1</entry>
	      <entry>LZW</entry>
	    </row>
	    <row>
	      <entry>2</entry>
	      <entry>HUFFMAN</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <table frame="all">
	<title>SCI01 compression algorithms</title>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>method</entry>
	      <entry>algorithm</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>0</entry>
	      <entry>uncompressed</entry>
	    </row>
	    <row>
	      <entry>1</entry>
	      <entry>LZW</entry>
	    </row>
	    <row>
	      <entry>2</entry>
	      <entry>COMP3</entry>
	    </row>
	    <row>
	      <entry>3</entry>
	      <entry>HUFFMAN</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>


      <table frame="all">
	<title>SCI1.0 compression algorithms</title>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>method</entry>
	      <entry>algorithm</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>0</entry>
	      <entry>uncompressed</entry>
	    </row>
	    <row>
	      <entry>1</entry>
	      <entry>LZW</entry>
	    </row>
	    <row>
	      <entry>2</entry>
	      <entry>COMP3</entry>
	    </row>
	    <row>
	      <entry>3</entry>
	      <entry>UNKNOWN-0</entry>
	    </row>
	    <row>
	      <entry>4</entry>
	      <entry>UNKNOWN-1</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>


      <table frame="all">
	<title>SCI1.1 compression algorithms</title>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>method</entry>
	      <entry>algorithm</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>0</entry>
	      <entry>uncompressed</entry>
	    </row>
	    <row>
	      <entry>18</entry>
	      <entry>UNKNOWN-2</entry>
	    </row>
	    <row>
	      <entry>19</entry>
	      <entry>UNKNOWN-3</entry>
	    </row>
	    <row>
	      <entry>20</entry>
	      <entry>UNKNOWN-4</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

    </para>
    <sect2>
      <title>Decompression algorithm LZW</title>
      <para>
	The LZW algorithm itself, when used for compression or decompression in an apparatus (sic)
	designed for compression and decompression, has been patented by Unisys in Japan, Europe, and
	the United States. Fortunately, FreeSCI only needs LZW decompression, which means that it
	does not match the description of the apparatus as given above. (Further, patents on
	software are (at the time of this writing) not enforceable in Europe, where the FreeSCI
	implementation of the LZW decompressor was written).
      </para>
      <para>
	<!-- fixme -->
	  WriteMe.
      </para>
    </sect2>
    <sect2 id="decomp-huffman">
      <title>Decompression algorithm HUFFMAN</title>
      <para>
	This is an implementation of a simple huffman token decoder, which looks up tokens in a huffman tree.
	A <emphasis>huffman tree</emphasis> is a hollow binary search tree. This means that all inner nodes, usually
	including the root, are empty, and have two siblings. The tree's leaves contain the actual information.
	<programlisting>
FUNCTION get_next_bit(): Boolean;
/* This function reads the next bit from the input stream. Reading starts at the MSB. */


FUNCTION get_next_byte(): Byte
VAR
    i: Integer;
    literal: Byte;
BEGIN
    literal := 0;
    FOR i := 0 to 7 DO
        literal := (literal << 1) | get_next_bit();
    OD
    RETURN literal;
END


FUNCTION get_next_char(nodelist : Array of Nodes, index : Integer): (Char, Boolean)
VAR
    left, right: Integer;
    literal : Char;
    node : Node;
BEGIN
    Node := nodelist[index];

    IF node.siblings == 0 THEN
	RETURN (node.value, False);
    ELSE BEGIN
       left := (node.siblings & 0xf0) >> 4;
       right := (node.siblings & 0x0f);

       IF get_next_bit() THEN BEGIN
	   IF right == 0 THEN /* Literal token */
	       literal := ByteToChar(get_next_byte());

	       RETURN (literal, True);
	   ELSE
	       RETURN get_next_char(nodelist, index + right)
        END ELSE
	        RETURN get_next_char(nodelist, index + left)
    END
END
	</programlisting>
	The function get_next_char() is executed until its second return value is True (i.e.
	if a value was read directly from the input stream) while the first return value equals
	a certain terminator character, which is the first byte stored in the compressed resource:
	<informaltable frame="none">
	  <tgroup cols="3">
	    <thead>
	      <row>
		<entry>Offset</entry>
		<entry>Name</entry>
		<entry>Meaning</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>0</entry>
		<entry>terminator</entry>
		<entry>Terminator character</entry>
	      </row>
	      <row>
		<entry>1</entry>
		<entry>nodes</entry>
		<entry>Number of nodes</entry>
	      </row>
	      <row>
		<entry>2 + i*2</entry>
		<entry>nodelist[i].value</entry>
		<entry>Value of node #i (0 &le; i < nodes)</entry>
	      </row>
	      <row>
		<entry>3 + i*2</entry>
		<entry>nodelist[i].siblings</entry>
		<entry>Sibling nodes of node #i</entry>
	      </row>
	      <row>
		<entry>2 + nodes*2</entry>
		<entry>data[]</entry>
		<entry>The actual compressed data</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
	where nodelist[0] is the root node.
      </para>
    </sect2>
    <sect2>
      <title>Decompression algorithm COMP3</title>
      <para>
	<!-- fixme -->
	  WriteMe.
      </para>
    </sect2>
    <sect2>
      <title>Decompression algorithm DCL-EXPLODE</title>
      <para>
	originally by <author><firstname>Petr</firstname> <surname>Vyhnak</surname></author>
      </para>
      <note><para>
	This algorithm matches one or more of the UNKNOWN algorithms.
      </para></note>
      <para>
	This algorithm is based on the Deflate algorithm described in the Internet RFC 1951 (see also
	RFC 1950 for related material).
      </para>
      <para>
	The algorithm is quite similar to the explode algorithm (ZIP method #6 - implode ) but 
	there are differences.
	<programlisting>
	/* The first 2 bytes are parameters */

P1 = ReadByte(); /* 0 or 1 */
	/* I think this means 0=binary and 1=ascii file, but in RESOURCEs I saw always 0 */

P2 = ReadByte();
	/* must be 4,5 or 6 and it is a parameter for the decompression algorithm */


/* Now, a bit stream follows, which is decoded as described below: */


LOOP:
     read 1 bit (take bits from the lowest value (LSB) to the MSB i.e. bit 0, bit 1 etc ...)
         - if the bit is 0 read 8 bits and write it to the output as it is.
         - if the bit is 1 we have here a length/distance pair:
                 - decode a number with Hufmman Tree #1; variable bit length, result is 0x00 .. 0x0F -&gt; L1
                   if L1 &lt;= 7:
                         LENGTH = L1 + 2
                   if L1 &gt; 7
                         read more (L1-7) bits -&gt; L2
                         LENGTH = L2 + M[L1-7] + 2

                 - decode another number with Hufmann Tree #2 giving result 0x00..0x3F -&gt; D1
                   if LENGTH == 2
                         D1 = D1 &lt;&lt; 2
                         read 2 bits -&gt; D2
                   else
                         D1 = D1 &lt;&lt; P2  // the parameter 2
                         read P2 bits -&gt; D2

                   DISTANCE = (D1 | D2) + 1

                 - now copy LENGTH bytes from (output_ptr-DISTANCE) to output_ptr
END LOOP

	</programlisting>
	The algorithm terminates as soon as it runs out of bits. The data structures used
	are as follows:
	</para>
	<sect3>
	  <title>M</title>
	  <para>
	    M is a constant array defined as M[0] = 7,  M[n+1] = M[n]+ 2^n.
	    That means M[1] = 8, M[2] = 0x0A, M[3] = 0x0E, M[4] = 0x16, M[5] = 0x26, etc.
	  </para>
	</sect3>

	<sect3>
	  <title>Huffman Tree #1</title>
	  <para>
	    The first huffman tree (<xref linkend="decomp-huffman">) contains the length values. It is described by the following table:

	    <informaltable>
	      <tgroup cols="2">
		<thead>
		  <row>
		    <entry>value (hex)</entry>
		    <entry>code (binary)</entry>
		  </row>
		</thead>
		<tbody>
		  <row> <entry>0</entry> <entry>101</entry> </row>
		  <row> <entry>1</entry> <entry>11</entry> </row>
		  <row> <entry>2</entry> <entry>100</entry> </row>
		  <row> <entry>3</entry> <entry>011</entry> </row>
		  <row> <entry>4</entry> <entry>0101</entry> </row>
		  <row> <entry>5</entry> <entry>0100</entry> </row>
		  <row> <entry>6</entry> <entry>0011</entry> </row>
		  <row> <entry>7</entry> <entry>0010 1</entry> </row>
		  <row> <entry>8</entry> <entry>0010 0</entry> </row>
		  <row> <entry>9</entry> <entry>0001 1</entry> </row>
		  <row> <entry>a</entry> <entry>0001 0</entry> </row>
		  <row> <entry>b</entry> <entry>0000 11</entry> </row>
		  <row> <entry>c</entry> <entry>0000 10</entry> </row>
		  <row> <entry>d</entry> <entry>0000 01</entry> </row>
		  <row> <entry>e</entry> <entry>0000 001</entry> </row>
		  <row> <entry>f</entry> <entry>0000 000</entry> </row>
		</tbody>
	      </tgroup>
	    </informaltable>
	    where bits should be read from the left to the right.
	  </para>
	</sect3>

	<sect3>
	  <title>Huffman Tree #2</title>
	  <para>
	    The second huffman code tree contains the distance values. It can be built from the following table:
	    <informaltable>
	      <tgroup cols="2">
		<thead>
		  <row>
		    <entry>value (hex)</entry>
		    <entry>code (binary)</entry>
		  </row>
		</thead>
		<tbody>
		  <row> <entry>00</entry> <entry>11</entry> </row>
		  <row> <entry>01</entry> <entry>1011</entry> </row>
		  <row> <entry>02</entry> <entry>1010</entry> </row>
		  <row> <entry>03</entry> <entry>1001 1</entry> </row>
		  <row> <entry>04</entry> <entry>1001 0</entry> </row>
		  <row> <entry>05</entry> <entry>1000 1</entry> </row>
		  <row> <entry>06</entry> <entry>1000 0</entry> </row>
		  <row> <entry>07</entry> <entry>0111 11</entry> </row>
		  <row> <entry>08</entry> <entry>0111 10</entry> </row>
		  <row> <entry>09</entry> <entry>0111 01</entry> </row>
		  <row> <entry>0a</entry> <entry>0111 00</entry> </row>
		  <row> <entry>0b</entry> <entry>0110 11</entry> </row>
		  <row> <entry>0c</entry> <entry>0110 10</entry> </row>
		  <row> <entry>0d</entry> <entry>0110 01</entry> </row>
		  <row> <entry>0e</entry> <entry>0110 00</entry> </row>
		  <row> <entry>0f</entry> <entry>0101 11</entry> </row>
		  <row> <entry>10</entry> <entry>0101 10</entry> </row>
		  <row> <entry>11</entry> <entry>0101 01</entry> </row>
		  <row> <entry>12</entry> <entry>0101 00</entry> </row>
		  <row> <entry>13</entry> <entry>0100 11</entry> </row>
		  <row> <entry>14</entry> <entry>0100 10</entry> </row>
		  <row> <entry>15</entry> <entry>0100 01</entry> </row>
		  <row> <entry>16</entry> <entry>0100 001</entry> </row>
		  <row> <entry>17</entry> <entry>0100 000</entry> </row>
		  <row> <entry>18</entry> <entry>0011 111</entry> </row>
		  <row> <entry>19</entry> <entry>0011 110</entry> </row>
		  <row> <entry>1a</entry> <entry>0011 101</entry> </row>
		  <row> <entry>1b</entry> <entry>0011 100</entry> </row>
		  <row> <entry>1c</entry> <entry>0011 011</entry> </row>
		  <row> <entry>1d</entry> <entry>0011 010</entry> </row>
		  <row> <entry>1e</entry> <entry>0011 001</entry> </row>
		  <row> <entry>1f</entry> <entry>0011 000</entry> </row>
		  <row> <entry>20</entry> <entry>0010 111</entry> </row>
		  <row> <entry>21</entry> <entry>0010 110</entry> </row>
		  <row> <entry>22</entry> <entry>0010 101</entry> </row>
		  <row> <entry>23</entry> <entry>0010 100</entry> </row>
		  <row> <entry>24</entry> <entry>0010 011</entry> </row>
		  <row> <entry>25</entry> <entry>0010 010</entry> </row>
		  <row> <entry>26</entry> <entry>0010 001</entry> </row>
		  <row> <entry>27</entry> <entry>0010 000</entry> </row>
		  <row> <entry>28</entry> <entry>0001 111</entry> </row>
		  <row> <entry>29</entry> <entry>0001 110</entry> </row>
		  <row> <entry>2a</entry> <entry>0001 101</entry> </row>
		  <row> <entry>2b</entry> <entry>0001 100</entry> </row>
		  <row> <entry>2c</entry> <entry>0001 011</entry> </row>
		  <row> <entry>2d</entry> <entry>0001 010</entry> </row>
		  <row> <entry>2e</entry> <entry>0001 001</entry> </row>
		  <row> <entry>2f</entry> <entry>0001 000</entry> </row>
		  <row> <entry>30</entry> <entry>0000 1111</entry> </row>
		  <row> <entry>31</entry> <entry>0000 1110</entry> </row>
		  <row> <entry>32</entry> <entry>0000 1101</entry> </row>
		  <row> <entry>33</entry> <entry>0000 1100</entry> </row>
		  <row> <entry>34</entry> <entry>0000 1011</entry> </row>
		  <row> <entry>35</entry> <entry>0000 1010</entry> </row>
		  <row> <entry>36</entry> <entry>0000 1001</entry> </row>
		  <row> <entry>37</entry> <entry>0000 1000</entry> </row>
		  <row> <entry>38</entry> <entry>0000 0111</entry> </row>
		  <row> <entry>39</entry> <entry>0000 0110</entry> </row>
		  <row> <entry>3a</entry> <entry>0000 0101</entry> </row>
		  <row> <entry>3b</entry> <entry>0000 0100</entry> </row>
		  <row> <entry>3c</entry> <entry>0000 0011</entry> </row>
		  <row> <entry>3d</entry> <entry>0000 0010</entry> </row>
		  <row> <entry>3e</entry> <entry>0000 0001</entry> </row>
		  <row> <entry>3f</entry> <entry>0000 0000</entry> </row>
		</tbody>
	      </tgroup>
	    </informaltable>
	    where bits should be read from the left to the right.
	  </para>
	</sect3>

      	<sect3>
	  <title>Huffman Tree #3</title>
	  <para>
	    This tree describes literal values for ASCII mode, which adds another
	    compression step to the algorithm.
	    <informaltable>
	      <tgroup cols="2">
		<thead>
		  <row>
		    <entry>value (hex)</entry>
		    <entry>code (binary)</entry>
		  </row>
		</thead>
		<tbody>
                  <row> <entry>00</entry> <entry>0000 1001 001</entry> </row>
                  <row> <entry>01</entry> <entry>0000 0111 1111 </entry> </row>
                  <row> <entry>02</entry> <entry>0000 0111 1110 </entry> </row>
                  <row> <entry>03</entry> <entry>0000 0111 1101 </entry> </row>
                  <row> <entry>04</entry> <entry>0000 0111 1100 </entry> </row>
                  <row> <entry>05</entry> <entry>0000 0111 1011 </entry> </row>
                  <row> <entry>06</entry> <entry>0000 0111 1010 </entry> </row>
                  <row> <entry>07</entry> <entry>0000 0111 1001 </entry> </row>
                  <row> <entry>08</entry> <entry>0000 0111 1000 </entry> </row>
                  <row> <entry>09</entry> <entry>0001 1101 </entry> </row>
                  <row> <entry>0a</entry> <entry>0100 011</entry> </row>
                  <row> <entry>0b</entry> <entry>0000 0111 0111 </entry> </row>
                  <row> <entry>0c</entry> <entry>0000 0111 0110 </entry> </row>
                  <row> <entry>0d</entry> <entry>0100 010</entry> </row>
                  <row> <entry>0e</entry> <entry>0000 0111 0101 </entry> </row>
                  <row> <entry>0f</entry> <entry>0000 0111 0100 </entry> </row>
                  <row> <entry>10</entry> <entry>0000 0111 0011 </entry> </row>
                  <row> <entry>11</entry> <entry>0000 0111 0010 </entry> </row>
                  <row> <entry>12</entry> <entry>0000 0111 0001 </entry> </row>
                  <row> <entry>13</entry> <entry>0000 0111 0000 </entry> </row>
                  <row> <entry>14</entry> <entry>0000 0110 1111 </entry> </row>
                  <row> <entry>15</entry> <entry>0000 0110 1110 </entry> </row>
                  <row> <entry>16</entry> <entry>0000 0110 1101 </entry> </row>
                  <row> <entry>17</entry> <entry>0000 0110 1100 </entry> </row>
                  <row> <entry>18</entry> <entry>0000 0110 1011 </entry> </row>
                  <row> <entry>19</entry> <entry>0000 0110 1010 </entry> </row>
                  <row> <entry>1a</entry> <entry>0000 0010 0100 1</entry> </row>
                  <row> <entry>1b</entry> <entry>0000 0110 1001 </entry> </row>
                  <row> <entry>1c</entry> <entry>0000 0110 1000 </entry> </row>
                  <row> <entry>1d</entry> <entry>0000 0110 0111 </entry> </row>
                  <row> <entry>1e</entry> <entry>0000 0110 0110 </entry> </row>
                  <row> <entry>1f</entry> <entry>0000 0110 0101 </entry> </row>
                  <row> <entry>20</entry> <entry>1111 </entry> </row>
                  <row> <entry>21</entry> <entry>0000 1010 01</entry> </row>
                  <row> <entry>22</entry> <entry>0001 1100 </entry> </row>
                  <row> <entry>23</entry> <entry>0000 0110 0100 </entry> </row>
                  <row> <entry>24</entry> <entry>0000 1010 00</entry> </row>
                  <row> <entry>25</entry> <entry>0000 0110 0011 </entry> </row>
                  <row> <entry>26</entry> <entry>0000 1001 11</entry> </row>
                  <row> <entry>27</entry> <entry>0001 1011 </entry> </row>
                  <row> <entry>28</entry> <entry>0100 001</entry> </row>
                  <row> <entry>29</entry> <entry>0100 000</entry> </row>
                  <row> <entry>2a</entry> <entry>0001 1010 </entry> </row>
                  <row> <entry>2b</entry> <entry>0000 1101 1</entry> </row>
                  <row> <entry>2c</entry> <entry>0011 111</entry> </row>
                  <row> <entry>2d</entry> <entry>1001 01</entry> </row>
                  <row> <entry>2e</entry> <entry>0011 110</entry> </row>
                  <row> <entry>2f</entry> <entry>0001 1001 </entry> </row>
                  <row> <entry>30</entry> <entry>0011 101</entry> </row>
                  <row> <entry>31</entry> <entry>1001 00</entry> </row>
                  <row> <entry>32</entry> <entry>0011 100</entry> </row>
                  <row> <entry>33</entry> <entry>0011 011</entry> </row>
                  <row> <entry>34</entry> <entry>0011 010</entry> </row>
                  <row> <entry>35</entry> <entry>0011 001</entry> </row>
                  <row> <entry>36</entry> <entry>0001 1000 </entry> </row>
                  <row> <entry>37</entry> <entry>0011 000</entry> </row>
                  <row> <entry>38</entry> <entry>0010 111</entry> </row>
                  <row> <entry>39</entry> <entry>0001 0111 </entry> </row>
                  <row> <entry>3a</entry> <entry>0001 0110 </entry> </row>
                  <row> <entry>3b</entry> <entry>0000 0110 0010 </entry> </row>
                  <row> <entry>3c</entry> <entry>0000 1001 000</entry> </row>
                  <row> <entry>3d</entry> <entry>0010 110</entry> </row>
                  <row> <entry>3e</entry> <entry>0000 1101 0</entry> </row>
                  <row> <entry>3f</entry> <entry>0000 1000 111</entry> </row>
                  <row> <entry>40</entry> <entry>0000 0110 0001 </entry> </row>
                  <row> <entry>41</entry> <entry>1000 11</entry> </row>
                  <row> <entry>42</entry> <entry>0010 101</entry> </row>
                  <row> <entry>43</entry> <entry>1000 10</entry> </row>
                  <row> <entry>44</entry> <entry>1000 01</entry> </row>
                  <row> <entry>45</entry> <entry>1110 1</entry> </row>
                  <row> <entry>46</entry> <entry>0010 100</entry> </row>
                  <row> <entry>47</entry> <entry>0001 0101 </entry> </row>
                  <row> <entry>48</entry> <entry>0001 0100 </entry> </row>
                  <row> <entry>49</entry> <entry>1000 00</entry> </row>
                  <row> <entry>4a</entry> <entry>0000 1000 110</entry> </row>
                  <row> <entry>4b</entry> <entry>0000 1100 1</entry> </row>
                  <row> <entry>4c</entry> <entry>0111 11</entry> </row>
                  <row> <entry>4d</entry> <entry>0010 011</entry> </row>
                  <row> <entry>4e</entry> <entry>0111 10</entry> </row>
                  <row> <entry>4f</entry> <entry>0111 01</entry> </row>
                  <row> <entry>50</entry> <entry>0010 010</entry> </row>
                  <row> <entry>51</entry> <entry>0000 1000 101</entry> </row>
                  <row> <entry>52</entry> <entry>0111 00</entry> </row>
                  <row> <entry>53</entry> <entry>0110 11</entry> </row>
                  <row> <entry>54</entry> <entry>0110 10</entry> </row>
                  <row> <entry>55</entry> <entry>0010 001</entry> </row>
                  <row> <entry>56</entry> <entry>0000 1100 0</entry> </row>
                  <row> <entry>57</entry> <entry>0001 0011 </entry> </row>
                  <row> <entry>58</entry> <entry>0000 1011 1</entry> </row>
                  <row> <entry>59</entry> <entry>0000 1011 0</entry> </row>
                  <row> <entry>5a</entry> <entry>0000 1000 100</entry> </row>
                  <row> <entry>5b</entry> <entry>0001 0010 </entry> </row>
                  <row> <entry>5c</entry> <entry>0000 1000 011</entry> </row>
                  <row> <entry>5d</entry> <entry>0000 1010 1</entry> </row>
                  <row> <entry>5e</entry> <entry>0000 0110 0000 </entry> </row>
                  <row> <entry>5f</entry> <entry>0001 0001 </entry> </row>
                  <row> <entry>60</entry> <entry>0000 0101 1111 </entry> </row>
                  <row> <entry>61</entry> <entry>1110 0</entry> </row>
                  <row> <entry>62</entry> <entry>0110 01</entry> </row>
                  <row> <entry>63</entry> <entry>0110 00</entry> </row>
                  <row> <entry>64</entry> <entry>0101 11</entry> </row>
                  <row> <entry>65</entry> <entry>1101 1</entry> </row>
                  <row> <entry>66</entry> <entry>0101 10</entry> </row>
                  <row> <entry>67</entry> <entry>0101 01</entry> </row>
                  <row> <entry>68</entry> <entry>0101 00</entry> </row>
                  <row> <entry>69</entry> <entry>1101 0</entry> </row>
                  <row> <entry>6a</entry> <entry>0000 1000 010</entry> </row>
                  <row> <entry>6b</entry> <entry>0010 000</entry> </row>
                  <row> <entry>6c</entry> <entry>1100 1</entry> </row>
                  <row> <entry>6d</entry> <entry>0100 11</entry> </row>
                  <row> <entry>6e</entry> <entry>1100 0</entry> </row>
                  <row> <entry>6f</entry> <entry>1011 1</entry> </row>
                  <row> <entry>70</entry> <entry>0100 10</entry> </row>
                  <row> <entry>71</entry> <entry>0000 1001 10</entry> </row>
                  <row> <entry>72</entry> <entry>1011 0</entry> </row>
                  <row> <entry>73</entry> <entry>1010 1</entry> </row>
                  <row> <entry>74</entry> <entry>1010 0</entry> </row>
                  <row> <entry>75</entry> <entry>1001 1</entry> </row>
                  <row> <entry>76</entry> <entry>0001 0000 </entry> </row>
                  <row> <entry>77</entry> <entry>0001 111</entry> </row>
                  <row> <entry>78</entry> <entry>0000 1111 </entry> </row>
                  <row> <entry>79</entry> <entry>0000 1110 </entry> </row>
                  <row> <entry>7a</entry> <entry>0000 1001 01</entry> </row>
                  <row> <entry>7b</entry> <entry>0000 1000 001</entry> </row>
                  <row> <entry>7c</entry> <entry>0000 1000 000</entry> </row>
                  <row> <entry>7d</entry> <entry>0000 0101 1110 </entry> </row>
                  <row> <entry>7e</entry> <entry>0000 0101 1101 </entry> </row>
                  <row> <entry>7f</entry> <entry>0000 0101 1100 </entry> </row>
                  <row> <entry>80</entry> <entry>0000 0010 0100 0</entry> </row>
                  <row> <entry>81</entry> <entry>0000 0010 0011 1</entry> </row>
                  <row> <entry>82</entry> <entry>0000 0010 0011 0</entry> </row>
                  <row> <entry>83</entry> <entry>0000 0010 0010 1</entry> </row>
                  <row> <entry>84</entry> <entry>0000 0010 0010 0</entry> </row>
                  <row> <entry>85</entry> <entry>0000 0010 0001 1</entry> </row>
                  <row> <entry>86</entry> <entry>0000 0010 0001 0</entry> </row>
                  <row> <entry>87</entry> <entry>0000 0010 0000 1</entry> </row>
                  <row> <entry>88</entry> <entry>0000 0010 0000 0</entry> </row>
                  <row> <entry>89</entry> <entry>0000 0001 1111 1</entry> </row>
                  <row> <entry>8a</entry> <entry>0000 0001 1111 0</entry> </row>
                  <row> <entry>8b</entry> <entry>0000 0001 1110 1</entry> </row>
                  <row> <entry>8c</entry> <entry>0000 0001 1110 0</entry> </row>
                  <row> <entry>8d</entry> <entry>0000 0001 1101 1</entry> </row>
                  <row> <entry>8e</entry> <entry>0000 0001 1101 0</entry> </row>
                  <row> <entry>8f</entry> <entry>0000 0001 1100 1</entry> </row>
                  <row> <entry>90</entry> <entry>0000 0001 1100 0</entry> </row>
                  <row> <entry>91</entry> <entry>0000 0001 1011 1</entry> </row>
                  <row> <entry>92</entry> <entry>0000 0001 1011 0</entry> </row>
                  <row> <entry>93</entry> <entry>0000 0001 1010 1</entry> </row>
                  <row> <entry>94</entry> <entry>0000 0001 1010 0</entry> </row>
                  <row> <entry>95</entry> <entry>0000 0001 1001 1</entry> </row>
                  <row> <entry>96</entry> <entry>0000 0001 1001 0</entry> </row>
                  <row> <entry>97</entry> <entry>0000 0001 1000 1</entry> </row>
                  <row> <entry>98</entry> <entry>0000 0001 1000 0</entry> </row>
                  <row> <entry>99</entry> <entry>0000 0001 0111 1</entry> </row>
                  <row> <entry>9a</entry> <entry>0000 0001 0111 0</entry> </row>
                  <row> <entry>9b</entry> <entry>0000 0001 0110 1</entry> </row>
                  <row> <entry>9c</entry> <entry>0000 0001 0110 0</entry> </row>
                  <row> <entry>9d</entry> <entry>0000 0001 0101 1</entry> </row>
                  <row> <entry>9e</entry> <entry>0000 0001 0101 0</entry> </row>
                  <row> <entry>9f</entry> <entry>0000 0001 0100 1</entry> </row>
                  <row> <entry>a0</entry> <entry>0000 0001 0100 0</entry> </row>
                  <row> <entry>a1</entry> <entry>0000 0001 0011 1</entry> </row>
                  <row> <entry>a2</entry> <entry>0000 0001 0011 0</entry> </row>
                  <row> <entry>a3</entry> <entry>0000 0001 0010 1</entry> </row>
                  <row> <entry>a4</entry> <entry>0000 0001 0010 0</entry> </row>
                  <row> <entry>a5</entry> <entry>0000 0001 0001 1</entry> </row>
                  <row> <entry>a6</entry> <entry>0000 0001 0001 0</entry> </row>
                  <row> <entry>a7</entry> <entry>0000 0001 0000 1</entry> </row>
                  <row> <entry>a8</entry> <entry>0000 0001 0000 0</entry> </row>
                  <row> <entry>a9</entry> <entry>0000 0000 1111 1</entry> </row>
                  <row> <entry>aa</entry> <entry>0000 0000 1111 0</entry> </row>
                  <row> <entry>ab</entry> <entry>0000 0000 1110 1</entry> </row>
                  <row> <entry>ac</entry> <entry>0000 0000 1110 0</entry> </row>
                  <row> <entry>ad</entry> <entry>0000 0000 1101 1</entry> </row>
                  <row> <entry>ae</entry> <entry>0000 0000 1101 0</entry> </row>
                  <row> <entry>af</entry> <entry>0000 0000 1100 1</entry> </row>
                  <row> <entry>b0</entry> <entry>0000 0101 1011 </entry> </row>
                  <row> <entry>b1</entry> <entry>0000 0101 1010 </entry> </row>
                  <row> <entry>b2</entry> <entry>0000 0101 1001 </entry> </row>
                  <row> <entry>b3</entry> <entry>0000 0101 1000 </entry> </row>
                  <row> <entry>b4</entry> <entry>0000 0101 0111 </entry> </row>
                  <row> <entry>b5</entry> <entry>0000 0101 0110 </entry> </row>
                  <row> <entry>b6</entry> <entry>0000 0101 0101 </entry> </row>
                  <row> <entry>b7</entry> <entry>0000 0101 0100 </entry> </row>
                  <row> <entry>b8</entry> <entry>0000 0101 0011 </entry> </row>
                  <row> <entry>b9</entry> <entry>0000 0101 0010 </entry> </row>
                  <row> <entry>ba</entry> <entry>0000 0101 0001 </entry> </row>
                  <row> <entry>bb</entry> <entry>0000 0101 0000 </entry> </row>
                  <row> <entry>bc</entry> <entry>0000 0100 1111 </entry> </row>
                  <row> <entry>bd</entry> <entry>0000 0100 1110 </entry> </row>
                  <row> <entry>be</entry> <entry>0000 0100 1101 </entry> </row>
                  <row> <entry>bf</entry> <entry>0000 0100 1100 </entry> </row>
                  <row> <entry>c0</entry> <entry>0000 0100 1011 </entry> </row>
                  <row> <entry>c1</entry> <entry>0000 0100 1010 </entry> </row>
                  <row> <entry>c2</entry> <entry>0000 0100 1001 </entry> </row>
                  <row> <entry>c3</entry> <entry>0000 0100 1000 </entry> </row>
                  <row> <entry>c4</entry> <entry>0000 0100 0111 </entry> </row>
                  <row> <entry>c5</entry> <entry>0000 0100 0110 </entry> </row>
                  <row> <entry>c6</entry> <entry>0000 0100 0101 </entry> </row>
                  <row> <entry>c7</entry> <entry>0000 0100 0100 </entry> </row>
                  <row> <entry>c8</entry> <entry>0000 0100 0011 </entry> </row>
                  <row> <entry>c9</entry> <entry>0000 0100 0010 </entry> </row>
                  <row> <entry>ca</entry> <entry>0000 0100 0001 </entry> </row>
                  <row> <entry>cb</entry> <entry>0000 0100 0000 </entry> </row>
                  <row> <entry>cc</entry> <entry>0000 0011 1111 </entry> </row>
                  <row> <entry>cd</entry> <entry>0000 0011 1110 </entry> </row>
                  <row> <entry>ce</entry> <entry>0000 0011 1101 </entry> </row>
                  <row> <entry>cf</entry> <entry>0000 0011 1100 </entry> </row>
                  <row> <entry>d0</entry> <entry>0000 0011 1011 </entry> </row>
                  <row> <entry>d1</entry> <entry>0000 0011 1010 </entry> </row>
                  <row> <entry>d2</entry> <entry>0000 0011 1001 </entry> </row>
                  <row> <entry>d3</entry> <entry>0000 0011 1000 </entry> </row>
                  <row> <entry>d4</entry> <entry>0000 0011 0111 </entry> </row>
                  <row> <entry>d5</entry> <entry>0000 0011 0110 </entry> </row>
                  <row> <entry>d6</entry> <entry>0000 0011 0101 </entry> </row>
                  <row> <entry>d7</entry> <entry>0000 0011 0100 </entry> </row>
                  <row> <entry>d8</entry> <entry>0000 0011 0011 </entry> </row>
                  <row> <entry>d9</entry> <entry>0000 0011 0010 </entry> </row>
                  <row> <entry>da</entry> <entry>0000 0011 0001 </entry> </row>
                  <row> <entry>db</entry> <entry>0000 0011 0000 </entry> </row>
                  <row> <entry>dc</entry> <entry>0000 0010 1111 </entry> </row>
                  <row> <entry>dd</entry> <entry>0000 0010 1110 </entry> </row>
                  <row> <entry>de</entry> <entry>0000 0010 1101 </entry> </row>
                  <row> <entry>df</entry> <entry>0000 0010 1100 </entry> </row>
                  <row> <entry>e0</entry> <entry>0000 0000 1100 0</entry> </row>
                  <row> <entry>e1</entry> <entry>0000 0010 1011 </entry> </row>
                  <row> <entry>e2</entry> <entry>0000 0000 1011 1</entry> </row>
                  <row> <entry>e3</entry> <entry>0000 0000 1011 0</entry> </row>
                  <row> <entry>e4</entry> <entry>0000 0000 1010 1</entry> </row>
                  <row> <entry>e5</entry> <entry>0000 0010 1010 </entry> </row>
                  <row> <entry>e6</entry> <entry>0000 0000 1010 0</entry> </row>
                  <row> <entry>e7</entry> <entry>0000 0000 1001 1</entry> </row>
                  <row> <entry>e8</entry> <entry>0000 0000 1001 0</entry> </row>
                  <row> <entry>e9</entry> <entry>0000 0010 1001 </entry> </row>
                  <row> <entry>ea</entry> <entry>0000 0000 1000 1</entry> </row>
                  <row> <entry>eb</entry> <entry>0000 0000 1000 0</entry> </row>
                  <row> <entry>ec</entry> <entry>0000 0000 0111 1</entry> </row>
                  <row> <entry>ed</entry> <entry>0000 0000 0111 0</entry> </row>
                  <row> <entry>ee</entry> <entry>0000 0010 1000 </entry> </row>
                  <row> <entry>ef</entry> <entry>0000 0000 0110 1</entry> </row>
                  <row> <entry>f0</entry> <entry>0000 0000 0110 0</entry> </row>
                  <row> <entry>f1</entry> <entry>0000 0000 0101 1</entry> </row>
                  <row> <entry>f2</entry> <entry>0000 0010 0111 </entry> </row>
                  <row> <entry>f3</entry> <entry>0000 0010 0110 </entry> </row>
                  <row> <entry>f4</entry> <entry>0000 0010 0101 </entry> </row>
                  <row> <entry>f5</entry> <entry>0000 0000 0101 0</entry> </row>
                  <row> <entry>f6</entry> <entry>0000 0000 0100 1</entry> </row>
                  <row> <entry>f7</entry> <entry>0000 0000 0100 0</entry> </row>
                  <row> <entry>f8</entry> <entry>0000 0000 0011 1</entry> </row>
                  <row> <entry>f9</entry> <entry>0000 0000 0011 0</entry> </row>
                  <row> <entry>fa</entry> <entry>0000 0000 0010 1</entry> </row>
                  <row> <entry>fb</entry> <entry>0000 0000 0010 0</entry> </row>
                  <row> <entry>fc</entry> <entry>0000 0000 0001 1</entry> </row>
                  <row> <entry>fd</entry> <entry>0000 0000 0001 0</entry> </row>
                  <row> <entry>fe</entry> <entry>0000 0000 0000 1</entry> </row>
                  <row> <entry>ff</entry> <entry>0000 0000 0000 0</entry> </row>
		</tbody>
	      </tgroup>
	    </informaltable>
	    where bits should be read from the left to the right.
	  </para>
	</sect3>

    </sect2>

    <sect2>
      <title>Decompression algorithm UNKNOWN</title>
      <para>
	The algorithms listed as UNKNOWN-x have not yet been mapped to actual algorithms but
	are known to be used by the games. For some of them, it is possible that they match
	one of the algorithms described above, but have not yet been added to FreeSCI in an
	appropriate way (refer to DCL-EXPLODE for a good example).
      </para>
    </sect2>
  </sect1>
</chapter>

<chapter>
 <Title/The Graphics subsystem/
 <sect1>
 <Title/General stuff/
 <para>
 The graphics in SCI are generated using four resource types:
 <itemizedlist>
 <listitem><para/Pic resources for background pictures/</listitem>
 <listitem><para/View resources for images/</listitem>
 <listitem><para/Font resources for drawing text/</listitem>
 <listitem><para/Cursor resources for displaying the mouse pointer/</listitem>
 </itemizedlist>
 
 Those resources are drawn on three distinct screens:
 <itemizedlist>
 <listitem><para/The visual screen, used for displaying the actual pictures the player sees/</listitem>
 <listitem><para/The priority screen, which keeps information about how the depth of the screen/</listitem>
 <listitem><para/The control screen, which contains special information/</listitem>
 </itemizedlist>
 </para>
 </sect1>
 <sect1>
 <Title/SCI Ports/
 <para>
 <author><firstname/Lars/ <surname/Skovlund/ </author>

</para><para>
  Version 1.0,
  6. July 1999
</para><para>
 Note that the observations made in this document are
generally based on SCI version 0.000.572 (the one that comes with LSL3),
but should be valid even for SCI01 and SCI1, as well. I know already
about
some differences in the port system from SCI0 to SCI1, but I feel we
should
have an interpreter running for SCI0 before dealing with SCI1.
</para><para>
This article discusses a key data structure in SCI graphics handling;
this data structure is called a port, and it is involved in most
graphics-related
operations. The port is basically a graphics state record, storing
things
like pen color, current font, cursor position etc. Each port also has
an origin and a size. The actual port data structure has remained
absolutely
unchanged from SCI0 up to the latest versions of SCI1. 
</para><para>
The port can be viewed as a rectangle in which things are drawn. Every
drawing operation (even KDrawPic) is executed relative to the origin
coordinates of the current port (depending on the kernel function, other
parameters in the port structure are used as well), such that coordinate
(0, 0) in the "picture window" (such a thing really exists in SCI!) is
<emphasis/not/ the top of the screen, but rather the leftmost point underneath
the menu bar. The coordinate set (0,0) is called the local coordinates,
and its physical position on the screen, (0, 10), is called the global
coordinates. Kernel calls exist to ease conversion between the two
coordinate
systems, but they are, it appears, meant for event handlers to use, and
not generally usable (I think they take a pointer to an Event object as
a
parameter).
</para><para>
At least three ports are created and managed automatically by the SCI
interpreter. These are the "window manager" port, the menu port, and the
picture port (which is actually a window, see later). The latter two
should be fairly easy to understand. The menu bar is drawn in the menu
port,
and the current room is drawn in the picture port. What may be less
obvious
is that the window manager port is an "invisible" port, on which the
window
backgrounds are drawn, although the windows have a port themselves. If
you
are familiar with <Trademark>Windows</trademark>
programming, the term "client rectangle" may
ring a
bell here - SCI draws the window backgrounds, using values in the window
manager port, while the window's own port controls what is drawn inside
it.
The window manager port covers the same bounding rectangle as the
picture
window, but it is transparent so it doesn't mess up the graphics.
</para><para>
I feel compelled to mention windows for a bit here, not in depth - they
are
the subject of a later article - but just to mention that the structure
used
to manage windows is just an extension of the port structure. Whenever
an
SCI system call needs a pointer to a port structure, a pointer to a
window
structure will do. This implicates that the SysWindow class (which
implements
windows) has no "port" property. Instead, its "window" property points
to the
extended port/window structure which can safely be passed to KSetPort.
Not
surprisingly, many of KNewWindow's arguments end up in the port part of
the
window structure.
</para><para>
An SCI program can't directly instantiate a port. If a program wants to
access a specific part of the screen using ports, it has to instantiate
a
transparent window. In fact, SCI creates the picture window using
RNewWindow,
the same function that the kernel call KNewWindow ends up calling,
asking for
an untitled window with a transparent background - but more on that in a
later article.
</para><para>
It must be stressed that ports are purely internal structures. Although
a
program can select different ports to draw in, the data structures
themselves
are absolutely off-limits to SCI code. KNewWindow fills a port structure
with
user-supplied data, but there is no way of changing that data, short of
dis-
posing the window and instantiating it again. The structure is
frequently
changed by SCI itself, though.
</para><para>
Only two kernel calls deal directly with ports:
</para><para>
<simpleList>
<member>KGetPort (see <xref linkend="KGetPort">)</member>
<member>KSetPort (see <xref linkend="KSetPort">)</member>
</simplelist>
</para><para>
These two functions are often used in pairs (also internally), like:
</para><para><programlisting>
var temp;

temp=KGetPort();  /* Save the old port */
KSetPort(...);      /* Activate some other port */
..                            /* Draw some stuff */
KSetPort(temp);    /* Reactivate the old port */
</programlisting>
 </para>

</sect1>
 <sect1>
 <Title/The Cursor resource/

  <para>
  This resource stores a simple bitmap describing the shape and texture of the
  mouse pointer. All information stored herein is little endian in byte order.
  </para><para>
  <VariableList>
   <VarListEntry><Term>0x00 - 0x01
        </Term><ListItem><Para> 
        X coordinate of the mouse cursor hot spot as a 16 bit integer.
	This variable is not used in SCI0.
        </para>
   </ListItem></VarListEntry><VarListEntry><Term>0x02 - 0x03
        </Term><ListItem><Para>
        Y coordinate of the mouse cursor hot spot as a 16 bit integer.
	Only 0x03 is used in SCI0; here, if set, the hot spot is at (8,8),
	if not set, it is located at (0,0).
        </para>
   </ListItem></VarListEntry><VarListEntry><Term>0x04 - 0x23
        </Term><ListItem><Para>
        This is a list of 16 unsigned 16 bit integers constituting bitmasks for the
        mouse cursor's transparency map, with the MSB representing the leftmost
        pixel.
        </para>
   </ListItem></VarListEntry><VarListEntry><Term>0x24 - 0x43
        </Term><ListItem><Para>
        This is another list of 16 unsigned 16 bit integers. Each of them represents
        another bitmask, determining whether the mouse cursor pixel should be drawn
        in black (not set) or white (set). 
        </para>
   </ListItem></VarListEntry></VariableList>
   To determine whether or not to draw a pixel, and, if it is to be drawn, in which
   color it should be drawn in, the corresponding bits of both bitmask lists mentioned
   above have to be examined. In the table below, A represents a bit from
   the first list, and B the corresponding bit from the lower list.
   </para>
   <sect2>
         <title>Color mapping for the SCI0 mouse pointer</title>
   <para>
   <informaltable frame="all">
         <tgroup cols="2">
           <thead>
             <row>
               <entry>AB</entry>
               <entry>Result</entry>
             </row>
           </thead>
           <tbody>
             <row>
               <entry>00</entry>
               <entry>Transparent</entry>
             </row>
             <row>
               <entry>01</entry>
               <entry>Transparent</entry>
             </row>
             <row>
               <entry>10</entry>
               <entry>0x00 (Black)</entry>
             </row>
             <row>
               <entry>11</entry>
               <entry>0x0f (White)</entry>
             </row>
           </tbody>
         </tgroup>
       </InformalTable>
   </para>
   </sect2>

   <sect2>
         <title>Color mapping for the SCI1 mouse pointer</title>
   <para>
   Since this method of doing things wastes one combination, the table was changed for
   SCI01 and SCI1:

   <InformalTable frame="all">
         <tgroup cols="2">
           <thead>
             <row>
               <entry>AB</entry>
               <entry>Result</entry>
             </row>
           </thead>
           <tbody>
             <row>
               <entry>00</entry>
               <entry>Transparent</entry>
             </row>
             <row>
               <entry>01</entry>
               <entry>0x0f (White)</entry>
             </row>
             <row>
               <entry>10</entry>
               <entry>0x00 (Black)</entry>
             </row>
             <row>
               <entry>11</entry>
               <entry>0x07 (Light Gray)</entry>
             </row>
           </tbody>
         </tgroup>
       </InformalTable>
  </para>
  </sect2>
 </sect1>


<sect1>
  <Title/The SCI0 View Resource/
   <para>
    In SCI0, Views are collections of images or sprites. Each View resource
    contains a number of groups, which, in turn, contain one or more images.
    Usually, those groups contain a number of consecutive animation frames.
    It appears to be customary to store related animations or images in a
    single frame. For example, the basic movements of all protagonists (four
    or eight animation cycles (depending on the game)) are stored inside of
    a single View resource.
    Please note that the byte order of the following data is always little endian.

 </para>
 <sect2>
   <Title/The View Resource/
 <para>
 <VariableList>
   <VarListEntry><Term>0x00 - 0x01
      </Term><ListItem><para>
        The number of image groups available.
      </para>
   </ListItem></VarListEntry><VarListEntry><Term>0x02 - 0x03
      </Term><ListItem><Para>
        A bitmask containing the 'mirrored' flag for each of the groups,
        with the LSB containing the 'mirrored' flag for group 0.
      </para>
   </ListItem></VarListEntry><VarListEntry><Term>0x04 - 0x07
      </Term><ListItem><Para>
        - unknown -
      </para>
   </ListItem></VarListEntry><VarListEntry><Term>0x08...
      </Term><ListItem><Para>
        A list of indices pointing to the start of the cell list for each
        image group. The number of entries is equal to the number of cells
        as described in 0x00 - 0x01.
   </para></ListItem></VarListEntry>
 </VariableList>
 </para>
 </sect2>


 <sect2>
   <Title/Cell List/
 <para>
  <VariableList>
    <VarListEntry><Term>0x00 - 0x01
       </Term><ListItem><Para>
         The number of image cells available for this group.
       </para>
    </ListItem></VarListEntry><VarListEntry><Term>0x02 - 0x03
       </Term><ListItem><Para>
         - unknown -
       </para>
    </ListItem></VarListEntry><VarListEntry><Term>0x04...
       </Term><ListItem><Para>
         A list of 16 bit pointers indexing the start of the image cell
         structure for each image cell. The pointers are relative to the
         beginning of the resource data.
    </para></ListItem></VarListEntry>
  </VariableList>
 </para>
 </sect2>


 <sect2><Title/Image Cell/
 <para>
 <VariableList>
   <VarListEntry><Term>0x00 - 0x01
      </Term><ListItem><Para>
        The horizontal (X) size of the image.
      </para>
   </ListItem></VarListEntry><VarListEntry><Term>0x02 - 0x03
      </Term><ListItem><Para>
        The vertical (Y) size of the image.
      </para>
   </ListItem></VarListEntry><VarListEntry><Term>0x04
      </Term><ListItem><Para>
        The x placement modifier. This signed value determines the number of pixels a
        view cell is moved to the right before it is drawn.
      </para>
   </ListItem></VarListEntry><VarListEntry><Term>0x05
      </Term><ListItem><Para>
        The y placement modifier. This signed value determines the number of pixels a
        view cell is moved downwards before it is drawn.
      </para>
   </ListItem></VarListEntry><VarListEntry><Term>0x06
      </Term><ListItem><Para>
        The color key, i.e. the color number used for transparency in
        this cell.
      </para>
   </ListItem></VarListEntry><VarListEntry><Term>0x07...
      </Term><ListItem><Para>
        A list of combined color/repeat count entries. Each byte contains
        a color entry (low nibble) and a repeat count (high nibble).
        If the color is equal to the color key from index 0x06, then
        no drawing should be performed, although [repeat] pixels still need
        to be skipped. It is not known whether this list is terminated;
        the FreeSCI drawing algorithm stops drawing as soon as the rectangle
        defined in the first two cell entries has been filled.
   </para></ListItem></VarListEntry>
 </VariableList>
 </para>
 </sect2>
</sect1>
<sect1>
  <title>The SCI0 and SCI01 pic resource</title>
  <para>
    The pic (background picture) resource format used in SCI0 is rather complex in comparison
    to the other graphical resource formats. It is best described as a sequence of drawing
    operations on a set of four 320x200 canvases, three of which are later used in the game
    (visual, priority, and control), and one of which is used during the drawing process for
    auxiliary purposes<footnote><para>
    Due to the vector graphics nature of these drawing operations, they are inherently more scaleable
    than pixmaps.
    </para></footnote>
  </para>
  <para>
    In order to describe the process, we will first need to define a set of operations
    we base them on:
    <programlisting>
FUNCTION peek_input(): Byte; /* returns the byte pointed to by the input pointer */
FUNCTION get_input(): Byte; /* works like peek_input(), but also increminates the 
                            ** input pointer  */
FUNCTION skip_input(x): Byte; /* skips x input bytes */
      </programlisting>
      Using these pre-defined functions, we will now define additional helper functions used for reading
      specifically encoded data tuples:
      <programlisting>
FUNCTION GetAbsCoordinates(): (Integer, Integer)
VAR
	x, y, coordinate_prefix : Integer;
BEGIN
	coordinate_prefix := get_input();
	x := get_input();
	y := get_input();
	x |= (coordinate_prefix & 0xf0) << 4;
	y |= (coordinate_prefix & 0x0f) << 8;

	RETURN (x,y)
END


FUNCTION GetRelCoordinates(x : Integer, y: Integer): (Integer, Integer)
VAR
	input : Integer;
BEGIN
	input := get_input();
	IF (input & 0x80) THEN
	        x -= (input >> 4);
	ELSE
		x += (input >> 4);
	FI

	IF (input & 0x08) THEN
		y -= (input & 0x7);
	ELSE
		y += (input & 0x7);
	FI

	RETURN (x,y)
END

      </programlisting>
      We also need some data types based on EGACOLOR and PRIORITY, which can be thought of as integers:
      <programlisting>
TYPE Palette = ARRAY[0..39] of EGACOLOR[0..1]
TYPE Priority_Table = ARRAY[0..39] of PRIORITY

Palette default_palette =
     &lt;(0,0), (1,1), (2,2), (3,3), (4,4), (5,5), (6,6), (7,7),
      (8,8), (9,9), (a,a), (b,b), (c,c), (d,d), (e,e), (8,8),
      (8,8), (0,1), (0,2), (0,3), (0,4), (0,5), (0,6), (8,8),
      (8,8), (f,9), (f,a), (f,b), (f,c), (f,d), (f,e), (f,f),
      (0,8), (9,1), (2,a), (3,b), (4,c), (5,d), (6,e), (8,8)&gt;;

#define DRAW_ENABLE_VISUAL   1
#define DRAW_ENABLE_PRIORITY 2
#define DRAW_ENABLE_CONTROL  4

#define PATTERN_FLAG_RECTANGLE 0x10
#define PATTERN_FLAG_USE_PATTERN 0x20
      </programlisting>
      And now for the actual algorithm:
      <programlisting>
FUNCTION DrawPic (cumulative, fill_in_black : Boolean; default_palette: Integer; visual_map, priority_map, control_map, aux_map : Map): Map^4
VAR
	palette : Array [0..3] of Palette;
	drawenable, priority, col1, col2, pattern_nr, pattern_code : Integer;
BEGIN
	palette := (default_palette  4);
	drawenable := DRAW_ENABLE_VISUAL | DRAW_ENABLE_PRIORITY
	priority := 0;
	col1 := col2 := 0;
	pattern_nr := 0;
	pattern_code := 0;

	IF (!cumulative) THEN BEGIN
		visual_map := (0xf  320  200);
		map control := map priority := map aux := (0  320  200);
	END

	FOREVER DO BEGIN

		opcode := get_input();

		COND opcode:
			0xf0 &rarr; /* PIC_OP_SET_COLOR */
				code := get_input();
				(col1, col2) := palette[default_palette + (code / 40)][code % 40];
				drawenable |= DRAW_ENABLE_VISUAL;

			0xf1 &rarr; /* PIC_OP_DISABLE_VISUAL */
				drawenable &= ~DRAW_ENABLE_VISUAL;

			0xf2 &rarr; /* PIC_OP_SET_PRIORITY */
				code := get_input();
				priority := code & 0xf;
				drawenable |= DRAW_ENABLE_PRIORITY;

			0xf3 &rarr; /* PIC_OP_DISABLE_PRIORITY */
				drawenable &= ~DRAW_ENABLE_PRIORITY;

			0xf4 &rarr; /* PIC_OP_RELATIVE_PATTERNS */
				IF (pattern_code & PATTERN_FLAG_USE_PATTERN) THEN
					pattern_nr := (get_input() &gt;&gt; 1) & 0x7f
				FI

				(x,y) := GetAbsCoordinates();

				DrawPattern(x, y, col1, col2, priority, control, drawenable,
						 pattern_code & PATTERN_FLAG_USE_PATTERN,
						 pattern_size, pattern_nr, pattern_code & PATTERN_FLAG_RECTANGLE);

				WHILE (peek_input() < 0xf0) DO BEGIN
					IF (pattern_code & PATTERN_FLAG_USE_PATTERN) THEN
						pattern_nr := (get_input() &gt;&gt; 1) & 0x7f
					FI
					(x,y) =  GetRelCoordinates(x,y);
					DrawPattern(x, y, col1, col2, priority, control, drawenable,
							 pattern_code & PATTERN_FLAG_USE_PATTERN,
							 pattern_size, pattern_nr, pattern_code & PATTERN_FLAG_RECTANGLE);
				END

			0xf5 &rarr; /* PIC_OP_RELATIVE_MEDIUM_LINES */
				(oldx, oldy) := GetAbsCoordinates();
				WHILE (peek_input() &lt; 0xf0) DO BEGIN
					temp := get_input();
					IF (temp & 0x80) THEN
						y := oldy - (temp & 0x7f)
					ELSE
						y := oldy + temp
					FI
					x = oldx + get_input();
					 DitherLine(oldx, oldy, x, y, col1, col2, priority, special, drawenable);
					(oldx, oldy) := (x, y);
				END

			0xf6 &rarr; /* PIC_OP_RELATIVE_LONG_LINES */
				(oldx, oldy) :=  GetAbsCoordinates()
				WHILE (peek_input() &lt; 0xf0) DO BEGIN
					(x, y) := GetAbsCoordinates();
					DitherLine(oldx, oldy, x, y, col1, col2, priority, special, drawenable);
					(oldx, oldy) := (x, y);
				END

			0xf7 &rarr; /* PIC_OP_RELATIVE_SHORT_LINES */
				(oldx, oldy) =  GetAbsCoordinates()
				WHILE (peek_input() &lt; 0xf0) DO BEGIN
					(x, y) := GetRelCoordinates(oldx, oldy);
					DitherLine(oldx, oldy, x, y, col1, col2, priority, special, drawenable);
					(oldx, oldy) := (x, y);
				END

			0xf8 &rarr; /* PIC_OP_FILL */
				IF (fill_in_black) THEN
					(oldc1, oldc2) := (c1, c2);
				FI

				WHILE (peek_unput() &lt; 0xf0) DO BEGIN
					(x, y) := GetAbsCoordinates();
					DitherFill(x, y, col1, col2, priority, special, drawenable);
				END

				IF (fill_in_black) THEN
					(c1, c2) := (oldc1, oldc2);
				FI

			0xf9 &rarr; /* PIC_OP_SET_PATTERN */
				pattern_code := get_input() & 0x37;
				pattern_size := pattern_code & 0x7;

			0xfa &rarr; /* PIC_OP_ABSOLUTE_PATTERNS */
				WHILE (peek_input() &lt; 0xf0) DO
					IF (pattern_code & PATTERN_FLAG_USE_PATTERN)
						pattern_nr := (get_input() >> 1) & 0x7f
					FI
					(x, y) := GetAbsCoordinates();
					DrawPattern(x, y, col1, col2, priority, control, drawenable,
							 pattern_code & PATTERN_FLAG_USE_PATTERN,
							 pattern_size, pattern_nr, pattern_code & PATTERN_FLAG_RECTANGLE);
					END

			0xfb &rarr; /* PIC_OP_SET_CONTROL */
				control := get_input() & 0x0f;
				drawenable |= DRAW_ENABLE_CONTROL;

			0xfc &rarr; /* PIC_OP_DISABLE_CONTROL */
				drawenable &= ~DRAW_ENABLE_CONTROL;

			0xfd &rarr; /* PIC_OP_RELATIVE_MEDIUM_PATTERNS */
				IF (pattern_code & PATTERN_FLAG_USE_PATTERN) THEN
					pattern_nr := (get_input() &gt;&gt; 1) & 0x7f;
				FI

				(oldx, oldy) := GetAbsCoordinates();

				DrawPattern(x, y, col1, col2, priority, control, drawenable,
						 pattern_code & PATTERN_FLAG_USE_PATTERN,
						 pattern_size, pattern_nr, pattern_code & PATTERN_FLAG_RECTANGLE);

				WHILE (peek_input() &lt; 0xf0) DO BEGIN
					IF (pattern_code & PATTERN_FLAG_USE_PATTERN) THEN
						pattern_nr := (get_input() &gt;&gt; 1) & 0x7f;
					FI
			
					temp := get_input();
					IF (temp & 0x80)
						y := oldy - (temp & 0x7f)
					ELSE
						y := oldy + temp
					FI
					x := oldx + get_input();
					DrawPattern(x, y, col1, col2, priority, control, drawenable,
							 pattern_code & PATTERN_FLAG_USE_PATTERN,
							 pattern_size, pattern_nr, pattern_code & PATTERN_FLAG_RECTANGLE);
				END

			0xfd &rarr; /* PIC_OP_OPX */
				COND get_input():
					0x00 &rarr; /* PIC_OPX_SET_PALETTE_ENTRY */
						WHILE peek_input() &lt; 0xf0 DO BEGIN
							index := get_input();
							color := get_input();
							palette[index / 40][color % 40] := color;
						END

					0x01 &rarr; /* PIC_OPX_SET_PALETTE */
						palette_number := get_input();
						FOR i := 0 TO 39 DO
							palette[palette_number][i] := get_input();
						OD

					0x02 &rarr; /* PIC_OPX_MONO0 */
						skip_input(41);

					0x03 &rarr; /* PIC_OPX_MONO1 */
						skip_input(1);

					0x04 &rarr; /* PIC_OPX_MONO2 */
					0x05 &rarr; /* PIC_OPX_MONO3 */
						skip_input(1);

					0x06 &rarr; /* PIC_OPX_MONO4 */
					0x07 &rarr; /* PIC_OPX_EMBEDDED_VIEW */ /* SCI01 operation */
					0x08 &rarr; /* PIC_OPX_SET_PRIORITY_TABLE */ /* SCI01 operation */

			0xff &rarr; return (visual, control, priority, aux);
		END OF COND
      END
END
      </programlisting>
      This algorithm uses three auxiliary algorithms, DrawPattern, DitherLine, and DitherFill, which are sketched below. All of
      these functions are supposed to take the four maps as implicit parameters.
      <programlisting>
PROCEDURE DrawPattern(x, y, col1, col2, priority, control, drawenable : Integer;  solid : Boolean ;  pattern_size, pattern_nr : Integer; rectangle : Boolean)

Alters (x,y) so that 0 &lt;= (x - pattern_size), 319 &gt;= (x + pattern_size), 189 &gt;= (y + pattern_size) and
0 &lt;= (y - pattern_size), then draws a rectangle or a circle filled with col1, col2, priority, control,
as determined by drawenable.
If rectangle is not set, it will draw a rectangle, otherwise a circle of size pattern_size.
pattern_nr is used to specify the start index in the random bit table (256 random bits)



PROCEDURE DitherLine(x, y, xend, yend, color1, color2, priority, control, drawenable : Integer)

Draws a dithered line between (x, y+10) and (xend, yend+10). If the appropriate drawenable flags
are set, it draws 'priority' to the priority map, 'control' to the control map, and 'color1' and 'color2'
(alternating) to the visual map. The auxiliary map is bitwise-or'd with the drawenable flag while this is
done.



PROCEDURE DitherFill(x, y, col0, col1, priority, control, drawenable : Integer)
Fills all layers for which drawenable is set with the appropriate content.
Diagonal filling is not allowed.
Boundaries are determined as follows:
x&lt;0, x&gt;319, y&lt;10, y&gt;199 are hard boundaries. We now determine the
'boundary map' bound_map and the allowed color legal_color.
If bound_map[coordinates] = legal_color, then the pixel may be filled.

IF (drawenable & DRAW_ENABLE_VISUAL)
	bound_map = visual;
	legal_color = 0xf;
ELSIF (drawenable & DRAW_ENABLE_PRIORITY)
	bound_map = priority;
	legal_color = 0;
ELSIF (drawenable & DRAW_ENABLE_CONTROL)
	bound_map = control;
	legal_color = 0;
ELSE
	return;
FI
      </programlisting>


</sect1>
<sect1 ID="LarsWindows">
<Title/Windows, Dialogs and Controls/
<para>
by <Author><firstname/Lars/<surname/Skovlund/</Author></para><para>
Version 1.0, 7. July 1999
</para><para>
I am going to start by mentioning the menus. It has nothing to do with the
material I deal with in this essay. They use different kernel calls, and
such things as port management are handled internally by the kernel 
routines.
The SCI program just sets up a menu structure using the kernel calls.
Since they are irrelevant to the subject of this essay, I will not spend 
more
time on them.
</para><para>
The Rect structure is important (also to ports) since it is the basis for
passing a screen position to the interpreter. It looks like this:
</para><para>
<programlisting>
typedef struct
{
  short top, left, bottom, right;
}
</programlisting>
</para><para>
It will be seen from this that rectangle coordinates in SCI are not normally
 represented in the usual (x,y,width,height) fashion. So pay close attention
 to this structure! Also, it is not passed as a pointer, but rather as
the four values in order. This is particularly true of SCI objects, where
the property names nsTop etc. actually form a Rect structure which can be
used directly by the interpreter.
</para><para>
Windows are created using the KNewWindow kernel function. Each window has
six attributes which are passed from the script to the kernel function:
</para><para>
<simplelist>
<member/Bounding rectangle/
<member/Title/
<member/Type/
<member/Priority/
<member/Foreground color/
<member/Background color/
</simplelist>
</para><para>
Of these, the type and priority are the most interesting, because they 
decide
the appearance of the window. The type is a bit field:
</para><para>
<simplelist>
<member/bit 0 - transparency/
<member/bit 1 - window does _not_ have a frame/
<member/bit 2 - the window has a title/
<member/bit 3-6 - unused/
<member/bit 7 - see below/
</simplelist>
</para><para>
Bit 0 specifies a transparent window. KNewWindow does not save the image
behind the created window - it stays on the screen until the pic is redrawn,
so windows with this style definitely can't be used as message boxes. It 
does
have some special uses, though. If this bit is not set, KNewWindow draws
a rectangle in the specified background color using the bounding rectangle
coordinates (using the WM port). When this bit is set,
</para><para>
Bit 1 specifies a window without a frame. The frame is the black shading you
can see in the corner of a message box.
</para><para>
Bit 2 tells KNewWindow to draw a grey title bar with a title printed in
white. In the version I have used for this essay, it is not possible to
change the title bar colors. Note that the bounding rectangle is always
specified as if the window had no title bar. If this bit is set, ten pixels
are reserved above the coordinates specified. Although this bit is set,
the Title parameter may still be NULL. If this is the case, an empty title
bar is drawn.
</para><para>
Bit 7 has a special meaning; it is used only in window type 0x81, and is not
tested in any other way. When this style is chosen, KNewWindow does not
draw anything at all. It is the caller's responsibility to draw a
window frame on the WM port. CB1 uses this style for its ornate windows,
and draws the frame manually.
</para><para>
The picture window which I mentioned in the last article is created using
style 3 (that is, TRANSPARENT | NOFRAME). The normal message box styles used
in LSL3 are 0 and 4.
</para><para>
I have not been able to investigate the priority property yet, so the fol-
lowing is based on suppositions. It is only used when drawing transparent
windows. In this case, if priority is not -1 (which means not used), the
window is drawn onto the priority map (with the specified priority value) as
well as the screen.
</para><para>
There is a class called SysWindow which is just a simple wrapper around the
following two kernel calls. Try breaking on SysWindow::open, then type c
to inspect the current object. You can change all the parameters to KNewWin-
dow (the Rect is split in its fields, to nsTop, nsLeft etc.)
</para><para>
To create a window structure, use KNewWindow (see <XREF LINKEND="KNewWindow">);
to remove it again, apply KDisposeWindow (see <XREF LINKEND="KDisposeWindow">) on
it.
</para><para>
So how do we put stuff inside these windows? That question is a little com-
plicated to answer, because it is really a shared effort between the inter-
preter and the object hierarchy, and this is one case where the interpreter
actually interacts with the objects itself. I will start by explaining the
classes involved.
</para><para>
All control types are descendants of a common class (I do not know its name,
since it appears to have an invalid name property). Among other things, this
common class contains a type number and a state. The type number is the only
thing that distinguishes the control types from each other inside the
interpreter - if a wrong type is set, the interpreter might try to change
a non-existent property.
</para><para>
The type numbers are laid out as follows:
<simplelist>
<member/  1 - Button control/
<member/  2 - Text control/
<member/  3 - Edit control/
<member/  4 - Icon control/
<member/  5 - not used/
<member/  6 - Selector control (as in the Save and Restore boxes)/
</simplelist>
The gauge "controls" are not really controls. I don't know how they work
(yet).
</para><para>
Each control also has a state value. These are laid out as follows:
<simplelist>
<member/bit 0 - selectable. If this bit is set, the control can be selected using 
the
Tab key. Except for the text and icon controls, all controls are selectable./
<member/bit 1 - unknown. Always set, except for the text and icon controls/
<member/bit 2 - disabled. When this bit is set, a button is grayed out. No other
control types are affected./
<member/bit 3 - selected. When this bit is set, a frame is drawn around the control./
</simplelist>
Note that state 3 is by far the most common.
With that explained, I'll move on to the kernel functions. There are three
functions associated with controls - KDrawControl (see <XREF LINKEND="KDrawControl">),
KHiliteControl (see <XREF LINKEND="KHiliteControl">) and
KEditControl (see <XREF LINKEND="KEditControl">).
 Note that there is a KOnControl kernel call which is entirely
unrelated to window management.
</para><para>
The dialogs are implemented using not one, but two classes - Dialog and
Window. While the Window class maintains the window (It is derived from
SysWindow), the Dialog class is just a list of controls. It is derived from
the List class, but has extended functionality to tell its members to redraw
etc. There is a special function, located in script 255, which allows
scripts to push information about the dialog on the stack instead of 
creating
the Dialog object manually.
</para><note><para>
Note that the internal debugger uses the same window calls as the SCI 
script.
That is why the screen messes up if you step through drawing code - the debugger has
 activated the Debug window port, and "forgets" to switch back
while stepping across instructions. Thus, all graphics commands are
redirected to the debug window port. Not a pretty sight.

</para></note>
</sect1>
<sect1 ID="LARSPICSANDMOVEMENT">
  <Title/Pictures and movement control/
   <para>By<author><firstname/Lars/<surname/Skovlund/</author></para>
   <para/Version 1.0, 24. July 1999/
   <para>
A pic in SCI consists of three layers (called maps - they are unrelated to
the map resources found in SCI1 gamers). The visual map, used for the
picture which appears on the user's screen. The priority map which tells the
interpreter which things go in front of which in the three-dimensional room.
Without the priority map, a room would just be a flat, painted surface.
The control map decides where game characters (called actors) can walk and
where special events occur. These special events are triggered by a game
character walking on a particular spot. Where the visual map is almost
always very complex and using dithered fills etc., the latter two consist of
large areas of solid color.
</para><para>
Many functions which need to access these maps do so by using a bit-field.
The bits are laid out as follows (but don't set more than one at a time!)
<simplelist>
<member/bit 0 - Visual/
<member/bit 1 - Priority/
<member/bit 2 - Control/
</simplelist>
</para><para>
It is important to understand that, although being represented as colors on
the screen, a priority/control "color" should be considered a number.
The colors map to values according to the standard EGA color values.
</para><para>
Every animated object in SCI has a priority. As the object moves, its pri-
ority changes according to the so-called priority bands, explained next
(it is, however, possible for a script to lock the priority of a view).
The picture window is divided vertically into 16 priority bands. The
priority of an animated object is determined by the position of its
"base rectangle" in one of these bands. Things are drawn in order of
ascending priority, so objects with priority 15 are guaranteed to be in 
front
of everything else. The default priority mapping gives priority 0 a fairly
large space, the 42 topmost rows (including the menu bar which AFAIK is 10) 
in the picture. All other priority
bands have the same size. A script can choose to alter this mapping,
specifying the amount of space to assign to priority 0, and the number of 
the
last row to include in the mapping calculation.
</para><para>
In most rooms, it is desirable to limit actor movement, confining the
actor to a specific part of the screen. In other cases, special events
are triggered by movement into a specific screen area. On some occasions,
even room switches are implemented using control polygons. While the meaning
of priorities is determined by the kernel, the meaning of control values
is entirely up to the script. It is more or less a standard, however, that
actors can't walk on white control areas.
</para><para>
As the control map is not consulted by the interpreter itself (except in a
few cases), scripts need a way to do so. That way is called OnControl, and
it is a kernel call. Supplied with a point or a rectangle, it returns a bit
mask containing the control values of all the pixels in the desired region.
If a specific control value is encountered, it is used as a bit number, and
that bit is set in the output mask.
</para><para>
This bit mask system is also used in another place, namely the illegalBits
selector of the Act (actor) class. The illegalBits selector determines in
which areas the actor may not walk.
</para><para>
The OnControl() system call is explained in <XREF LINKEND="KONCONTROL">.
</para>
</sect1>
</chapter>

<Chapter>
  <Title/The Sound subsystem/
   <sect1>
     <Title/The SCI0 Sound Resource Format/
     <para> by <author><firstname/Ravi/<surname/I./</author>
     </para><para>
	Revision 8, Dec. 21, 2000
	</para>
	<sect2><Title/Preface/
	<para>
	   Sierra's SCI0 sound resources contain the music and sound effects played
	   in the game. With the introduction of SCI, the company took advantage of
	   new sound hardware which allowed for far better music than the traditional
	   PC speaker could ever create. Sierra chose two devices to specifically
	   target: the MT-32, and the Adlib. The MT-32 is a MIDI synth while the
	   Adlib is a less expensive card based around the OPL2, a non-MIDI chip.
	   Anyone interested in Sierra music and its history can find information at
	   the Sierra Soundtrack Series (http://www.queststudios.com).
	</para><para>
	   Music is stored as a series of MIDI events, and the sound resource is
	   basically just a MIDI file. Much of what I write here comes from outside
	   documents, and I would direct anyone seeking more information to a MIDI
	   specification. The MIDI resource page (http://www.midi.org/resource.htm)
	   on midi.org has some good links as well as tables with status and
	   control information.
	</para><para>
	   Some people prefer the one-based numbering system for channel and program
	   numbers. I personally prefer the zero-based system, and use it here. If
	   you're familiar with channels 1-16, be aware that I will call them 0-15.
	   My intention is not to be deviant from other programs but to be more
	   accurate in representing the way information gets stored. The same is true
	   for programs 0-127 as opposed to 1-128. For whatever reason, convention
	   already holds that controls be numbered 0-127, so nothing in my treatment
	   of them should be abnormal.
	</para><para>
	   Sierra changed its sound file format in the switch to SCI1. I refer only
	   to SCI0 sound files in this specification. Hybrid interpreters such as
	   the one used for Quest for Glory II are also excluded. Finally, SCI games
	   written for non-DOS systems may have different formats. This document
	   applies to Sierra's IBM games.
	</para><para>
	   Please post comments or questions to the SCI webboard:
	      http://www.InsideTheWeb.com/mbs.cgi/mb173941
	</para><para>
	   You can contact me personally at ravi.i@softhome.net, but I would prefer
	   that SCI messages be posted on the webboard so everyone can see them.
	</para>
	</sect2><sect2><Title/Sound Devices/
	<para>
	   A gamer's sound hardware greatly affects how the music will sound. Devices
	   used by SCI0 can be broken into 3 categories:
	<variablelist>
		<varlistentry><term>MIDI Synths</term><listitem><para>
		   These will generally give the best sound quality. MIDI
                   synths are polyphonic with defineable instruments through
                   patch files and full support for MIDI controls. The
                   General MIDI standard had not been written when Sierra
                   began writing SCI games, and as far as I know no SCI0 game
                   uses a GM driver or includes a GM track. This means that
                   synths had to be individually supported.
		</para></listitem></varlistentry>

		<varlistentry><term>Non-MIDI Synths</term><listitem><para>
		   Generally not as good as MIDI synths, but also less
                   expensive. The OPLx family of chips are still very common
                   among home PC users thanks to the Adlib and SoundBlaster
                   cards. Synths are polyphonic with defineable instruments
                   through patch files, but drivers must be written to
                   interpret MIDI events and turn them into commands the
                   hardware will recognize. Support for most sound controls
                   gets lost in the process. Furthermore, drivers must map
                   logical, polyphonic MIDI channels to physical, monophonic
                   hardware channels. A specific control was introduced for
                   this purpose and will be discussed later. There is no
                   common way of accessing these devices, so they must be
                   individually supported. These days, however, most people
                   have an Adlib compatible card.
		</para></listitem></varlistentry>

		<varlistentry><term>Beepers</term><listitem><para>
		   Beepers produce very poor music and don't support instrument
                   definitions, but all PC users have one so supporting them
                   covers people without special sound hardware. The most
                   common device is the PC speaker, which is monophonic.
                   Another is the Tandy speaker with 3 channels. Drivers must
                   interpret MIDI events, but need only concern themselves
                   with basic functionality. Interpreting the MIDI events is
                   also made easier because each channel is monophonic. To
                   play a chord on the Tandy, for example, each voice must be
                   put in a separate MIDI channel.
		</para></listitem></varlistentry>
	</variablelist>
	</para><para>
	   With such a diverse group of devices to support, Sierra put a lot of the
	   work on the shoulders of the drivers. Functions for loading patch files,
	   handling events, pausing, etc. are all in the drivers. The interpreter
	   calls them as needed but does not concern itself at all with how they
	   get implemented.
	</para><para>
	   Listed here are devices supported by the SCI0 interpreter with a little
	   information about each. There could very well be other hardware not listed
	   here, so please send in any missing information. Also, since the
	   interpreter is made to be device independent, this list could be easily
	   expanded. The process would require that a new driver be written and a
	   patch file created if appropriate. Since the driver is responsible for
	   choosing which patch file to use and then entering it into the device, the
	   second step would be quite easy.
	  </para><para>
	   <informaltable frame="all">
	    <tgroup cols="5">
	     <thead><row>
	      <entry/Device Name/
	      <entry/Driver/
	      <entry/Patch/
	      <entry/Poly/
	      <entry/Flag/
	     </row></thead>
	     <tbody>
	      <row>
	      <entry/    Roland MT-32      /<entry/  mt32    /<entry/   001   /<entry/   32   / <entry/01h/
	     </row><row>
	      <entry/        Adlib         /<entry/  adl     /<entry/   003   /<entry/   9    /<entry/04h/
	     </row><row>
	      <entry/     PC Speaker       /<entry/  std     /<entry/    *    /<entry/   1    /<entry/20h/
	     </row><row>
	      <entry/  Tandy 1000 or PCJr   /<entry/  jr      /<entry/    *    /<entry/   3    /<entry/+/
	     </row><row>
	      <entry/  Tandy 1000 SL, TL   /<entry/  tandy   /<entry/    *    /<entry/   3    /<entry/+/
	     </row><row>
	      <entry/  IBM Music Feature   /<entry/  imf     /<entry/   002   /<entry/   8    /<entry//
	     </row><row>
	      <entry/    Yamaha FM-01      /<entry/  fb01    /<entry/   002   /<entry/   8    /<entry//
	     </row><row>
	      <entry/  CMS or Game Blaster  /<entry/  cms     /<entry/   101   /<entry/   12   /<entry//
	     </row><row>
	      <entry/  Casio MT540 or CT460   /<entry/  mt540   /<entry/   004   /<entry/   10   /<entry//
	     </row><row>
	      <entry/     Casio CSM-1      /<entry/          /<entry/   007   /<entry/        /<entry//
	     </row><row>
	      <entry/  Roland D110,D10,D20   /<entry/          /<entry/   000   /<entry/        /<entry//
	      </row>
	     </tbody>
	    </tgroup>
	   </informaltable>
	              (thanks to Shane T. for providing some of this).
	              Blank fields are unknown, not unused.
	   <simplelist>
	            <member/*  when asked which patch to load, the PC and Tandy
	                  speaker drivers return FFFFh, which is a signal
	                  that they do not use patches/
	            <member/+  the Tandy drivers almost certainly use 10h for their
	                  play flag, but this is unconfirmed so I'll leave
	                  it out for now/
	   </simplelist>
	</para><para>
	   The driver field is the file name of the driver without the drv extension.
	   Patch specifies which patch file the driver requests. Poly is the maximum
	   number of voices which can be playing at once as reported by the driver.
	   The play flag specifies which channels the device will play and gets
	   explained in the header section.
	</para>
	</sect2><sect2><Title/File Format/
	<para>
	   Sound files follow the same format as all extracted SCI0 resources: the
	   first two bytes of the file contain a magic number identifying the
	   resource type and the rest of the file contains a dump of the uncompressed
	   data. The identifier is the resource type (04h for sound) OR-ed with 80h
	   and stored as a word. The result will be 84h 00h in extracted sound files.
	</para><para>
	   The sound resource data itself is a header with channel initialization
	   followed by a series of MIDI events.
	</para>
	<sect3><Title/Header/
		<para>
		   The header provides the sound driver with 2 pieces of information about
		   each channel. The first is a byte which specifies how many voices each
		   logical MIDI channel will be playing. For MIDI synths, this information is
		   not really necessary and is probably ignored. The same goes for beepers.
		   This byte is only useful for non-MIDI synths which must know how many
		   hardware channels each logical MIDI channel will need. This value is only
		   an initial setting. Sound files can request changes to the mapping later
		  with control changes. Requesting more hardware channels than are actually
		  available can cause errors on some drivers.
		</para><para>
		   The second byte describes how the user's sound harware should treat the
		   channel. It is the combination of bit flags which may be OR-ed together.
		   If the appropriate bit is set for the currently selected sound device, the
		   channel will be played. If it is not, the channel will be silent. The
		   driver decides which bit it will use as the play flag, and the table under
		   Sound Devices lists the flag used by each driver. Drivers ignore the first
		   byte (used to request hardware channels) on MIDI channels it won't play.
		</para><para>
		  There is an exception to the above. Channel 9 is the MIDI percussion
		  channel. The MT-32 (and possibly other MIDI synths) always plays this
		  channel, regardless of whether or not it is specifically flagged.
		</para><para>
		   Before the channel initialization is a byte which specifies whether the
		   header holds information for 15 or 16 channels. A value of 0 means that
		   there will be 16 channels and a value of 2 means that there will be 15
		   channels. All other values are undefined and will render sound files
		   unplayable.
		</para><para>
		   The header format:
		   <simplelist>
		      <member/1 byte  - number of channels code (usually 0, can also be 2)/
		      <member/2 bytes - initialization for channel 0/
		      <member/2 bytes - initialization for channel 1/
		      <member/./
		      <member/./
		      <member/./
		      <member/2 bytes - initialization for channel 15/
		    </simplelist>
		</para><para>
		   Notice that the space for channel 15's initialization will always be
		   present. If the number of channels code is 2, the last two bytes of the
		   header will be ignored, but they are stil in the resource. The header is
		   always 33 bytes in length.
		</para></sect3><sect3><title/Events/
		<para>
		   The actual music is stored in a series of events. The generic form for an
		   event is:
		<simplelist>
			<member/&lt;byte - delta time&gt; [byte - status] [byte - p1 [p2]]/
		</simplelist>
		</para><para>
		   Delta time is the number of ticks to wait after executing the previous
		   event before executing this event. Standard MIDI stores this as a variable
		  length value. In sound resources, it will generally be one byte and the
		  most significant bit is in fact used as part of the value. In cases where
		  a single byte cannot hold a high enough delta time, sound resources use
		  F8h one or more times in a row. The F8h byte causes a delay of F0h (240
		  decimal) ticks before continuing playback. The sequence F8 F8 78 FC waits
		  600 ticks then stops the sequence because of the FCh status. The fact that
		  F8h waits F0h ticks makes me think that E9h is the largest technically
		  accepted delta time, even though larger values will work. The only
		  exception is the FCh status, which can be theoretically given without a
		  preceding delta time value -- any cases where FCh is listed as a delta
		  time, the sound should stop playing. Ticks occur at 60 Hz, which is about
		  16667 microseconds between ticks.
		</para><para>
		   The status byte is basically a command. The most significant bit is always
		   set. This feature is important because the status byte will not always be
		   present. If you read a byte expecting it to be a status byte but the most
		   significant bit is not set, that byte is actually a paramater and you
		   should repeat the last status used. This is known as running status mode
		   and appears to get used relatively often.
		</para><para>
		   The generic form for a status byte is (in bits) 1xxxcccc - The lower
		   nibble designates which channel the message affects except when the upper
		   nibble is 15. The upper nibble is the command, but as stated earlier, the
		   most significant bit must be 1. That leaves space for 8 messages, most of
		   which require at least one paramater. Paramaters will never have their
		   most significant bit set.
		</para>
		</sect3><sect3><title/Status Reference/
		<para>
		<variablelist>
			<varlistentry><term/8x n v/<listitem><para/
			    Note off: Stop playing note n on channel x, releasing the key
		            with velocity v. If a hold pedal is pressed, the note will
		            continue to play after this status is received and end when the
		            pedal is released. A zero velocity note on can also be used to
		            stop playing a note./
			</listitem></varlistentry>

			<varlistentry><term/9x n v/<listitem><para/
			    Note on: Play note n on with velocity v on channel x. The
		            velocity is the speed with which the key gets pressed, which
		            basically means how loud the note should be played. Playing a
		            note with velocity 0 is a way of turning the note off./
			</listitem></varlistentry>

			<varlistentry><term/Ax n p/<listitem><para/
			    Key pressure (after-touch): Set key pressure to p for note n on
		            channel x. This is to modify key pressure for a note that is
		            already playing./
			</listitem></varlistentry>

			<varlistentry><term/Bx c s /<listitem><para>
			    Control: Set control c to s on channel x. This can be confusing
		            because there isn't just one meaning. Changing the settings on
		            different controls will, of course, have different outcomes.
			</para><para>
		            Controls which handle any value are continuous controllers. They
		            have a continuous range. Controls which are only on/off are
		            switches. Their defined range is only 01h (OFF) and 7Fh (ON).
		            However, in order to respond to all values, 01h-3Fh is treated as
		            OFF and 40h-7Fh is treated as ON. While in practice they may only
		            use bit 6 as a flag, my personal opinion is that values between
		            01h and 7Fh should be avoided for the sake of clarity.
			</para><para>
		            Listed in this reference are the non-standard MIDI controls I've
		            found in Sierra SCI0 sound files. Not all drivers support all
		            controls.
			</para><para>
		            Control Refrence
			<variablelist>
				<varlistentry><term/4Bh/<listitem><para/
					Channel mapping: When a channel sets this control, it
		                        tells the driver how many notes it will be playing
		                        at once, and therefore how many hardware channels it
		                        occupies./
				</listitem></varlistentry>

				<varlistentry><term/4Ch/<listitem><para>
					Reset on SUSPEND: An on/off switch where a value of
		                        zero is off and a non-zero value is on. Note that
		                        this is not the same as for standard MIDI control
		                        switches. When this control is on, calling the sound
		                        driver's SUSPEND subfunction will reset the sound
		                        position to the beginning. The initial value is set
		                        to off when a sound gets loaded.</para>
				</listitem></varlistentry>

               			<varlistentry><term/4Eh/<listitem><para/
					Unknown: Experiments in setting and clearing it show
		                        that a value of 0 will cause notes to be played
		                        without regard for the velocity paramater while a
		                        value of 1 will enable velocities./
				</listitem></varlistentry>

				<varlistentry><term/50h/<listitem><para>
				  Reverb: I know little about this myself. Rickard Lind
				  reports that it exists in the MT-32 driver and
				  supports parameter values 0-10 (possibly 0-16?).
				</para></listitem></varlistentry>

               			<varlistentry><term/60h/<listitem><para/
					Cumulative cue: The interpreter can get cues from the
		                        sound file, which sets the Sound object's signal
		                        property. When a sound gets loaded, the inital cue is
		                        set to 127. When a CC60 occurs, the new control value
		                        is added to the current cue. If the cue were 130, for
		                        example, a CC60 5 on any channel would make the new
		                        cumulative cue equal 135./
				</listitem></varlistentry>
			</variablelist>
			</para></listitem></varlistentry>

			<varlistentry><term/Cx p/<listitem><para>
				  Program change: Set program (patch / instrument / ect.) to p for
				  channel x. This is a simple instrument change.
			</para><para>
			          Channel 15, however, includes two special cases of this status. If
			          the new program is less than 127 the Sound object's signal property
			          is set to the new program, making a non-cumulative cue. If the new
			          program is equal to 127, then that exact position (not the start of
			          the current tick) is set as the loop point. Normally, the driver
			          loops to the beginning of the sound. If an explicit loop point is
			          set, the sound will be replayed from the marked time instead.
			</para><para>
			          The actual time of the loop point is better explained with a short
			          diagram:
				<simplelist>
				      <member/0x10 0x91 0x20 0x20      play a note on channel 1/
			              <member/0x05 0x91 0x20 0x00      stop the previous note/
			              <member/0x00 0x92 0x30 0x10      play a note on channel 2/
			              <member/  [restart here]/
			              <member/0x00 0xCF 0x7F           set loop point/
			              <member/0x00 0xC8 0x05           set to program 5 on channel 8/
			              <member/0x00 0xCF 0x13           set signal to 19/
			              <member/0x20 0xFC                end of file, loop to marked location/
				</simplelist>
			</para><para>
			          In both situations (p < 127 and p = 127), no actual program change
			          takes place. Channel 15 is used for control, not playing music.
			</para></listitem></varlistentry>

   			<varlistentry><term/Dx p/<listitem><para/
				  Pressure (after-touch): Set key pressure to p on channel x. This is
			          similar to Ax but differs in its scope. Message Ax is applied on a
			          per-note basis while message Dx is applied to an entire channel./
			</listitem></varlistentry>

			<varlistentry><term/Ex t b/<listitem><para/
				    Pitch wheel: Set the pitch wheel to tb. The setting is actually
			            a 14 bit number with the least significant 7 bits stored in b
			            and the most significant 7 bits stored in t. (Remember the top
			            bit can't be used for either byte.) The range of settings is
			            0000h to 3FFFh. A setting of 2000h means the pitch wheel is
			            centered. Larger values raise pitch and smaller values lower it./
			</listitem></varlistentry>

			<varlistentry><term/F0/<listitem><para>
				Begin SysEx: Starts a system exclusive data block. The block must
			        terminate with F7h.</para>
			</listitem></varlistentry>

			<varlistentry><term/F7/<listitem><para>
				End SysEx: Ends a system exclusive data block. Normal sound data
			        resumes at this point.</para>
			</listitem></varlistentry>

			<varlistentry><term/FC/<listitem><para>
				Stop Sequence: This is a system real-time message which tells the
			        sound driver to stop the current sound. The sound object's signal
			        property gets set to FFFFh and the position moves to the loop point,
			        which defaults to the beginning. Drivers allow this message to occur
			        without a delta time, but I haven't seen any examples.</para>
			</listitem></varlistentry>
		</variablelist>
		</para>
	</sect3>
	</sect2><sect2><title/Revision history/
  <para>
  <variablelist>
    <varlistentry><term/Revision 8 - Dec. 21, 2000/
      <listitem><para><itemizedlist>
	<listitem><para>Added suggested limit on delta time values</para></listitem>
	<listitem><para> Fixed hex notation (sometimes listed NNh, sometimes 0xNN)</para></listitem>
	<listitem><para> Removed notice about early revisions' mistake describing the header's
	  channel mapping byte</para></listitem>
	<listitem><para> Added note about control 50h (thanks to Rickard Lind)</para></listitem>
	<listitem><para> Listed MT-32 play flag</para></listitem>
	<listitem><para> Added notice about the special case of channel 9 to the header
	  section</para></listitem></itemizedlist>
   <varlistentry><term/Revision 7 - Jan. 7, 2000/
	<listitem><para><itemizedlist>
	      	<listitem><para/Added information about F8h delta times (thanks to Rickard Lind for
			bringing these to my attention)/</listitem>
      		<listitem><para/Reorganized Fx status information/</listitem>
      		<listitem><para/Fixed major error in description of loop points (sorry)/</listitem>
      		<listitem><para/Fixed typos/</listitem>
     </itemizedlist></para></listitem></varlistentry>

   <varlistentry><term/Revision 6 - Sep. 17, 1999/
	<listitem><para><itemizedlist>
	      	<listitem><para/Added information about cues/</listitem>
	      	<listitem><para/Updated control 60h information/</listitem>
	      	<listitem><para/Added information about loop points/</listitem>
	      	<listitem><para/Updated control 4Ch information/</listitem>
	      	<listitem><para/Cleaned up control reference introduction/</listitem>
     </itemizedlist></para></listitem></varlistentry>

   <varlistentry><term/Revision 5 - Jul. 5, 1999/
     <listitem><para><itemizedlist>
      <listitem><para/Rewrote much of the specification, trying to focus less on explaining
        MIDI and more on explaining sound resources/</listitem>
      <listitem><para/Removed information about standard MIDI controls/</listitem>
      <listitem><para/Added driver table/</listitem>
      <listitem><para/Expanded sound device section/</listitem>
      <listitem><para/Completed header information/</listitem>
     </itemizedlist></para></listitem></varlistentry>

   <varlistentry><term/Revision 4 - Jun. 19, 1999/
     <listitem><para><itemizedlist>
      <listitem><para/Fixed the list of changes in Revision 3 (was incomplete)/</listitem>
      <listitem><para/Expanded the introductory blurb about controls/</listitem>
      <listitem><para/I began working with a disassembly of ADL.DRV, and am hoping to use
        it to complete this specification. The next revision should be more
        interesting than this one./</listitem>
     </itemizedlist></para></listitem></varlistentry>

   <varlistentry><term/Revision 3 - May 4, 1999/
     <listitem><para><itemizedlist>
      <listitem><para/Removed the "compatible games" list. I haven't found a non-compatible
        SCI0 game yet, which makes the list quite useless./</listitem>
      <listitem><para/Verified that SCI1 sound resources are different./</listitem>
      <listitem><para/Tidied the "About the output medium" section. Does that term "output
        medium" sound wordy or unclear? I don't really like it, but I didn't
        want to beat "sound device" to death./</listitem>
      <listitem><para/More information about the header/</listitem>
      <listitem><para/Modified the explanation for message FCh./</listitem>
      <listitem><para/Changed most references to status bytes as "commands" with "messges"
        to stay more consistent with MIDI terminology./</listitem>
      <listitem><para/Added midi.org as a source for more MIDI information/</listitem>
      <listitem><para/Removed labels like "tentative" and "incomplete" as things become
        more concrete -- not complete yet, but getting there./</listitem>
      <listitem><para/More information about controls/</listitem>
     </itemizedlist></para></listitem></varlistentry>

   <varlistentry><term/Revision 2 - Jan. 16, 1999/
     <listitem><para><itemizedlist>
      <listitem><para/Got rid of the HTML. I originally intented to post this as a message
        on the webboard, but ended up distributing the file. If I'm going to
        distribute it as a file, there's no need to bother with the HTML
        since I can do all my formatting as plain text./</listitem>
      <listitem><para/I found refrences to command 8x in the 1988 Christmas Card, so my
        comment about not seeing one got removed. To date, I haven't seen any
        examples of commands Ax or Dx./</listitem>
      <listitem><para/Expanded the header section./</listitem>
      <listitem><para/Added information about controls./</listitem>
      <listitem><para/Added information about the output mediums./</listitem>
      <listitem><para/Tried to be more consistent with terminology/</listitem>
     </itemizedlist></para></listitem></varlistentry>

   <varlistentry><term/Revision 1 - Dec. 29, 1998/
     <listitem><para><itemizedlist>
      <listitem><para/First release of the specification/</listitem>
     </itemizedlist></para></listitem></varlistentry>
  </variablelist>
  </para>
 </sect2>
</sect1>

   <sect1>
    <title/Mapping instruments in FreeSCI/
    <sect2><Title/The Patch.002 resource/
     <para>
       As Ravi describes in his description of the patch resources (which have not been included
       here), one of the major problems with SCI sound support is the lack of General Midi (GM)
       support in the earlier games. Since those were written before GM was conceived, this
       can hardly be considered to be Sierra's fault; but this fact doesn't help when it comes
       to supporting the games in a portable manner.
     </para><para>
       Unfortunately, almost every SCI0 game uses an individual instrument mapping scheme. This
       means that there are only two options to generate GM music from the original SCI sound
       resources: Either create a manual mapping for each game, or abuse existing data from the
       game for this purpose. Obviously, the latter way would be either impossible or much
       easier.
     </para><para>
       So, the solution would be to use an existing instrument mapping scheme. Those mapping schemes
       are stored in the patch resources, and, as such, easily accessible to an SCI engine.
       As those patch files are driver dependant (which, in turn, are hardware dependant), most
       of the patch data is unusable. The Adlib data, for example, will only work for an OPL-2
       FM synthesizer chip or one of its successors, the MT-32 data (which consists of one massive
       sysex block) won't help anyone without an MT-32 or LAPC-1, and so on. So, to recycle
       this hardware-dependant data, two new possibilities remain: Either extract and interpret
       the patch data using a portable software synthesizer (such as timidity), or extract
       instrument names and map those to GM instruments. The first approach would, of course,
       yield the better results (at the cost of computation power); but the only software emulator
       for a specific sound system I've seen so far was an OPL-2 emulator. So the alternative,
       extracting a text ID of each instrument and using it to map this instrument to a GM instrument,
       looks much more promising.
     </para><para>
       Now, most SCI0 games come with a patch.002 resource, which is used by the IBM Music Feature card
       and Yamaha FM-01 sound synthesizers (both of which appear to use frequency modulation).
       This is the only patch file that includes text descriptions of most of its instruments. Note
       this, not all instruments have name representation. This means that some of them can't be
       mapped and have to be silenced; but those instruments are either used for sound effects only
       or not used at all, so this isn't critical.
     </para><para>
       Using those 7-letter instrument names, it is now possible to build a small database of
       instruments, which, subseqently, can be mapped to GM instruments.
     </para><para>
       The file structure is relatively simple (for this purpose): Every patch.002 consists of
       either one or two instrument banks carrying 48 instruments each. Every instrument has a
       fixed block size of 0x40 bytes; each block starts with the 7-letter description of the
       instrument or seven blanks if none is available.
     </para><para>
       If two banks are present, the second bank is separated from the first one by a two-byte
       sequence (0xab, 0xcd). Keeping this in mind, it is trivial to extract the instrument names
       of the 48 or 96 instruments.
     </para>
    </sect2>
    <sect2><title/Percussion instruments/
     <para>
       Percussion instruments are treated specially in the MIDI standard. MIDI channel 10 (or 9,
       if you count from 0 to 15 like most people do) is reserved for percussions and some
       special effects; each key for this channel represents either nothing or one
       fixed percussion instrument.
     </para><para>
       At first glance, this might lead to an additional problem of mapping those percussion
       instruments. Fortunately, the General Midi standard extends on the MT-32 percussion mappings,
       which are used in SCI0, so that channel 9 can be left completely untouched in the process
       of instrument mapping.
     </para>
    </sect2>
   </sect1>
</chapter>


<Chapter>
 <Title/The SCI virtual machine/
  <sect1>
  <Title/Introduction/
   <sect2>
   <Title/Script resources and the VM/
    <para>
      Like any processor, the SCI virtual machine is useless without code to execute.
      This code is provided by script resources, which constitute the logic behind any
      SCI game.
    </para><para>
      In order to operate on the script resource, those first have to be loaded to the heap.
      The heap is the only memory space that the VM can work on directly (with some restrictions); all
      other memory spaces have to be used implicitly or explicitly by using kernel calls.
      The heap also contains a stack, which is heavily used by SCI bytecode.
    </para><para>
      Each script resource may contain one or several of various script objects, listed
      here<footnote><para/Other types are used as well, but they are addressed directly by the
      SCI bytecode, so their meaning has not been thoroughly investigated yet/</footnote>:
      <simplelist>
       <member/Type 1: Object/
       <member/Type 2: Code/
       <member/Type 3: Synonym word lists/
       <member/Type 4: Said specs/
       <member/Type 5: Strings/
       <member/Type 6: Class/
       <member/Type 7: Exports/
       <member/Type 8: Relocation table/
       <member/Type 9: Preload text (a flag, rather than a real section)/
       <member/Type 10: Local variables/
      </simplelist>
      </para><para>
       The code blocks contain the SCI bytecode that actually gets executed. The export block
       (of which there may be only one (or none at all)) contains script-relative pointers to
       exported functions, which can be called by the SCI operations <function/calle/ and
       <function/callb/. The local variables block, which stores one of the four variable types,
       is used to share variables among the objects and classes of one script.
      </para><para>
       But the most important script members are Objects and Classes. As in the usual OOP terms,
       Classes refer to object prototypes, and Objects are instantiated Classes. However, unlike
       most OOP languages, SCI treats the base class very similar to objects, so that they may
       actually get called by the SCI bytecode. Therefore, they also have their own space for
       selectors (see below). Also, each object or class knows which class it inherits from and
       which class it was instantiated from (in the case of objects).
      </para><para>
       Also of note is the relocation table (type 8). It contains script-relative pointers to other
       script-relative pointers that have to be translated to absolute (heap-relative) pointers
       during script loading<footnote><para/Thanks to Francois Boyer for this information/</footnote>.
    </para>
   </sect2>
   <sect2>
   <Title/Selectors/
    <para>
       Selectors are very important in SCI. They can be either methods or object/class-relative
       variables, and this makes the interpretation of SCI operations like <function/send/
       a bit tricky.
    </para><para>
       Each class comes with two two-dimensional tables. The first table contains selector values
       and selector indices<footnote><para>Those can be used as an index into vocab.997, where
       the selector names are stored as strings.</para></footnote> for each variable selector. The
       second table contains selector indices and script-relative method offsets. Objects look
       nearly identical, but they do not contain the list of selector indices for variable selectors,
       since those can be looked up at the class they were instantiated from (their "species", which
       happens to be one of the variable selectors).
    </para><para>
       Now, whenever a selector is sent for, the engine has to determine the right action to take.
       FreeSCI first determines whether the selector is a variable selector, by looking for it in
       the list of variable selector indices of the species class of the object that the
       "<function/send/" was sent to (classes use their own class number as their species class)
       <footnote><para/In practice, send looks up the heap position of the requested class in a
       global class table./</footnote>. If it is, the selector value is either read (if no parameter
       was provided to the <function/send/ call) or set (if one parameter was provided). If the
       selector was not part of the variable selectors of the specified object, the object's methods
       are checked for this selector index. If they don't contain the selector index, either, then
       FreeSCI recurses into checking the method selectors of the object's superclasses. If it finds
       the selector value there, it calls the heap address corresponding to the selector index.
    </para>
   </sect2>
   <sect2>
   <Title/Function invocation/
    <para>
       SCI provides three distinct ways for invocating a function<footnote><para/Of course, "manual"
       invocation (using push and jump operations) could also be used, but there are no special
       provisions for it, and it does not appear to be used in the existing SCI bytecode./</footnote>:
       <simplelist>
        <member>Calling exported functions (<function/calle/, <function/callb/)</member>
        <member>Calling selector methods (<function/send/, <function/self/, <function/super/)</member>
        <member>Calling PC-relative addresses (<function/call/)</member>
       </simplelist>
    </para><para>
       Exported functions are called by providing a script number and an exported function number
       (which is then looked up in the script's Type 7 block). They use the object they were called
       from to look up local variables and selectors for <function/self/ and <function/super/.
     </para><para>
       Selector methods are called by providing an object and a selector index. The selector index
       gets looked up in the object's selector tables, and, if it is used for a method, this method
       gets invocated. The provided object is used for local references.
     </para><para>
       PC-relative calls only make sense inside scripts, since they jump to a position relative
       to the <function/call/ opcode. The calling object is used for local references.
    </para>
   </sect2>
   <sect2>
   <Title/Variable types/
    <para>
       SCI bytecode can address four types of variables (not counting the variable selectors).
       Those variable types are:
       <variablelist>
         <varlistentry>
          <term/Local variables/
           <listitem><para>
              These are the variables stored in Type 10 script blocks. They are shared between
              the objects and classes of each script.
           </para></listitem>
         </varlistentry>
         <varlistentry>
          <term/Global variables/
           <listitem><para>
              These variables are the local variables of script 0.
           </para></listitem>
         </varlistentry>
         <varlistentry>
          <term/Temporary variables/
           <listitem><para>
              Those variables are stored on the stack. They are relative to the stack frame of
              the current method, so space for them must be allocated before they can be used.
              This is commonly done by using the <function/link/ operation.
           </para></listitem>
         </varlistentry>
         <varlistentry>
          <term/Parameters/
           <listitem><para>
              Parameters are stored on the stack below the current stack frame, as they technically
              belong to the calling function. They can be modified, if neccessary.
              <footnote><para/Obviously, SCI uses a call-by-value model/</footnote>
           </para></listitem>
         </varlistentry>
       </variablelist>
    </para>
   </sect2>
  </sect1>
  <sect1 ID="LSExecLoop">
  <title/Interpreter initialization and the main execution loop/
  <para>
By <author><firstname/Lars/<surname/Skovlund/</author>
Version 1.0, 7. July 1999
</para><para>
When the interpreter initializes, it sets up a timer for 60 hertz (one that
"ticks" 60 times per second). This timer does two things: it lets
the so-called servers execute (most notably, the sound player and input
manager) and it "feeds" the internal game clock. This 60 hz. "systick" is
used all over the place. For example, it is accessible using the KGetTime
kernel function. Some graphic effects depend on it, for example the
"shake screen" effect. In SCI1, it is also used for timing in the palette
fades. And naturally, it is used in the KWait kernel call.
</para><para>
Basically, the initialization proceeds as follows:
<simplelist>
<member/   Initialize the heap and hunk./
<member/   Parse the config file and the command line./
<member/   Load the drivers specified in the config file/
<member/   Initialize the graphics subsystem./
<member/   Initialize the event manager/
<member/   Initialize the window manager/
<member/   Initialize the text parser (i.e. load the vocabulary files)/
<member/   Initialize the music player/
<member>   Save the machine state for restarting the game later on
  <footnote><para>This is quite interesting, the KRestartGame kernel call is implemented
  using a simple setjmp/longjmp pair.</para></footnote></member>
<member/   Allocate the PMachine stack on the heap./
<member/   Get a pointer to the game object/
<member/   And run, by executing the play or replay method./
</simplelist>
</para><para>
The right game object is found by looking in the "dispatch table" of script
0. The dispatch table has block type 7, and is an array of words. The first
entry is a pointer (script relative) to the game object, for instance SQ3.
If the game was restarted, the interpreter executes the replay method, play
otherwise.
</para><para>
After looking up the address of the method in the object block, execution is
started. It can be viewed as a huge switch statement, which executes con-
tinuously. When the last ret statement (in the play or replay method) is
met, the interpreter terminates.
</para><para>
The ExecuteCode function, which contains the mentioned switch statement,
is called recursively. It lets other subroutines handle the object
complexity, all the ExecuteCode function has is a pointer to the next in-
struction. Thus, it is easy to terminate the interpreter; just return from
all running instances of ExecuteCode.
</para><para>
So, how does an SCI program execute? Well, the play method is defined in the
Game class, and it is never overridden. It consists of a huge loop which
calls Game::doit continuously, followed by a pause according to the selected
animation speed. That is, the script, not the interpreter, handles animation
speed. Notice how the debugger very often shows the statement sag $12 upon
entering the debugger? This instruction resides in Game::play, and the break
occurs here because of a KWait kernel call which is executed right before
that instruction. This wait takes the most execution time, so therefore the
debug break is most likely to be
A game programmer would then override Game::doit and place the game
specific main loop here (still, Game::doit is almost identical from game to
game). Execution of the Game::play main loop stops when an event causes
global variable 4 to be non-zero. The last ret instruction is met, and the
interpreter terminates.
</para>
  </sect1>

  <sect1>
   <Title/The SCI Heap/
    <para>
     SCI0 (and probably SCI1 as well) uses a heap consisting of 0xffff bytes of
     memory; this size corresponds to the size of one i386 real-mode memory segment
     minus one.
     <Footnote><para/
     This appears to be the maximum size; the games generally require less heap
     space./
     </Footnote>
    </para>

     <sect2>
     <Title/Heap structure/
     <para>
      The original heap starts with 200 separate entries with a size of four bytes.
      Each of those entries appears to be a pointer to "hunk" memory, which is
      separate from the heap and not covered here. The actual heap base pointer
      points to the first byte that is not part of these pointers.
     </para>
     </sect2>

     <sect2>
      <Title/Memory handles/
      <para>
      A memory handle consists of two consecutive unsigned 16 bit integers:
      <itemizedlist>
       <listitem><para>The memory block size</para></listitem>
       <listitem><para>The heap address of the next memory handle</para></listitem>
      </itemizedlist>
      in this sequence.
      </para><para>
      Memory handles are stored inside of the heap; they delimit the holes in the
      heap by indexing each other, with the exception of the last handle, which
      points to zero.
     </para>
     </sect2>


     <sect2>
     <Title/Initialization/
     <para>
      The list is initialized to 0. Memory handle #0 is set to contain 0xffff minus
      the size required by the memory handles (800 bytes) to a total of 0xfcdf,
      the pointer to the next free index is set to 0x0.
     </para>
     </sect2>

     <sect2>
     <Title/Memory allocation/
     <para>
      The memory allocation function takes one parameter; this is the requested allocation
      block size. If it is 0, the function aborts. Otherwise, the size is increased by 2
      (and then again by 1, if it is odd, for alignment purposes).
     </para><para>
      After the memory allocation algorithm finds a sufficiently large memory hole, it
      allocates its memory by splitting the memory hole and allocating the lower part
      (or by swallowing the upper part if its size would be less than four). It adjusts the
      previous memory handle (which used to point to the start of the now allocated part
      of the heap) to point to the next hole, and then goes on to write its size to the first
      two bytes of its newly allocated home.
     </para><para>
      If no sufficiently large memory hole can be found, the function returns 0; otherwise,
      it returns a heap pointer to the start of the allocated block (i.e. to the two bytes
      that carry the block's size).
     </para>
     <para>
      Memory deallocation does this process in reverse; it also merges adjacent memory holes
      to prevent memory fragmentation.
     </para>
     </sect2>
  </sect1>

  <sect1 ID="VM">
    <Title/The Sierra PMachine/
      <para>
        <author><firstname/Lars/ <surname/Skovlund/ </author>,
        <author><firstname/Dark/ <surname/Minister/ </author> and
        <author><firstname/Christoph/ <surname/Reichenbach/ </author>
      </para><para>
         Version 1.0, 6. July 1999 </para>
      <para>
This document describes thee design of the Sierra PMachine (the virtual CPU
used for executing SCI programs). It is a special CPU, in the sense that it
is designed for object oriented programs.
</para><para>
There are three kinds of memory in SCI: Variables, objects, and stack space.
The stack space is used in a Last-In-First-Out manner, and is primarily used
for temporary space in a routine, as well as passing data from one routine
to another. Note that the stack space is used bottom-up by the original in-
terpreter, instead of the more usual top-down. I don't know if this has any
significance for us.
</para><para>
Scripts are loaded into the PMachine by creating a memory imagee of it on 
the
heap. For this reason, the script file format may seem a bit obscure at
times. It is optimized for in-memory performance, not readability. It should
be mentioned here that a lot of fixup stuff is done by the interpreter.
In the script files, all addresses are specified as script-relative. These
are converted to absolute offsets. The species and superClass fields of all
objects are converted into pointers to the actual class etc.
</para><para>
There are four types of variables. These are called global, local, 
temporary,
and parameter. All four types are simple arrays of 16-bit words. A pointer 
is
kept for each type, pointing to the list that is currently active. In fact,
only the global variable list is constant in memory. The other pointers are
changed frequently, as scripts are loaded/unloaded, routines called, etc.
The variables are always referenced as an index into the variable list.
I'll explain the four types below - the names in parantheses will be used
occasionally in the rest of the text:
</para>
<sect2><Title/Local variables (LocalVar)/
<para>
This variable type is called "local" because it belongs to a specific 
script.
Each script may have its own set of local variables, defined by script block
type 10. As long as the code from a specific script is running, the local
variables for that script are "active" (pointed to by the mentioned 
pointer).
</para></sect2>
<sect2><Title/Global variables/
<para>
These, like the local variables, reside in script space (in fact, they are
the local variables of script 0!). But the pointer to them remains constant
for the whole duration of the program.
</para></sect2>
<sect2><Title/Temporary variables/
<para>
These are allocated by specific subroutines in a script. They reside on the
PMachine stack and are allocated by the link opcode. The temp variables are
automatically discarded when the subroutine returns.
</para></sect2>
<sect2><Title/Parameter variables/
<para>
These variables also reside on the stack. They contain information passed
from one routine to another. Any routine in SCI is capable of taking a
variable number of parameters, if need be. This is possible because a list
size is pushed as the first thing before calling a routine. In addition to
this, a frame size is passed to the call* functions.
</para></sect2>
<sect2><Title/Objects/
<para>
While two adjacent variables may be entirely unrelated, the contents of an
object is always related to one task. The object, like the variable tables,
provides storage space. This storage space is called properties. Depending
on the instructions used, a property can be referred to by index into the
object structure, or by property IDs (PIDs). For instance, the name property
has the PID 17h, but the offset 6. The property IDs are assigned by the SCI
compiler, and it is the "compatible" way of accessing object data. Whereas
the offset method is used only internally by an object to access its own
data, the PID method is used externally by objects to read/write the data
fields of other objects. The PID method is also used to call methods in an
object, either by the object itself, by another object, or by the SCI inter-
preter. Yes, this really happens sometimes.
</para></sect2>
<sect2><Title/The PMachine "registers"/
<para>
The PMachine can be said to have a number of registers, although none of 
them
can be accessed explicitly by script code. They are used/changed implicitly
by the script opcodes:
<simplelist>
  <member/Acc - the accumulator. Used for result storage and input for a number of
  opcodes./
  <member>IP - the instruction pointer.<Footnote><para/FreeSCI calls this the "Program Counter"
          or PC, which is the more general term./</footnote>
          Points to the currently executing instruction</member>
  <member/Vars - an array of 4 values, pointing to the current variables of each
  mentioned type/
  <member/Object - points to the currently executing object./
  <member/SP - the current stack pointer. Note that the stack in the original SCI
  interpreter is used bottom-up instead of the more usual top-down./
</simplelist>
</para><para>
The PMachine, apart from the actual instruction pointer, keeps a record of
which object is currently executing.
</para></sect2>
<sect2><title/The instruction set/
<para>
The PMachine CPU potentially has 128 instructions (however, a couple of 
these
are invalid and generate an error). Some of these instructions have a flag
which specify whether the opcode has byte- or word-sized operands (I will
refer to this as variably-sized parameters, as opposed to constant
parameters). Other instructions have only one calling form. These
instructions simply disregard the operand size flag. Ideally, however, all
script instructions should be prepared to take variably-sized operands.
Yet another group of instructions take both a constant parameter and a
variably-sized parameter. The format of an opcode byte is as follows:
<informaltable frame="all">
 <tgroup cols="2">
  <tbody>
   <row>
    <entry/bit 7-1/<entry/        opcode number/
   </row><row>
    <entry/bit 0/<entry/            operand size flag/
   </row>
  </tbody>
 </tgroup>
</informaltable>
</para>
<sect3><title/Relative addresses/
<para>
Certain instructions (in particular, branching ones) take relative addresses
as a parameter. The actual address is calculated based on the instruction
after the branching instruction itself. In this example, the bnt
instruction, if the branch is made, jumps over the ldi instruction.
<programlisting>
        eq?
        bnt +2
        ldi byte 2
        push
</programlisting>
<note><para/Relative addresses are signed values./</note>
</para></sect3>
<sect3><title/Dispatch addresses/
<para>
The callb and calle instructions take a so-called dispatch index as a
parameter. This index is used to look up an actual script address, using the
so-called dispatch table. The dispatch table is located in script block type
7 in the script file. It is a series of words - the first one, as in so many
other places in the script file, is the number of entries.
</para></sect3>
<sect3><title/Frame sizes/
<para>
In every call instruction, a value is included which determines the size of
the parameter list, as an offset into the stack. This value discounts the
list size pushed by the SCI code. For instance, consider this example from
real SCI code:

<programlisting>
     pushi 3 ; three parameters passed
     pushi 4 ; the screen flag
     pTos x ; push the x property
     pTos y ; push the y property
     callk OnControl, 6
</programlisting>

Notice that, although the callk line specifies 6 bytes of parameters, the
kernel routine has access to the list size (which is at offset 8)!
</para></sect3>
<sect3><title/PErrors/
<para>
These are internal errors in the interpreter. They are usually caused by
buggy script code. The PErrors end up displaying an "Oops!" box in the
original interpreter (it is interesting to see how Sierra likes to believe
that PErrors are caused by the user - judging by the message "You did
something we weren't expecting"!). In the original interpreter, specifying
-d on the command line causes it to give more detailed information about
PErrors, as well as activating the internal debugger if one occurs.
</para></sect3>
<sect3><Title/Class numbers and adresses/
<para>
The key to finding a specific class lies in the class table. This class
table resides in VOCAB.996, and contains the numbers of scripts that carry
classes. If a script has more than one class defintion, the script number
is repeated as necessary. Notice how each script number is followed by a
zero word? When the interpreter loads a script, it checks to see if the
script has classes. If it does, a pointer to the object structure is put in
this empty space.
</para></sect3>
<sect3><title/The instructions/
<para>
The instructions are described below. I have used Dark Minister's text on
the subject as a starting point, but many things have changed; stuff
explained more thoroughly, errors corrected, etc. The first 23 instructions
(up to, but not including, bt) take no parameters.
      </para><para>
         These functions are used in the pseudocode explanations:
         <simplelist>
           <member/pop(): sp -= 2; return *sp;/
           <member/push(x): *sp = x; sp += 2; return x;/
         </simplelist>
         The following rules apply to opcodes:
         <simplelist>
           <member/Parameters are signed, unless stated otherwise. Sign extension is performed./
           <member/Jumps are relative to the posisition of the next operation./
           <member/*TOS refers to the TOS (Top Of Stack) element./
           <member/"tmp" refers to a temporary register that is used for explanation purposes only./
         </simplelist>
      </para>
          <itemizedlist>
           <listitem><para>
              <simplelist>
                <member>op 0x00: bnot  (1 byte)</member>
                <member>op 0x01: bnot  (1 byte)</member>
              </simplelist>
              Binary not:
                 <programlisting/acc ^= 0xffff;/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x02: add  (1 byte)</member>
                <member>op 0x03: add  (1 byte)</member>
              </simplelist>
              Addition:
                 <programlisting/acc += pop();/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x04: sub  (1 byte)</member>
                <member>op 0x05: sub  (1 byte)</member>
              </simplelist>
              Subtraction: 
                 <programlisting/acc = pop() - acc;/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x06: mul  (1 byte)</member>
                <member>op 0x07: mul  (1 byte)</member>
              </simplelist>
              Multiplication:
                 <programlisting/acc *= pop();/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x08: div  (1 byte)</member>
                <member>op 0x09: div  (1 byte)</member>
              </simplelist>
              Division:
                 <programlisting>acc = pop() / acc;</programlisting>

              Division by zero is caught => acc = 0.
           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x0a: mod  (1 byte)</member>
                <member>op 0x0b: mod  (1 byte)</member>
              </simplelist>
              Modulo:
                 <programlisting/acc = pop() % acc;/

              Modulo by zero is caught => acc = 0.
           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x0c: shr  (1 byte)</member>
                <member>op 0x0d: shr  (1 byte)</member>
              </simplelist>
              Shift Right logical:
                 <programlisting/acc = pop() >> acc;/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x0e: shl  (1 byte)</member>
                <member>op 0x0f: shl  (1 byte)</member>
              </simplelist>
              Shift Left logical:
                 <programlisting/acc = pop() << acc;/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x10: xor  (1 byte)</member>
                <member>op 0x11: xor  (1 byte)</member>
              </simplelist>
              Exclusive or:
                 <programlisting/acc ^= pop();/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x12: and  (1 byte)</member>
                <member>op 0x13: and  (1 byte)</member>
              </simplelist>
              Logical and:
                 <programlisting/acc &= pop();/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x14: or  (1 byte)</member>
                <member>op 0x15: or  (1 byte)</member>
              </simplelist>
              Logical or:
                 <programlisting/acc |= pop();/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x16: neg  (1 byte)</member>
                <member>op 0x17: neg  (1 byte)</member>
              </simplelist>
              Sign negation:
                 <programlisting/acc = -acc;/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x18: not  (1 byte)</member>
                <member>op 0x19: not  (1 byte)</member>
              </simplelist>
              Boolean not:
                 <programlisting/acc = !acc;/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x1a: eq?  (1 byte)</member>
                <member>op 0x1b: eq?  (1 byte)</member>
              </simplelist>
              Equals?:
                 <programlisting/prev = acc;
                                 acc = (acc == pop());/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x1c: ne?  (1 byte)</member>
                <member>op 0x1d: ne?  (1 byte)</member>
              </simplelist>
              Is not equal to?
                 <programlisting/prev = acc;
                                 acc = !(acc == pop());/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x1e: gt?  (1 byte)</member>
                <member>op 0x1f: gt?  (1 byte)</member>
              </simplelist>
              Greater than?
                 <programlisting/prev = acc;
                                 acc = (pop() > acc);/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x20: ge?  (1 byte)</member>
                <member>op 0x21: ge?  (1 byte)</member>
              </simplelist>
              Greater than or equal to?
                 <programlisting/prev = acc;
                                 acc = (pop() >= acc);/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x22: lt?  (1 byte)</member>
                <member>op 0x23: lt?  (1 byte)</member>
              </simplelist>
              Less than?
                 <programlisting/prev = acc;
                                 acc = (pop() < acc);/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x24: le?  (1 byte)</member>
                <member>op 0x25: le?  (1 byte)</member>
              </simplelist>
              Less than or equal to?
                 <programlisting/prev = acc;
                                 acc = (pop() <= acc);/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x26: ugt?  (1 byte)</member>
                <member>op 0x27: ugt?  (1 byte)</member>
              </simplelist>
              Unsigned: Greater than?
                 <programlisting/acc = (pop() > acc);/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x28: uge?  (1 byte)</member>
                <member>op 0x29: uge?  (1 byte)</member>
              </simplelist>
              Unsigned: Greather than or equal to?  
                 <programlisting/acc = (pop() >= acc);/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x2a: ult?  (1 byte)</member>
                <member>op 0x2b: ult?  (1 byte)</member>
              </simplelist>
              Unsigned: Less than?
                 <programlisting/acc = (pop() < acc);/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x2c: ule?  (1 byte)</member>
                <member>op 0x2d: ule?  (1 byte)</member>
              </simplelist>
              Unsigned: Less than or equal to?
                 <programlisting/acc = (pop() <= acc);/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x2e: bt W relpos  (3 bytes)</member>
                <member>op 0x2f: bt B relpos  (2 bytes)</member>
              </simplelist>
              Branch relative if true
                 <programlisting/if (acc) pc += relpos;/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x30: bnt W relpos  (3 bytes)</member>
                <member>op 0x31: bnt B relpos  (2 bytes)</member>
              </simplelist>
              Branch relative if not true
                 <programlisting/if (!acc) pc += relpos;/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x32: jmp W relpos  (3 bytes)</member>
                <member>op 0x33: jmp B relpos  (2 bytes)</member>
              </simplelist>
              Jump
                 <programlisting/pc += relpos;/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x34: ldi W data  (3 bytes)</member>
                <member>op 0x35: ldi B data  (2 bytes)</member>
              </simplelist>
              Load data immediate
                 <programlisting/acc = data;/
              Sign extension is done for 0x35 if required.

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x36: push  (1 byte)</member>
                <member>op 0x37: push  (1 byte)</member>
              </simplelist>
              Push to stack
                 <programlisting/push(acc)/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x38: pushi W data  (3 bytes)</member>
                <member>op 0x39: pushi B data  (2 bytes)</member>
              </simplelist>
              Push immediate
                 <programlisting/push(data)/
              Sign extension for 0x39 is performed where required.

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x3a: toss  (1 byte)</member>
                <member>op 0x3b: toss  (1 byte)</member>
              </simplelist>
              TOS subtract
                 <programlisting/pop();/
              For confirmation: Yes, this simply tosses the TOS value away.

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x3c: dup  (1 byte)</member>
                <member>op 0x3d: dup  (1 byte)</member>
              </simplelist>
              Duplicate TOS element
                 <programlisting/push(*TOS);/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x3e: link W size  (3 bytes)</member>
                <member>op 0x3f: link B size  (2 bytes)</member>
              </simplelist>
                 <programlisting/sp += (size * 2);/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x40: call W relpos, B framesize  (4 bytes)</member>
                <member>op 0x41: call B relpos, B framesize  (3 bytes)</member>
              </simplelist>
              Call inside script.
              <programlisting/(See description below)
                              sp -= (framesize + 2 + &amp;rest_modifier);
                              &amp;rest_modifier = 0;/
              This calls a script subroutine at the relative position
              <parameter/relpos/, setting up the ParmVar pointer first.
              ParmVar points to sp-<parameter/framesize/ (but see also the &amp;rest operation).
              The number of parameters is stored at word offset -1 relative to ParmVar.

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x42: callk W kfunct, B kparams  (4 bytes)</member>
                <member>op 0x43: callk B kfunct, B kparams  (3 bytes)</member>
              </simplelist>
              Call kernel function (see <XREF LINKEND="Kfunctions">)
                 <programlisting/sp -= (kparams + 2 + &amp;rest_modifier);
                                 &amp;rest_modifier = 0;
                                 (call kernel function <parameter/kfunct/)/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x44: callb W dispindex, B framesize  (4 bytes)</member>
                <member>op 0x45: callb B dispindex, B framesize  (3 bytes)</member>
              </simplelist>
              Call base script
                 <programlisting/(See description below)
                              sp -= (framesize + 2 + &amp;rest_modifier);
                              &amp;rest_modifier = 0;/
              This operation starts a new execution loop at the beginning of script 0, public
              method <parameter/dispindex/ (Each script comes with a dispatcher list (type 7) that
              identifies public methods). Parameters are handled as in the call operation.

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x46: calle W script, B dispindex, B framesize  (5 bytes)</member>
                <member>op 0x47: calle B script, B dispindex, B framesize  (4 bytes)</member>
              </simplelist>
              Call external script
                 <programlisting/(See description below)
                              sp -= (framesize + 2 + &amp;rest_modifier);
                              &amp;rest_modifier = 0;/
              This operation starts a new execution loop at the beginning of script
              <parameter/script/s public method <parameter/dispindex/. The dispatcher list
              (the script's type 7 object) is used to dereference the requested method.
              Parameters are handled as described for the call operation.

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x48: ret  (1 byte)</member>
                <member>op 0x49: ret  (1 byte)</member>
              </simplelist>
              Return: returns from an execution loop started by call, calle, callb, send, self or
              super.
              

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x4a: send B framesize (2 bytes)</member>
                <member>op 0x4b: send B framesize (2 bytes)</member>
              </simplelist>
              Send for one or more selectors. This is the most complex SCI operation (together with
              self and class).
            </para><para>
              Send looks up the supplied selector(s) in the object pointed to by the accumulator.
              If the selector is a variable selector, it is read (to the accumulator) if it was sent
              for with zero parameters. If a parameter was supplied, this selector is set to that
              parameter. Method selectors are called with the specified parameters.
            </para><para>
              The selector(s) and parameters are retreived from the stack frame. Send first looks up
              the selector ID at the bottom of the frame, then retreives the number of parameters,
              and, eventually, the parameters themselves. This algorithm is iterated until all of
              the stack frame has been "used up". Example:
            <programlisting/; This is an example for usage of the SCI send operation
                            pushi x      ; push the selector ID of x
                            push1        ; 1 parameter: x is supposed to be set
                            pushi 42     ; That's the value x will get set to
                            pushi moveTo ; In this example, moveTo is a method selector.
                            push2        ; It will get called with two parameters-
                            push         ; The accumulator...
                            lofss 17     ; ...and PC-relative address 17.
                            pushi foo    ; Let's assume that foo is another variable selector.
                            push0        ; This will read foo and return the value in acc.
                            send 12      ; This operation does three quite different things./
                            

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x4c</member>
                <member>op 0x4d</member>
                <member>op 0x4e</member>
                <member>op 0x4f</member>
              </simplelist>
              These opcodes don't exist in SCI.

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x50: class W function  (3 bytes)</member>
                <member>op 0x51: class B function  (2 bytes)</member>
              </simplelist>
              Get class address.
              Sets the accumulator to the memory address of the specified <parameter/function/
              of the current object.

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x52</member>
                <member>op 0x53</member>
              </simplelist>
              These opcodes don't exist in SCI.

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x54: self B stackframe (2 bytes)</member>
                <member>op 0x55: self B stackframe (2 bytes)</member>
              </simplelist>
              Send to self. This operation is the same as the send operation, except that it
              sends to the current object instead of the object pointed to by the accumulator.

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x56: super W class, B stackframe (4 bytes)</member>
                <member>op 0x57: super B class, B stackframe (3 bytes)</member>
              </simplelist>
              Send to any class. This operation is the same as the send operation, except that it
              sends to an arbitrary <parameter/class/.

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x58: &amp;rest W paramindex  (3 bytes)</member>
                <member>op 0x59: &amp;rest B paramindex  (2 bytes)</member>
              </simplelist>
    Pushes all or part of the ParmVar list on the stack. The number specifies
    the first parameter variable to be pushed.
    I'll give a small example. Suppose we have two functions:
</para><para>
    function a(y,z)
    and
    function b(x,y,z)
</para><para>
    function b wants to call function a with its own y and z parameters. Easy
    job, using the the normal lsp instruction. Now suppose that both function
    a and b are designed to take a variable number of parameters:
</para><para>
    function a(y,z,...)
    and
    function b(x,y,z,...)
</para><para>
    Since lsp does not support register indirection, we can't just push the
    variables in a loop (as we would in C). Instead this function is used.
    In this case, the instruction would be &amp;rest 2, since we want the copying
    to start from y (inclusive), the second parameter.
</para><para>
    Note that the values are copied to the stack <emphasis>immediately</emphasis>.
    The <literal>&amp;rest_modifier</literal> is set to the number of variables pushed
    afterwards.


           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x5a: lea W type, W index ( bytes)</member>
                <member>op 0x5b: lea B type, B index ( bytes)</member>
              </simplelist>
              Load Effective Address
</para><para>
    The variable type is a bit-field used as follows:
  <variablelist>
   <varlistentry><term/bit 0/<listitem><para/      unused/</listitem></varlistentry>
   <varlistentry><term/bit 1-2/<listitem><para>  the number of the variable list to use
           <simplelist>
                       <member/       0 - globalVar/
                       <member/       2 - localVar/
                       <member/       4 - tempVar/
                       <member/       6 - parmVar/
           </simplelist>
         </para></listitem></varlistentry>
  <varlistentry><term/bit 3/<listitem><para/      unused/</listitem></varlistentry>
  <varlistentry><term/bit 4/<listitem><para/      set if the accumulator is to be used as additional index/</listitem></varlistentry>
  </variablelist>
Because it is so hard to explain, I have made a transcription of it here:

<programlisting>
< <![CDATA[
short *vars[4];

int acc;

int lea(int vt, int vi)
{
  return &((vars[(vt >> 1) & 3])[vt & 0x10 ? vi+acc : vi]);
}
]]>
</programlisting>

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x5c: selfID  (1 bytes)</member>
                <member>op 0x5d: selfID  (1 bytes)</member>
              </simplelist>
              Get 'self' identity: SCI uses heap pointers to identify objects, so this operation
              sets the accumulator to the address of the current object.
                 <programlisting/acc = object/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x5e</member>
                <member>op 0x5f</member>
              </simplelist>
              These opcodes don't exist in SCI.

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x60: pprev  (1 bytes)</member>
                <member>op 0x61: pprev  (1 bytes)</member>
              </simplelist>
              Push prev: Pushes the value of the prev register, set by the last comparison
              bytecode (eq?, lt?, etc.), on the stack.
                 <programlisting/push(prev)/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x62: pToa W offset  (3 bytes)</member>
                <member>op 0x63: pToa B offset  (2 bytes)</member>
              </simplelist>
              Property To Accumulator:
    Copies the value of the specified property (in the current object) to the
    accumulator. The property is specified as an offset into the object 
structure.

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x64: aTop W offset  (3 bytes)</member>
                <member>op 0x65: aTop B offset  (2 bytes)</member>
              </simplelist>
              Accumulator To Property:
    Copies the value of the accumulator into the specified property (in the
    current object). The property number is specified as an offset into the
    object structure.

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x66: pTos W offset  (3 bytes)</member>
                <member>op 0x67: pTos B offset  (2 bytes)</member>
              </simplelist>
              Property To Stack:
    Same as pToa, but pushes the property value on the stack instead.

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x68: sTop W offset  (3 bytes)</member>
                <member>op 0x69: sTop B offset  (2 bytes)</member>
              </simplelist>
              Stack To Property:
    Same as aTop, but gets the new property value from the stack instead.

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x6a: ipToa W offset  (3 bytes)</member>
                <member>op 0x6b: ipToa B offset  (2 bytes)</member>
              </simplelist>
              Incement Property and copy To Accumulator:
    Increments the value of the specified property of the current object
    and copies it into the accumulator. The property number is specified as
    an offset into the object structure.

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x6c: dpToa W offset  (3 bytes)</member>
                <member>op 0x6d: dpToa B offset  (2 bytes)</member>
              </simplelist>
              Decrepent Property and copy to Accumulator:
    Decrements the value of the specified property of the current object
    and copies it into the accumulator. The property number is specified as
    an offset into the object structure.

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x6e: ipTos W offset  (3 bytes)</member>
                <member>op 0x6f: ipTos B offset  (2 bytes)</member>
              </simplelist>
              Increment Property and push to Stack
    Same as ipToa, but pushes the result on the stack instead.

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x70: dpTos W offset  (3 bytes)</member>
                <member>op 0x71: dpTos B offset  (2 bytes)</member>
              </simplelist>
              Decrement Property and push to stack:
    Same as dpToa, but pushes the result on the stack instead.

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x72: lofsa W offset  (3 bytes)</member>
                <member>op 0x73: lofsa B offset  (2 bytes)</member>
              </simplelist>
              Load Offset to Accumulator:
              <programlisting>acc = pc + <parameter>offset</parameter></programlisting>
              Adds a value to the post-operation pc and stores the result in the accumulator.
             

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x74: lofss W offset  (3 bytes)</member>
                <member>op 0x75: lofss B offset  (2 bytes)</member>
              </simplelist>
              Load Offset to Stack:
              <programlisting>push(pc + <parameter>offset</parameter>)</programlisting>
              Adds a value to the post-operation pc and pushes the result on the stack.

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x76: push0  (1 bytes)</member>
                <member>op 0x77: push0  (1 bytes)</member>
              </simplelist>
              Push 0:
                 <programlisting/push(0)/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x78: push1  (1 bytes)</member>
                <member>op 0x79: push1  (1 bytes)</member>
              </simplelist>
              Push 1:
                 <programlisting/push(1)/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x7a: push2  (1 bytes)</member>
                <member>op 0x7b: push2  (1 bytes)</member>
              </simplelist>
              Push 2:
                 <programlisting/push(2)/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x7c: pushSelf  (1 bytes)</member>
                <member>op 0x7d: pushSelf  (1 bytes)</member>
              </simplelist>
              Push self:
                 <programlisting/push(object)/

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x7e</member>
                <member>op 0x7f</member>
              </simplelist>
              These operations don't exist in SCI.

           </para></listitem>
           <listitem><para>
              <simplelist>
                <member>op 0x80 - 0xfe: [ls+-][as][gltp]i? W index  (3 bytes)</member>
                <member>op 0x81 - 0xff: [ls+-][as][gltp]i? B index  (2 bytes)</member>
              </simplelist>
              The remaining SCI operations work on one of the four variable types. The variable
              index is retreived by taking the heap pointer for the specified variable type, adding
              the <parameter/index/ and possibly the accumulator, and executing the operation according
              to the following table:
              <variablelist>
                <varlistentry>
                 <term/Bit 0/
                 <listitem><para>
                   Used as with all other opcodes with variably-sized parameters:
                   <simplelist>
                    <member/0: 16 bit parameter/
                    <member/1: 8 bit parameter/
                   </simplelist>
                 </para></listitem>
                </varlistentry>
                <varlistentry>
                 <term/Bits 1,2/
                 <listitem><para>
                   The type of variable to operate on:
                   <simplelist>
                    <member/0: Global/
                    <member/1: Local/
                    <member/2: Temporary/
                    <member/3: Parameter/
                   </simplelist>
                 </para></listitem>
                </varlistentry>
                <varlistentry>
                 <term/ Bit 3/
                 <listitem><para>
                   Whether to use the accumulator or the stack for operations:
                   <simplelist>
                    <member/0: Accumulator/
                    <member/1: Stack/
                   </simplelist>
                 </para></listitem>
                </varlistentry>
                <varlistentry>
                 <term/Bit 4/
                 <listitem><para>
                   Whether to use the accumulator as a modifier to the supplied index:
                   <simplelist>
                    <member/0: Don't use accumulator as an additional index/
                    <member/1: Use the accumulator as an additional index/
                   </simplelist>
                 </para></listitem>
                </varlistentry>
                <varlistentry>
                 <term/Bits 5,6/
                 <listitem><para>
                   The type of execution to perform:
                   <simplelist>
                    <member/0: Load the variable to the accumulator or stack/
                    <member/1: Store the accumulator or stack in the variable/
                    <member/2: Increment the variable, then load it into acc or on the stack/
                    <member/3: Decrement the variable, then load it into acc or on the stack/
                   </simplelist>
                 </para></listitem>
                </varlistentry>
                <varlistentry>
                 <term/Bit 7/
                 <listitem><para>
                   Always 1 (identifier for these opcodes)
                 </para></listitem>
                </varlistentry>
              </variablelist>
              Example: "sagi 2" would Store the Accumulator in the Global variable indexed with
              2 plus the current accumulator value (this rarely makes sense, obviously). "+sp 6"
              would increment the parameter at offset 6 (the third parameter, not counting the
              argument counter), and push it on the stack.

           </para></listitem>
          </itemizedlist>
         </sect3>
     </sect2>
  </sect1>

  <sect1 ID="Kfunctions">
   <Title/Kernel functions/
<note><para/Thanks to Lars Skovlund and Francois Boyer for additional information!/</note>
<para>
In SCI0, calls to the SCI kernel are initiated by using the <function>callk</function> opcode.
<function>callk</function> has the opcode <literal>0x42</literal>
or <literal>0x43</literal>; <literal>0x42</literal> takes one 16 bit little endian and
one 8 bit paramter, <literal/0x43/ takes two 8 bit parameters.
The first parameter is the number of the kernel function to be called, the
second number undetermined (as of yet).
</para><para>
Opcode summary:
</para><para>
<simplelist>
<member>op 0x42: callk W kfunct, B kparams  (4 bytes)</member>
<member>op 0x43: callk B kfunct, B kparams  (3 bytes)</member>
</simplelist>
</para><para>
The number of parameters passed to the kernel function are determined
by kparam. A total number of (kparams+2) bytes are removed from the local
stack and passed on to the kernel function.
The first two of those bytes are apparently always created by pushing
the number of following bytes.
For example, if Load(view, 10) is called, then we've got two word
parameters, "view" (0x0080) and "10" (0x000a). So the callk function would
have kparams set to 4; this value would be pushed to the stack first,
followed by the two parameters.
So the stack would look like this (left means lower address, byte ordering
little endian):
</para><para>

<literal/02 00  80 00  0a 00/
</para><para>
before calling Load().

</para><para>

Return values are returned into the accumulator, unless stated otherwise.
If return type is stated as (void), then the accumulator is not modified.
</para>


<sect2>
<Title/Parameter types/
<para>
SCI0 uses only little endian 16 bit integer values for parameters. However, this document
distinguishes between different uses of those integers by defining the following variable
types:
<simplelist>
<member><Type/(word)/: 16 bit signed little endian integer</member>
<member><Type/(HeapPtr)/: As <Type/(word)/; interpreted as a pointer to a heap address</member>
<member><Type/(DblList)/: As <Type/(HeapPtr)/; interpreted as offset of a doubly linked list</member>
<member><Type/(Node)/: As <Type/(HeapPtr)/; interpreted as offset of a list node</member>
<member><Type/(&amp;FarPtr)/: As <Type/(HeapPtr)/; interpreted as the 32 bit pointer stored at
           the referenced heap address</member>
<member><Type/(Point)/: A sequence of two <Type/(word)/s to describe a point on the screen, with
the y coordinate being the first in the sequence.</member>
<member><Type/(Rect)/: A sequence of four <Type/(word)/s describing a rectangle. If you read
"(Rect) foo", think "(word) foo_ymin, (word) foo_xmin, (word) foo_ymax, (word) foo_xmax" instead.
</member>
<member><Type/(String)/: If greater than or equal to 1000, this is the heap address of a text string.
If less than 1000, it is the number of a text resource, and immediately followed by another word
that contains the number of the string inside the text resource.</member>
</simplelist>
</para><para>
Parameters in brackets (like "[foo]") are optional.
</para><para>
Most functions exit gracefully if either a NULL HeapPtr or DblList is
provided.
</para></sect2>

<sect2><Title/SCI0 Kernel functions/

  <sect3>
<Title/Kernel function 0x00: Load(word, word)/
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x00: Load
    </funcdef><paramdef>
word ResType, word ResNr</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member><type>
(word)
    </type>
<parameter/ResType/: The resource type number | 0x80 (as in the patch files)
    </member><member><type>
(word)
    </type>
<parameter/ResNr/: The resource number
    </member></simplelist></para><para>
    Returns: <type>
(&amp;FarPtr)
    </type>:
A <Type/HeapPtr/ pointing to an actual pointer on the heap.
    </para><para>
Loads a resource. The returned HeapPtr points to a special point on the heap
where a pointer (32 bits) to the memory location of the specified resource
is located. If the resource type equals sci_memory, the resource number is
interpreted as a memory size instead; the specified number of bytes is allocated
dynamically, and a handle returned.
    </para>
  </sect3>



  <sect3>
<Title/Kernel function 0x01: UnLoad(word, word)/
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x01: UnLoad
    </funcdef><paramdef>
word ResType, word ResNr</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member><type>
(word)
    </type>
<parameter/ResType/: The resource type number | 0x80
    </member><member><type>
(word)
    </type>
<parameter/ResNr/: The resource number
    </member></simplelist></para><para>
    Returns: <type>
(void)
    </type>
    </para><para>
This function unloads a resource identified by its ResType and ResNr, NOT by the HeapPtr
it has been loaded to, except for sci_memory resources, where the parameters are the
memory resource type and the handle.
    </para>
  </sect3>




  <sect3>
<Title/Kernel function 0x02:ScriptID(word, word)/
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x02: ScriptID
    </funcdef><paramdef>
word ScriptNr, word DispatchNr</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member><type>
(word)
    </type>
<parameter/ScriptNr/: Number of the script to reference
    </member><member><type>
(word)
    </type>
<parameter/DispatchNr/: Number of the Dispatch entry inside the script to reference
    </member></simplelist></para><para>
    Returns: <type>
(HeapPtr)
    </type>:
The address pointed to by the specified element of the dispatch/exports table (script block
type #7)
    </para><para>
This function returns the address pointed to by an element of a script's dispatch table.
    </para>
  </sect3>




  <sect3>
<Title/Kernel function 0x03: DisposeScript(word ScriptNumber)/
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x03: DisposeScript
    </funcdef><paramdef>
word ScriptNumber</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member><type>
(word)
    </type>
<parameter/ScriptNumber/
    </member></simplelist></para><para>
    Returns: <type>
(void)
    </type>
    </para><para>
Disposes a script. Unloads it, removes its entries from the class table, and frees the
associated heap memory.
    </para>
  </sect3>


<sect3><Title/Kernel function 0x04: Clone(HeapPtr)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x04:Clone
    </funcdef><paramdef>
HeapPtr object</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member><type>
(HeapPtr)
    </type>
<parameter/object/: The object to clone
    </member></simplelist></para><para>
    Returns: <type>
(HeapPtr)
    </type>
The address of the clone
    </para><para>
This function clones a Class or Object by copying it as a whole and mofifying the -info-
selector so that it contains 1. Objects with -info- set to 0x8000 (Classes) are stripped of
their selector name area, and both Objects and Classes are stripped of the function selector
area.
    </para>
</sect3>



<sect3><Title/Kernel function 0x05: DisposeClone(HeapPtr)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x05: DisposeClone
    </funcdef><paramdef>
HeapPtr clone</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member><type>
(HeapPtr)
    </type>
<parameter/clone/: The clone to dispose
    </member></simplelist></para><para>
    Returns: <type>
(void)
    </type>
    </para><para>
Frees all memory associated with a cloned object (as produced by Clone()).
    </para>
</sect3>


<sect3><Title/Kernel function 0x06: IsObject(HeapPtr)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x06: IsObject
    </funcdef><paramdef>
HeapPtr suspected_object</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member><type>
(HeapPtr)
    </type>
<parameter/suspected_object/: The address of something that is suspected to be an object.
    </member></simplelist></para><para>
    Returns: <type>
(int)
    </type>
1 if there is an object at the specified address, 0 if not.
    </para><para>
This function checks whether the supplied heap pointer is valid and returns 0 if not, then
proceeds to testing whether an object is at the indexed heap position. If it is, 1 is returned,
0 otherwise.
    </para>
</sect3>


<sect3><Title/Kernel function 0x07: RespondsTo(?)/<para></para>
</sect3>

  <sect3 ID="KDrawPic">
<Title/Kernel function 0x08: DrawPic(word[, word, word, word])/
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x08: DrawPic
    </funcdef><paramdef>
word PicNr[, word Animation, word Flags, word DefaultPalette]</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member><type>
(word)
    </type>
<parameter/PicNr/: The resource number of the picture to draw
    </member><member><type>
(word)
    </type>
<parameter/Animation/: One of the following animation modes:<msgtext>
   <simplelist>
<member/ -1: Display instantly/
<member/  0: horizontally open from center/
<member/  1: vertically open from center/
<member/  2: open from right/
<member/  3: open from left/
<member/  4: open from bottom/
<member/  5: open from top/
<member/  6: open from edges to center/
<member/  7: open from center to edges/
<member/  8: open random checkboard/
<member/  9: horizontally close to center, reopen from center/
<member/ 10: vertically close to center, reopen from center/
<member/ 11: close to right, reopen from right/
<member/ 12: close to left,  reopen from left/
<member/ 13: close to bottom, reopen from bottom/
<member/ 14: close to top, reopen from top/
<member/ 15: close from center to edges, reopen from edges to center/
<member/ 16: close from edges to center, reopen from center to edges/
<member/ 17: close random checkboard, reopen/
   </simplelist></msgtext>
  The animation is executed when kAnimate() (see <XREF LINKEND="KAnimate">) is invoked.
  If not specified, it is assumed to be the same animation as last time.

    </member><member><type>
(word)
    </type>
<parameter/Flags/:<msgtext>
     <simplelist>
        <member><type/Bit 0/: Clear screen before drawing</member>
        <member><type/Bit 1-f/: unknown, probably unused</member>
     </simplelist></msgtext>If not specified, it defaults to 1.<msgtext>
<note><para/Some interpreter versions older than 0.000.502 interpret this
parameter inversely, and have 0 as a default./
</note></msgtext>
    </member><member><type>
(word)
    </type>
<parameter/DefaultPalette/: The default palette number to use for drawing
    </member></simplelist></para><para>
    Returns: <type>
(void)
    </type>
    </para><para>
The second parameter does not appear to affect anything. In QfG1, it appears
to be set to 0x64 constantly.
DefaultPalette is used to differentiate between day and night in QfG1. Palette
1 is used for "night" pictures, Palette 0 for "day" pictures there.
The picture is drawn to the background image (which is used for restauration of
everything with the exception of the mouse pointer). To bring it to the
foreground, Animate() must be used.
    </para>
  </sect3>

  <sect3>
<Title/Kernel function 0x09: Show()/
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x09: Show
    </funcdef><paramdef></paramdef></funcprototype></funcsynopsis><para>
    Returns: <type>
(void)
    </type>
    </para><para>
Sets the PicNotValid flag to 2.
    </para>
  </sect3>


  <sect3>
<Title/Kernel function 0x0a: PicNotValid([word])/
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x0a: PicNotValid
    </funcdef><paramdef>
[(word) NewPicNotValid]</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member>[<type>
(word)
    </type>
<parameter/NewPicNotValid/]: The new value of the "PicNotValid" flag.
    </member></simplelist></para><para>
    Returns: <type>
(word)
    </type>:
The previous value of the "PicNotValid" flag
    </para><para>
This sets the PicNotValid flag that determines whether or not the current
background picture should be considered "valid" by the other kernel functions.
    </para>
  </sect3>


  <sect3 ID="KAnimate">
<Title/Kernel function 0x0b: Animate([DblList], [word])/
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x0b: Animate
    </funcdef><paramdef>
[DblList ViewList], [word cycle]</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member>[<type>
(DblList)
    </type>
<parameter/ViewList/]: List of views that are to be drawn on top of the background picture
    </member><member><type>
(word)
    </type>
&lt;unknown&gt;
    </member></simplelist></para><para>
    Returns: <type>
(void)
    </type>
    </para><para>
This function draws a background picture plus some views to the foreground.
If the background picture had not been drawn previously, it is animated with
the animation style set during kDrawPic (see <XREF LINKEND="KDrawPic">).
Drawing the views is a rather complex issue. Refer to <XREF LINKEND="LarsAnim">
for its description.
    </para>
  </sect3>




  <sect3>
<Title/Kernel function 0x0c: SetNowSeen(DblList)/
    <funcsynopsis><funcprototype><funcdef>
?? kfunct 0x0c: SetNowSeen
    </funcdef><paramdef>
DblList ViewList</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member><type>
(DblList)
    </type>
<parameter/ViewList/: List of affected views
    </member></simplelist></para><para>
    Returns: <type>
(void)
    </type>
    </para><para>
    </para>
  </sect3>

<sect3><Title/Kernel function 0x0d: NumLoops(HeapPtr)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x0d: NumLoops
    </funcdef><paramdef>
HeapPtr object</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member><type>
(HeapPtr)
    </type>
<parameter/object/: The object which the view selector should be taken from
    </member></simplelist></para><para>
    Returns: <type>
(word)
    </type>
The number of loops in the view
    </para><para>
This function looks up the view selector in the specified object, loads the
view resource associated with it, and checks for the number of animation loops
in the view.
    </para>
</sect3>

<sect3><Title/Kernel function 0x0e: NumCels(HeapPtr)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x0e: NumCels
    </funcdef><paramdef>
HeapPtr object</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member><type>
HeapPtr
    </type>
<parameter/object/: The object which the selectors should be taken from
    </member></simplelist></para><para>
    Returns: <type>
(word)
    </type>
The number of cels in the loop
    </para><para>
This function looks up one specific loop in a specific view (both are taken
from selectors with the same name from the object pointed to by the parameter)
and returns the number of cels (animation frames) in it.
    </para>
</sect3>

<sect3><Title/Kernel function 0x0f: CelWide(word view, word loop, word cel)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x0f: CelWide
    </funcdef><paramdef>
word view, word loop, word cel</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member><type>
(HeapPtr)
    </type>
<parameter/view/: The view we're searching in
<parameter/loop/: The loop the cel is contained in
<parameter/cel/: The cel we're interested in
    </member></simplelist></para><para>
    Returns: <type>
(word)
    </type>
The width of the cel identified by the tuple (view, loop, cel).
    </para><para>
    </para>
</sect3>

<sect3><Title/Kernel function 0x0f: CelWide(word view, word loop, word cel)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x10: CelHigh
    </funcdef><paramdef>
word view, word loop, word cel</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member><type>
(HeapPtr)
    </type>
<parameter/view/: The view we're searching in
<parameter/loop/: The loop the cel is contained in
<parameter/cel/: The cel we're interested in
    </member></simplelist></para><para>
    Returns: <type>
(word)
    </type>
The height of the cel identified by the tuple (view, loop, cel).
    </para><para>
    </para>
</sect3>

<sect3><Title/Kernel function 0x11: DrawCel(word, word, word, Point, word)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x11: DrawCel
		</funcdef><paramdef>word view, word loop, word cel, Point pos, word priority</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(word)/ view: Number of the view resource to display</member>
                       <member><type/(word)/ loop: Number of the loop in the view resource to display</member>
                       <member><type/(word)/ cel: Number of the cel inside the loop to display</member>
                       <member><type/(Point)/ pos: Position the cel should be drawn to</member>
                       <member><type/(word)/ priority: Priority to draw the cel with</member>
                   </simplelist></para>
		<para>
			Returns: <type>(void)</type>
		</para><para>
			Explicitly draws a cel, specified by the complete tuple (view, loop, cel), to
			a specified position.
			Invalid loop/cel values are assumed to be 0.
		</para>
	</sect3>

<sect3><Title/Kernel function 0x12: AddToPic(DblList)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x12: AddToPic
    </funcdef><paramdef>
DblList picviews</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member><type>
(DblList)
    </type>
<parameter/picviews/: A doubly linked list of PicViews, i.e. objects that are drawn statically onto
the background picture
    </member></simplelist></para><para>
    Returns: <type>
(void)
    </type>
    </para><para>
This function stores the list of PicViews for later use by the Animate() syscall.
See <XREF LINKEND="KAnimate"> for more details.
    </para>
</sect3>

<sect3 ID="KNewWindow"><Title/Kernel function 0x13: NewWindow(Rect, HeapPtr, word, word, word, word)/
    <funcsynopsis><funcprototype><funcdef>
kfunct NewWindow
    </funcdef><paramdef>
Rect Boundaries, HeapPtr Title, word Flags, word Priority, word FGColor, word BGColor</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member><type>
(Rect)
    </type>
<parameter/Boundaries/: The bounding rectangle of the window
    </member><member><type>
(HeapPtr)
    </type>
<parameter/Title/: A pointer to the window title
    </member><member><type>
(word)
    </type>
<parameter/Flags/:<msgtext><simplelist>
<member/bit 0 - transparency/
<member/bit 1 - window does not have a frame/
<member/bit 2 - the window has a title (starting 10 pixels above the minimum y position specified as the first element of <parameter/Boundaries/)/
<member/bit 3-6 - unused/
<member/bit 7 - don't draw anything/
</simplelist>
</msgtext>
    </member><member><type>
(word)
    </type>
<parameter/Priority/: The priority at which the window should be drawn, or -1 to force on-top drawing
    </member><member><type>
(word)
    </type>
<parameter/FGColor/: The foreground color for the window
    </member><member><type>
(word)
    </type>
<parameter/BGColor/: The background color
    </member></simplelist></para><para>
    Returns: <type>
(HeapPtr)
    </type>:
The position of the window structure on the heap
    </para><para>
This function creates a window (see also <XREF LINKEND="LarsWindows">), sets
this window as the active port, draws the window (if neccessary), and returns
with the window's heap address.
    </para>
  </sect3>



  <sect3 ID="KGetPort">
<Title/Kernel function 0x14: GetPort()/
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x14: GetPort
    </funcdef><paramdef></paramdef></funcprototype></funcsynopsis><para>
    Returns: <type>
(HeapPtr)
    </type>:
A pointer to a record with the internal representation of the currently active port.
    </para><para>
Returns a heap pointer to a port structure.
    </para>
  </sect3>



  <sect3 ID="KSetPort">
<Title/Kernel function 0x15: SetPort()/
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x15: SetPort
    </funcdef><paramdef>
HeapPtr NewPort</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member><type>
(HeapPtr)
    </type>
<parameter/NewPort/: The new port to set
    </member></simplelist></para><para>
    Returns: <type>
(void)
    </type>
    </para><para>
This selects the new port which many kernel functions will draw to.
</para><para>
If 0 is passed, the window manager port is selected.
The picture window is not accessible using this call. Only other kernel
calls like KDrawPic may activate the picture window - and they always
save the old port and restore it before they return.
    </para>
  </sect3>



<sect3 ID="KDisposeWindow">
<Title/Kernel function 0x16: DisposeWindow(HeapPtr Window)/
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x16: DisposeWindow
    </funcdef><paramdef>
HeapPtr Window</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member><type>
(HeapPtr)
    </type>
<parameter/Window/: The heap address of the window to destroy
    </member></simplelist></para><para>
    Returns: <type>
(void)
    </type>
    </para><para>
Destroys a window and frees the associated heap structure.
    </para>
  </sect3>



<sect3 ID="KDrawControl"><Title/Kernel function 0x17: DrawControl(HeapPtr)/
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x17: DrawControl
    </funcdef><paramdef>
HeapPtr Control</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member><type>
(HeapPtr)
    </type>
<parameter/Control/: The heap address of the Control to draw
    </member></simplelist></para><para>
    Returns: <type>
(void)
    </type>
    </para><para>
This function draws a Control (see <XREF LINKEND="LarsWindows"> for details).
Please note that the correct port must be selected beforehand.
    </para>
  </sect3>



<sect3 ID="KHiliteControl"><Title/Kernel function 0x18: HiliteControl(HeapPtr)/
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x18: HiliteControl
    </funcdef><paramdef>
HeapPtr Control</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member><type>
(HeapPtr)
    </type>
<parameter/Control/: The control to highlight
    </member></simplelist></para><para>
    Returns: <type>
(void)
    </type>
    </para><para>
This function is used to highlight a control by drawing it with an inverted color
scheme. It requires the correct port to be set beforehand.
See <XREF LINKEND="LarsWindows"> for details on the windowing/Control system.
    </para>
  </sect3>



<sect3 ID="KEditControl"><Title/Kernel function 0x19: EditControl(HeapPtr)/
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x19: EditControl
    </funcdef><paramdef>
HeapPtr Control</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member><type>
(HeapPtr)
    </type>
<parameter/Control/: A heap pointer to the Control to edit
    </member></simplelist></para><para>
    Returns: <type>
(void)
    </type>
    </para><para>
This function will give control to the kernel and allow the editing of a type
3 (Edit window) Control (see <XREF LINKEND="LarsWindows"> for a description
of the control system). If it is called to edit a Control which is not of type
3, it returns without error. Please note that the correct port (usually the
window which the Control was drawn in) must be selected beforehand.
    </para>
  </sect3>



<sect3><Title/Kernel function 0x1a: TextSize(HeapPtr, HeapPtr, word[, word])/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x1a: TextSize
    </funcdef><paramdef>
HeapPtr dest, HeapPtr src, word font[, word maxwidth]</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
    <member><type>
(HeapPtr)</type>
<parameter/dest/: The destination to write the rectangle to
    </member>
    <member><type>
(HeapPtr)</type>
<parameter/src/: A pointer to the string to analyze
    </member>
    <member><type>
(word)</type>
<parameter/font/: The number of the font resource to use for this check
    </member>
    <member><type>
(word)</type>
<parameter/maxwidth/: The maximum width to allow for the text (defaults to 192)
    </member>
    </simplelist></para><para>
    Returns: <type>
(void)
    </type>
    </para><para>
This function calculates the width and height the specified text will require to
be displayed with the specified font and the specified maximum width. The result will
be written to the (you guessed it) specified destination on the heap. The result is a
rectangle structure: The first four bytes equal to zero, the next word is the height,
and the last word is the width.
    </para>
</sect3>



<sect3><Title/Kernel function 0x1b: Display(String, word...)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x1b: Display
    </funcdef><paramdef>
String text, word commands...</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member><type>
    </type>
(String)
<parameter/text/: The text to work with
</member><member><type/(word)/
<parameter/commands.../: A sequence of commands with parameters:
<msgtext><simplelist>
<member/100: 2 params, (X,Y) coord of where to write on the port./
<member/101: 1 param, -1, 0 or 1 (align right (-1), left (0) or center (1)/
<member/102: 1 param, set the text color./
<member/103: 1 param, set the background color (-1 to draw text with transparent
background)/
<member/104: 1 param, set the "gray text" flag (1 to draw disabled items)/
<member/105: 1 param, (resource number) set the font/
<member/106: 1 param, set the width of the text (the text wraps to fit in that width)/
<member/107: no param, set the "save under" flag, to save a copy of the pixels before
writing the text (the handle to the saved pixels is returned)/
<member/108: 1 param, (handle to stored pixels) restore under.  With this command, the
text and all other parameters are ignored./
</simplelist></msgtext>
</member></simplelist></para><para>
    Returns: <type>
(void) or (&amp;FarPtr)
    </type>(see above)
    </para><para>
This function executes the specified commands, then draws the supplied text to the active
port (unless command 108 was executed).
    </para>
</sect3>



<sect3 ID="KGetEvent"><Title/Kernel function 0x1c: GetEvent(word, HeapPtr)/
    <funcsynopsis><funcprototype><funcdef>
       kfunct 0x1c: GetEvent
    </funcdef><paramdef>
       word Flags, HeapPtr Event</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member>
        <type/(word)/
           <parameter/Flags/: A bitfield:
             <msgtext><simplelist>
               <member/bit 0 - 14: Bit mask for the events to be returned./
               <member/bit 15: Disable joystick polling/
             </simplelist></msgtext>
        </member><member>
         <type/(HeapPtr)/
           <parameter/Event/: An Object on the stack which the results are written to.
        </member></simplelist>
     </para><para>
        Returns: <type/(word)/: <returnvalue/0/ if a null event was created,
                 <returnvalue/1/ otherwise.
        </para><para>     
          This function fills an Event object with data from the event queue. The results
          are written to the "type", "message" and "modifiers" selectors.
          See <XREF LINKEND="LarsEvents"> for details.
        </para>
</sect3>


<sect3 ID="KGlobalToLocal"><Title/Kernel function 0x1d: GlobalToLocal(HeapPtr Event)/
   <funcsynopsis><funcprototype><funcdef>
       kfunct 0x1d: GlobalToLocal
     </funcdef><paramdef>
         HeapPtr Event</paramdef>
   </funcprototype></funcsynopsis><para><simplelist><member>
      <type/(HeapPtr)/
         <parameter/Event/: pointer to the Event object to convert
       </member>
   </simplelist></para>
 <para>
   Returns: <type/(void)/
 </para><para>
    This function converts a screen-relative event to a port-relative one, using the
    currently active port.
 </para>
</sect3>


<sect3 ID="KLocalToGlobal"><Title/Kernel function 0x1e: LocalToGlobal(HeapPtr Event)/
   <funcsynopsis><funcprototype><funcdef>
       kfunct 0x1e: LocalToGlobal
     </funcdef><paramdef>
         HeapPtr Event</paramdef>
   </funcprototype></funcsynopsis><para><simplelist><member>
      <type/(HeapPtr)/
         <parameter/Event/: pointer to the Event object to convert
       </member>
   </simplelist></para>
 <para>
   Returns: <type/(void)/
 </para><para>
    This function converts a port-relative event to a screen-relative one, using the
    currently active port.
 </para>
</sect3>



<sect3 ID="KMapKeyToDir"><Title/Kernel function 0x1f: MapKeyToDir(HeapPtr Event)/
    <funcsynopsis><funcprototype><funcdef>
       kfunct 0x1f: MapKeyToDir
      </funcdef><paramdef>
        HeapPtr Event</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member>
       <type/(HeapPtr)/
          <parameter/Event/: pointer to the Event object to convert
       </member>
     </simplelist></para>
   <para>
     Returns: <type/(HeapPtr)/: A pointer to the converted object
   </para><para>
        This function converts a keyboard event to a movement event, if possible.
        Otherwise, the function returns without error.
        See <XREF LINKEND="LarsEvents"> for details.
   </para>
</sect3>




<sect3><Title/Kernel function 0x20: DrawMenuBar(word)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x20: DrawMenuBar
    </funcdef><paramdef>
word mode</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member><type>
(word)
    </type>
<parameter/mode/: 1 to draw, 0 to clear
    </member></simplelist></para><para>
    Returns: <type>
(void)
    </type>
    </para><para>
Either draws or clears (overdraws with black) the menu bar.
    </para>
</sect3>


	<sect3>
	<Title/Kernel function 0x21: MenuSelect(HeapPtr[, word])/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x21: MenuSelect
		</funcdef><paramdef>HeapPtr event[, word flag]</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(HeapPtr)/ event: The event to interpret</member>
                       <member><type/(word)/ flag: (unknown)</member>
                   </simplelist></para>
		<para>
			Returns: <type>(word)</type>
                        The menu index of a selected option, -1 if no menu option was selected,
                        or 0 if the event passed through all of the menu system's filters.
		</para><para>
                   This function interprets the event passed to it by running several checks.
                   First, it tries to determine whether the menu system was activated by pressing
                   the ESC key or clicking on the menu bar. In this case, the interpreter takes over
                   and waits for the player to select a menu option. It then returns the menu option
                   selected (menu number, starting at 1, in the upper 8 bits, item number, starting
                   at 1 as well, in the lower part) or -1 if no active menu item was selected.
                   In any case, the event is claimed.
                   If the menu system was not activated by the event, it checks the event against
                   the key commands or Said Blocks associated with each menu entry. If there is a match,
                   the menu coordinate tuple is returned and the event is claimed, otherwise, 0 is returned.
		</para>
	</sect3>



<sect3><Title/Kernel function 0x22: AddMenu(HeapPtr, HeapPtr)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x22: AddMenu
    </funcdef><paramdef>
HeapPtr title, HeapPtr content</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
    <member><type>
(HeapPtr)
    </type>
<parameter/title/: The menu title
    </member>
    <member><type>
(HeapPtr)
    </type>
<parameter/content/: The menu options
    </member>
    </simplelist></para><para>
    Returns: <type>
(void)
    </type>
    </para><para>
This function adds a menu to the menu bar. The menu title is passed in the first parameter,
the second parameter contains a heap pointer to the menu entries. They are contained in one
single string; the following special characters/character combinations are used:
<simplelist>
  <member/'`': Right justify the following text/
  <member/':': Menu item separator/
  <member/"--!": Seperation line: This menu item is just a separator/
  <member/'#': Function key. This is replaced by an F for displaying/
  <member/'^': Control key. This is replaced by \001 (CTRL) for displaying/
</simplelist>
    </para>
</sect3>



<sect3><Title/Kernel function 0x23: DrawStatus(HeapPtr)/
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x23: DrawStatus
    </funcdef><paramdef>
HeapPtr text</paramdef>
    </funcprototype></funcsynopsis><para><simplelist><member><type>
(HeapPtr)
    </type>
<parameter/text/: The text to draw
    </member></simplelist></para><para>
    Returns: <type>
(void)
    </type>
    </para><para>
Draws the specified text to the title bar
    </para>
</sect3>



<sect3><Title/Kernel function 0x24: Parse(HeapPtr, HeapPtr)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x24: Parse
    </funcdef><paramdef>
HeapPtr event, HeapPtr input</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
    <member><type>
(HeapPtr)
    </type>
<parameter/event/: The event to generate
    </member>
    <member><type>
(HeapPtr)
    </type>
<parameter/input/: The input line to parse
    </member>
    </simplelist></para><para>
    Returns: <type>
(word)
    </type>
1 on success, 0 otherwise
    </para><para>
This function parses the input line and generates a parse event (type 0x80).
See <XREF LINKEND="LarsDMParser"> and <XREF LINKEND="LarsEvents"> for details.
    </para>
</sect3>



<sect3><Title/Kernel function 0x25: Said(HeapPtr)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x:25: Said
    </funcdef><paramdef>
HeapPtr said_block</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(HeapPtr)</type>
<parameter/said_block/: Pointer to a Said block
  </member>
    </simplelist></para><para>
    Returns: <type>
(word)
    </type>
1 if the line last parsed meets the criteria of the supplied said_block,
0 otherwise.
    </para><para>
This function is only invoked after Parse() was called, and works on output
generated by this function.
See <XREF LINKEND="LarsDMParser"> and <XREF LINKEND="LarsEvents"> for details.
    </para>
</sect3>

<sect3><Title/Kernel function 0x26: SetSynonyms(DblList)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x26: SetSynonyms 
		</funcdef><paramdef>HeapPtr list</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(DblList)/ list: List of script objects to examine</member>
                   </simplelist></para>
		<para>
			Returns: <type>(void)</type>
		</para><para>
			This function sets the synonyms used by the parser. Synonyms are used to
			replace specified word groups with other word groups. The list contains
			a collection of script objects; all synonyms defined by the corresponding
			script (which can be identified by evaluating the 'number' selector of the
			script object) are added to the list of active synonyms.
		</para>
	</sect3>

<sect3><Title/Kernel function 0x27: HaveMouse() /<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x27: HaveMouse
    </funcdef><paramdef>
</paramdef>
    </funcprototype></funcsynopsis><para>
    </para><para>
    Returns: <type>
(word)
    </type>
1 if a mouse is available, 0 if not.
    </para><para>
This function simply returns a flag containing the availability of a pointing device.
    </para>
</sect3>



<sect3><Title/Kernel function 0x28: SetCursor(word, word[, Point])/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x28: SetCursor
    </funcdef><paramdef>
word resource, word visible[, Point coordinates]</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(word)</type>
<parameter/resource/: The cursor resource to use for drawing the mouse pointer
  </member>
  <member><type>
(word)</type>
<parameter/visible/: 1 if the mouse pointer should be visible, 0 if not
  </member>
  <member><type>
(Point)</type>
<parameter/coordinates/: The coordinates (relative to the wm-port) to move the mouse pointer to
  </member>
    </simplelist></para><para>
    Returns: <type>
(void)
    </type>
    </para><para>
This function can change the appearance and position of the mouse pointer. If no position is provided,
the position remains unchanged.
    </para>
</sect3>

<sect3><Title/Kernel function 0x29: FOpen(String, word)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x29: FOpen 
		</funcdef><paramdef>String fname, word mode</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(String)/ fname: The file name</member>
                       <member><type/(word)/ mode: The mode to open the file with</member>
                   </simplelist></para>
		<para>
			Returns: <type>(word) a file handle on success, 0 on error</type>
		</para><para>
			Tries to open or create a file in the CWD with the specified file name.
			The following modes are valid:
			<simplelist>
				<member/0: open or fail: Try to open file, abort if not possible/
				<member/1: open or create: Try to open file, create it if it doesn't exist/
				<member/2: create: Create the file, destroying any content it might have had/
			</simplelist>
		</para>
	</sect3>

<sect3><Title/Kernel function 0x2a: FPuts(word, String)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x2a: FPuts
		</funcdef><paramdef>word filehandle, String data</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(word)/ filehandle: Handle of the file to write to</member>
                       <member><type/(String)/ data: The string to write to the file</member>
                   </simplelist></para>
		<para>
			Returns: <type>(void)</type>
		</para><para>
			Writes a zero-terminated string to a file
		</para>
	</sect3>

<sect3><Title/Kernel function 0x2b: FGets(String, word, word)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x2b: FGets
		</funcdef><paramdef>String dest, word maxsize, word handle</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(String)/ dest: Pointer to the destination buffer</member>
                       <member><type/(word)/ maxsize: Maximum number of bytes to read</member>
                       <member><type/(word)/ handle: Handle of the file to read from</member>
                   </simplelist></para>
		<para>
			Returns: <type>(void)</type>
		</para><para>
		</para>
	</sect3>

<sect3><Title/Kernel function 0x2c: FClose(word)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x2c: FClose
		</funcdef><paramdef>word filehandle</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(word)/ filehandle: Handle of the file to close</member>
                   </simplelist></para>
		<para>
			Returns: <type>(void)</type>
		</para><para>
			Closes a previously opened file.
		</para>
	</sect3>

	<sect3>
	<Title/Kernel function 0x2d: SaveGame(String, word, String, String)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x2d: SaveGame
		</funcdef><paramdef>String game_id, word save_nr, String save_description, String version</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(String)/ game_id: The game object's ID string (e.g. "SQ3")</member>
                       <member><type/(word)/ save_nr: "slot" the game is to be saved to</member>
                       <member><type/(String)/ save_description: String description of the game</member>
                       <member><type/(String)/ version: Stringified game version number</member>
                   </simplelist></para>
		<para>
			Returns: <type>(word)</type>
			1 on success, 0 if an error occured while saving
		</para><para>
			This function saves the game state (heap, windows, call stack, view list,
			sound state etc.) to the savegame with the numeric id <parameter/save_nr/
			and the description <parameter/save_description/. <parameter/game_id/ and
			<parameter/version/ are stored alongside, for verification when the game state
			is restored.
		</para>
	</sect3>

	<sect3>
	<Title/Kernel function 0x2e: RestoreGame(String, word, String)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x2e: RestoreGame
		</funcdef><paramdef>String game_id, word save_nr, String version</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(String)/ game_id: The game object's ID string</member>
                       <member><type/(word)/ save_nr: Number of the save game to restore</member>
                       <member><type/(String)/ version: The game object's version number</member>
                   </simplelist></para>
		<para>
			Returns: <type>(void)</type>
		</para><para>
			This function restores a previously saved game. It should only
			return if restoring failed.
		</para>
	</sect3>

	<sect3>
	<Title/Kernel function 0x2f: RestartGame()/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x2f: RestartGame
		</funcdef><paramdef></paramdef></funcprototype></funcsynopsis>
                <para>
			Returns: <type>never</type>
		</para><para>
			If this function is invoked, the following things happen:
			<simplelist>
				<member/The restarting flag is set/
				<member/The menu bar structure is destroyed/
				<member/All sounds are stopped/
				<member/All scripts are removed from the script table/
				<member/The heap status is reset, but the heap is not cleared/
			</simplelist>
			After this is done, the engine restarts at a certain point (see 
			<xref linkend="LSExecLoop"/>), re-initializes the stack, and executes the
			replay method of the game object.
		</para>
	</sect3>

<sect3><Title/Kernel function 0x30: GameIsRestarting()/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x30: GameIsRestarting
    </funcdef><paramdef>
</paramdef>
    </funcprototype></funcsynopsis><para>
    </para><para>
    Returns: <type>
(word)
    </type>
1 if the game is restarting, 0 if not
    </para><para>
    </para>
</sect3>


	<sect3>
	<Title/Kernel function 0x31: DoSound(word, ...])/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x31: DoSound
		</funcdef><paramdef>word action, ...</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(word)/ action: The sound command subfunction number</member>
                   </simplelist></para>
		<para>
			Returns: (see below)
		</para><para>
			'action' may be one of the following:
			<simplelist>
				<member/0x0: INIT/
				<member/0x1: PLAY/
				<member/0x2: NOP/
				<member/0x3: DISPOSE/
				<member/0x4: SET_SOUND/
				<member/0x5: STOP/
				<member/0x6: SUSPEND/
				<member/0x7: RESUME/
				<member/0x8: VOLUME/
				<member/0x9: UPDATE/
				<member/0xa: FADE/
				<member/0xb: CHECK_DRIVER/
				<member/0xc: ALL_STOP/
			</simplelist>
			See individual descriptions below for more information.
		</para>
	</sect3>

	<sect3>
	<Title/Kernel function 0x31: DoSound(INIT, Object)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x31: DoSound
		</funcdef><paramdef>word 0, Object sound_obj</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(word)/ 0: subfunction identifier</member>
                       <member><type/(Object)/ sound_obj: The sound object affected</member>
                   </simplelist></para>
		<para>
			Returns: <type>(void)</type>
		</para><para>
			Initializes the specified sound object. This will set the 'status' selector
			of the object to 1 ('initialized'), and load the sound indicated by the
			'number' selector into the sound driver.
		</para>
	</sect3>

	<sect3>
	<Title/Kernel function 0x31: DoSound(PLAY, Object)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x31: DoSound
		</funcdef><paramdef>word 1, Object sound_obj</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(word)/ 1: The subfunction identifier</member>
                       <member><type/(Object)/ sound_obj: The sound object affected</member>
                   </simplelist></para>
		<para>
			Returns: <type>(void)</type>
		</para><para>
			Starts to play the song represented by the specified sound object. This will
			also set the 'status' selector of the object to 2 ('playing').
		</para>
	</sect3>

	<sect3>
	<Title/Kernel function 0x31: DoSound(NOP)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x31: DoSound
		</funcdef><paramdef>word 2</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(word)/ 2: The sound command subfunction number</member>
                   </simplelist></para>
		<para>
			Returns: <type>(void)</type>
		</para><para>
			No action appears to be associated with this subfunction call.
		</para>
	</sect3>

	<sect3>
	<Title/Kernel function 0x31: DoSound(DISPOSE, Object)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x31: DoSound
		</funcdef><paramdef>word 3, Object sound_obj</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(word)/ 3: The sound command subfunction number</member>
                       <member><type/(Object)/ sound_obj: The sound object affected</member>
                   </simplelist></para>
		<para>
			Returns: <type>(void)</type>
		</para><para>
			Removes the song indexed by a sound object from the sound server song list
		</para>
	</sect3>

	<sect3>
	<Title/Kernel function 0x31: DoSound(SET_SOUND, word)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x31: DoSound
		</funcdef><paramdef>word 4, word state</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(word)/ 4: The sound command subfunction number</member>
                       <member><type/(word)/ state: 1 if sound should be active, 0 if it should be turned off</member>
                   </simplelist></para>
		<para>
			Returns: <type>(word) 1 if currently active, 0 if currently muted.</type>
		</para><para>
			This function completely mutes or un-mutes the sound subsystem.  If called with no parameters, it returns the current status.
		</para>
	</sect3>

	<sect3>
	<Title/Kernel function 0x31: DoSound(STOP, Object)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x31: DoSound
		</funcdef><paramdef>word 5, Object sound_obj</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(word)/ 5: The sound command subfunction number</member>
                       <member><type/(Object)/ sound_obj: The sound object affected</member>
                   </simplelist></para>
		<para>
			Returns: <type>(void)</type>
		</para><para>
			Stops playing the song represented by the specified sound object. This will
			set the object's 'state' selector to 0 ('stopped').
		</para>
	</sect3>

	<sect3>
	<Title/Kernel function 0x31: DoSound(SUSPEND, Object)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x31: DoSound
		</funcdef><paramdef>word 6, Object sound_obj</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(word)/ 6: The sound command subfunction number</member>
                       <member><type/(Object)/ sound_obj: The sound object affected</member>
                   </simplelist></para>
		<para>
			Returns: <type>(void)</type>
		</para><para>
			Suspends the song associated with the specified sound object. Its state is buffered,
			so that it can be resumed later on. The sound object's 'state' selector is set to
			3 ('suspended').
		</para>
	</sect3>

	<sect3>
	<Title/Kernel function 0x31: DoSound(RESUME, Object)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x31: DoSound
		</funcdef><paramdef>word 7, Object sound_obj</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(word)/ 7: The sound command subfunction number</member>
                       <member><type/(Object)/ sound_obj: The sound object affected</member>
                   </simplelist></para>
		<para>
			Returns: <type>(void)</type>
		</para><para>
			Resumes a previously suspended song. The 'state' selector is set to 2 ('playing').
		</para>
	</sect3>

	<sect3>
	<Title/Kernel function 0x31: DoSound(VOLUME[, word])/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x31: DoSound
		</funcdef><paramdef>word 8[, word volume]</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(word)/ 8: The sound command subfunction number</member>
                       <member><type/(word)/ volume: An optional volume parameter</member>
                   </simplelist></para>
		<para>
			Returns: <type>(word) The currently set sound volume (0 to 0xf)</type>
		</para><para>
			This subfunction retrieves and returns the current sound volume. If a second
			parameter is supplied the volume will be set to the value of this parameter.
		</para>
	</sect3>

	<sect3>
	<Title/Kernel function 0x31: DoSound(UPDATE, Object])/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x31: DoSound
		</funcdef><paramdef>word 9, Object sound_obj</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(word)/ 9: The sound command subfunction number</member>
                       <member><type/(Object)/ sound_obj: The sound object affected</member>
                   </simplelist></para>
		<para>
			Returns: <type>(void)</type>
		</para><para>
			Notifies the sound server that a sound object was modified. The song priority
			and number of loops (stored in the 'priority' and 'loop' selectors, respectively)
			are re-evaulated by the sound system.
		</para>
	</sect3>

	<sect3>
	<Title/Kernel function 0x31: DoSound(FADE, Object])/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x31: DoSound
		</funcdef><paramdef>word 0xa, Object sound_obj</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(word)/ 0xa: The sound command subfunction number</member>
                       <member><type/(Object)/ sound_obj: The sound object affected</member>
                   </simplelist></para>
		<para>
			Returns: <type>(void)</type>
		</para><para>
			Fades the specified song. Fading takes approximately two seconds. The song
			status is set to 'stopped' (0) afterwards.
		</para>
	</sect3>

	<sect3>
	<Title/Kernel function 0x31: DoSound(CHECK_DRIVER)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x31: DoSound
		</funcdef><paramdef>word 0xb</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(word)/ 0xb: The sound command subfunction number</member>
                   </simplelist></para>
		<para>
			Returns: <type>(word)</type>
			1 if the sound driver was installed successfully, 0 if not
		</para><para>
		</para>
	</sect3>

	<sect3>
	<Title/Kernel function 0x31: DoSound(ALL_STOP)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x31: DoSound
		</funcdef><paramdef>word 0xc</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(word)/ 0xc: The sound command subfunction number</member>
                   </simplelist></para>
		<para>
			Returns: <type>(void)</type>
		</para><para>
			Stops all music and sound effects.
		</para>
	</sect3>


<sect3><Title/Kernel function 0x32: NewList()/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x32: NewList
    </funcdef><paramdef>
</paramdef>
    </funcprototype></funcsynopsis><para>
    </para><para>
    Returns: <type>
(DblList)
    </type>
The address of a new node list on the heap
    </para><para>
This function allocates and initializes a node list containing no elements.
    </para>
</sect3>



<sect3><Title/Kernel function 0x33: DisposeList(DblList)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x33: DisposeList
    </funcdef><paramdef>
NodeList list</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(NodeList)</type>
<parameter/list/: The list to dispose
  </member>
    </simplelist></para><para>
    Returns: <type>
(void)
    </type>
    </para><para>
Frees all memory associated to a list
    </para>
</sect3>



<sect3><Title/Kernel function 0x34: NewNode(word, word)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x34: NewNode
    </funcdef><paramdef>
word key, word value</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(word)</type>
<parameter/key/: The node key (used for searching the list)
  </member>
  <member><type>
(word)</type>
<parameter/value/: The node value
  </member>
    </simplelist></para><para>
    Returns: <type>
(Node)
    </type>
A new node
    </para><para>
This function allocates a new node and initializes it with the key and value passed as parameters.
    </para>
</sect3>



<sect3><Title/Kernel function 0x35: FirstNode(DblList)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x35: FirstNode
    </funcdef><paramdef>
DblList list</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(DblList)</type>
<parameter/list/: The list to examine
  </member>
    </simplelist></para><para>
    Returns: <type>
(Node)
    </type>
The first node of the list, or 0 if the list is empty
    </para><para>
    </para>
</sect3>



<sect3><Title/Kernel function 0x36: LastNode(DblList)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x36: LastNode
    </funcdef><paramdef>
DblList list</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(DblList)</type>
<parameter/list/: The list to examine
  </member>
    </simplelist></para><para>
    Returns: <type>
(Node)
    </type>
The last node of the list, or 0 if the list is empty
    </para><para>
    </para>
</sect3>

	<sect3>
	<Title/Kernel function 0x37: EmptyList(DblList)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x37: EmptyList
		</funcdef><paramdef>DblList list</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(DblList)/ list: The list to check</member>
                   </simplelist></para>
		<para>
			Returns: <type>(int)</type>
                        1 if <parameter/list/ is an empty list, 0 if it isn't.
		</para><para>
		</para>
	</sect3>


<sect3><Title/Kernel function 0x38: NextNode(Node)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x38: NextNode
    </funcdef><paramdef>
Node node</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(Node)</type>
<parameter/node/: The node whose succcessor is to be found
  </member>
    </simplelist></para><para>
    Returns: <type>
(Node)
    </type>
The node following the supplied node, or 0 if none is available
    </para><para>
    </para>
</sect3>



<sect3><Title/Kernel function 0x39: PrevNode(Node)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x39: PrevNode
    </funcdef><paramdef>
Node node</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(Node)</type>
<parameter/node/: The node whose predecessor is to be determined
  </member>
    </simplelist></para><para>
    Returns: <type>
(Node)
    </type>
The supplied node's predecessor, or 0 if the node has no predecessor
    </para><para>
    </para>
</sect3>



<sect3><Title/Kernel function 0x3a: NodeValue(Node)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x3a: NodeValue
    </funcdef><paramdef>
Node node</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(Node)</type>
<parameter/node/: The node whose value is to be determined
  </member>
    </simplelist></para><para>
    Returns: <type>
(word)
    </type>
The value associated with the specified node
    </para><para>
    </para>
</sect3>

	<sect3>
	<Title/Kernel function 0x3b: AddAfter(DblList, Node, Node)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x3b: AddAfter
		</funcdef><paramdef>DblList list, Node ref_node, Node new_node</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(DblList)/ list: The list to insert into</member>
                       <member><type/(Node)/ ref_node: The node in <parameter/list/ to insert after</member>
                       <member><type/(Node)/ new_node: The node to insert</member>
                   </simplelist></para>
		<para>
			Returns: <type>(void)</type>
		</para><para>
                       This function inserts <parameter/new_node/ into <parameter/list/ as the
                       immediate successor of <parameter/ref_node/.
		</para>
	</sect3>


<sect3><Title/Kernel function 0x3c: AddToFront(DblList, Node)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x3c: AddToFront
    </funcdef><paramdef>
DblList list, Node node</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(DblList)</type>
<parameter/list/: The list the node is to be added to
  </member>
  <member><type>
(Node)</type>
<parameter/node/: The node to add
  </member>
    </simplelist></para><para>
    Returns: <type>
(void)
    </type>
    </para><para>
This function adds a node to the beginning of a doubly linked list.
    </para>
</sect3>



<sect3><Title/Kernel function 0x3d: AddToEnd(DblList, Node)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x3d: AddToEnd
    </funcdef><paramdef>
DblList list, Node node</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(DblList)</type>
<parameter/list/: The list to add the node to
  </member>
  <member><type>
(Node)</type>
<parameter/node/: The node to add to the list
  </member>
    </simplelist></para><para>
    Returns: <type>
(void)
    </type>
    </para><para>
This function adds the specified node to the end of the specified list.
    </para>
</sect3>



<sect3><Title/Kernel function 0x3e: FindKey(DblList, word)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x3e: FindKey 
    </funcdef><paramdef>
DblList list, word key</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(DblList)</type>
<parameter/list/: The list in which the key is to be sought
  </member>
  <member><type>
(word)</type>
<parameter/key/: The key to seek
  </member>
    </simplelist></para><para>
    Returns: <type>
(Node)
    </type>
The node containing the key, or 0 if no node contains it
    </para><para>
This function searches for a specific key in the nodes of a doubly linked list.
    </para>
</sect3>



<sect3><Title/Kernel function 0x3f: DeleteKey(DblList, word)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x3f:
    </funcdef><paramdef>
DblList list, word key</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(DblList)</type>
<parameter/list/: The list to examine
  </member>
  <member><type>
(word)</type>
<parameter/key/: The key to find
  </member>
    </simplelist></para><para>
    Returns: <type>
(void)
    </type>
    </para><para>
This function searches in the supplied list for the specified key and removes the
node containing it, if any can be found.
    </para>
</sect3>



<sect3><Title/Kernel function 0x40: Random(word, word)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x40: Random
    </funcdef><paramdef>
word min, word max</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(word)</type>
<parameter/min/: The minimum result
  </member>
  <member><type>
(word)</type>
<parameter/max/: The maximum result
  </member>
    </simplelist></para><para>
    Returns: <type>
(word)
    </type>
A random number between min and max (inclusive)
    </para><para>
    </para>
</sect3>



<sect3><Title/Kernel function 0x41: Abs(word)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x41: Abs
    </funcdef><paramdef>
word value</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(word)</type>
<parameter/value/: The value to absolutize
  </member>
    </simplelist></para><para>
    Returns: <type>
(word)
    </type>
The absolute value of the specified parameter
    </para><para>
This function interprets the supplied value as a signed value and returns its absolute
value.
    </para>
</sect3>



<sect3><Title/Kernel function 0x42: Sqrt(word)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x42: Sqrt
    </funcdef><paramdef>
word value</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(word)</type>
<parameter/value/: The value to draw the square root out of
  </member>
    </simplelist></para><para>
    Returns: <type>
(word)
    </type>
The square root of the supplied value
    </para><para>
    </para>
</sect3>



<sect3><Title/Kernel function 0x43: GetAngle(Point, Point)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x43: GetAngle
    </funcdef><paramdef>
Point origin, Point destination</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(Point)</type>
<parameter/origin/: The point to look from
  </member>
  <member><type>
(Point)</type>
<parameter/destination/: The point to look to
  </member>
    </simplelist></para><para>
    Returns: <type>
(word)
    </type>
A positive angle between the two points, relative to the screen coordinate axis.
    </para><para>
This function returns approximately the following value:
-(180.0/PI * atan2(destination.y - origin.y, destination.x - origin.x)) + 180;
Where atan2(double, double) is the libm function.
    </para>
</sect3>



<sect3><Title/Kernel function 0x44: GetDistance(Point, Point)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x44: GetDistance
    </funcdef><paramdef>
Point foo, Point bar</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(Point)</type>
<parameter/foo/: A point in two-dimensional integer space
  </member>
  <member><type>
(Point)</type>
<parameter/bar/: Another two-dimensional integer point
  </member>
    </simplelist></para><para>
    Returns: <type>
(int)
    </type>
The euklidian distance between the points foo and bar
    </para><para>
    </para>
</sect3>



<sect3><Title/Kernel function 0x45: Wait(word)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x45: Wait
    </funcdef><paramdef>
word ticks</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(word)</type>
<parameter/ticks/: The number of game ticks (60 Hz beats) to wait
  </member>
    </simplelist></para><para>
    Returns: <type>
(word)
    </type>
The time passed in between the finish of the last Wait() syscall
    </para><para>
    </para>
</sect3>



<sect3><Title/Kernel function 0x46: GetTime([word])/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x46: GetTime
    </funcdef><paramdef>
word mode</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(wrod)</type>
<parameter/mode/: If this parameter is supplied, the time of day is returned.
  </member>
    </simplelist></para><para>
    Returns: <type>
(word)
    </type>
Either the time of day in seconds, or the elapsed number of ticks since the
interpreter started.
    </para><para>
This function is somewhat strange, because it determines its behaviour not by
the value of a parameter passed, but by its presence instead. Please note that the
time of day in this case does not distinguish between am and pm.
    </para>
</sect3>



<sect3><Title/Kernel function 0x47: StrEnd(HeapPtr)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x47: StrEnd
    </funcdef><paramdef>
HeapPtr string</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(HeapPtr)</type>
<parameter/string/: The string whose terminator should be found
  </member>
    </simplelist></para><para>
    Returns: <type>
(HeapPtr)
    </type>
The address of the null terminator of the indexed string
    </para><para>
    </para>
</sect3>



<sect3><Title/Kernel function 0x48: StrCat(HeapPtr, HeapPtr)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x48: StrCat
    </funcdef><paramdef>
HeapPtr dest, HeapPtr source</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(HeapPtr)</type>
<parameter/dest/: The string whose end is appended to
  </member>
  <member><type>
(HeapPtr)</type>
<parameter/source/: The string to append
  </member>
    </simplelist></para><para>
    Returns: <type>
(HeapPtr)
    </type>
dest
    </para><para>
This function concatenates two strings on the heap.
    </para>
</sect3>



<sect3><Title/Kernel function 0x49: StrCmp(HeapPtr, HeapPtr[, word])/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x49:
    </funcdef><paramdef>
HeapPtr foo, HeapPtr bar[, word length]</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(HeapPtr)</type>
<parameter/foo/: The one string to compare
  </member>
  <member><type>
(HeapPtr)</type>
<parameter/bar/: The other string to compare
  </member>
  <member><type>
(int)</type>
<parameter/width/: The maximum number of characters to compare
  </member>
    </simplelist></para><para>
    Returns: <type>
(word)
    </type>
-1 if foo is less than bar, 0 if both are equal, 1 if foo is greater than bar
    </para><para>
This function simply encapsulates the libc <function/strcmp(char *, char *)/ and
<function/strncmp(char *, char *, int)/ functions.
    </para>
</sect3>



<sect3><Title/Kernel function 0x4a: StrLen(HeapPtr)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x4a: StrLen
    </funcdef><paramdef>
HeapPtr string</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(HeapPtr)</type>
<parameter/string/: The string whose length should be calculated
  </member>
    </simplelist></para><para>
    Returns: <type>
(word)
    </type>
The length of the specified string.
    </para><para>
    </para>
</sect3>



	<sect3><Title/Kernel function 0x4b: StrCpy(HeapPtr, HeapPtr[, word])/<para></para>
	    <funcsynopsis><funcprototype><funcdef>
kfunct 0x4b: StrCpy
    </funcdef><paramdef>
HeapPtr dest, HeapPtr src[, word length]</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(HeapPtr)</type>
<parameter/dest/: The destination to copy the string to
  </member>
  <member><type>
(HeapPtr)</type>
<parameter/src/: The source from which the string is to be copied
  </member>
  <member><type>
(word)</type>
<parameter/length/: The maximum length of the string to copy
  </member>
    </simplelist></para><para>
    Returns: <type>
(HeapPtr)
    </type>
dest
    </para><para>
Copies a string, plus the trailing \0 terminator. The length of the string may be reduced
with the optional length parameter. This function simply encapsulates the libc
<function/strcpy(char *, char *)/ and
<function/strncpy(char *, char *, int)/ fucntions.
    </para>
</sect3>



<sect3><Title/Kernel function 0x4c: Format(HeapPtr, String,...)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x4c: Format
    </funcdef><paramdef>
HeapPtr dest, String format, parameters...</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(HeapPtr)</type>
<parameter/dest/: The heap destination to write to
  </member>
  <member><type>
(String)</type>
<parameter/format/: The format to use
  </member>
  <member><type>
(misc)</type>
<parameter/parameters/: The values and strings to insert
  </member>
    </simplelist></para><para>
    Returns: <type>
(HeapPtr)
    </type>
dest
    </para><para>
This syscall acts as a frontend to the libc <function/sprintf(char *, char *)/ function.
    </para>
</sect3>



<sect3><Title/Kernel function 0x4d: GetFarText(word, word, HeapPtr)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x4d: GetFarText
    </funcdef><paramdef>
word resnr, word stringnr, HeapPtr dest</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(word)</type>
<parameter/resnr/: Number of the text resource to retreive the text from
  </member>
  <member><type>
(word)</type>
<parameter/stringnr/: Number of the string inside the resource to retreive
  </member>
  <member><type>
(HeapPtr)</type>
<parameter/dest/: The destination to write the text to
  </member>
    </simplelist></para><para>
    Returns: <type>
(HeapPtr)
    </type>
dest
    </para><para>
Retreives a string from a text resource and puts it on the heap.
    </para>
</sect3>


<sect3><Title/Kernel function 0x4e: ReadNumber(HeapPtr)/<para></para>
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x4e: ReadNumber
    </funcdef><paramdef>
HeapPtr src</paramdef>
    </funcprototype></funcsynopsis><para><simplelist>
  <member><type>
(HeapPtr)</type>
<parameter/src/: The address of the string to interpret as a number
  </member>
    </simplelist></para><para>
    Returns: <type>
(word)
    </type>
The numeric value of the supplied string
    </para><para>
This function acts as a frontend to the libc <function/atoi(char *)/ function, with one exception:
Numbers beginning with a '$' are interpreted as hexadecimal numbers.
    </para>
</sect3>

	<sect3>
	<Title/Kernel function 0x4f: BaseSetter(HeapPtr)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x4f: BaseSetter
		</funcdef><paramdef>HeapPtr view_obj</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(HeapPtr)/ view_obj: The view object whose base is to be set</member>
                   </simplelist></para>
		<para>
			Returns: <type>(void)</type>
		</para><para>
                        This method is used to set the bounding rectangle of a view. The bounding rectangle
                        is specified by the set {brLeft, brRight, brTop, brBottom} of selectors, which indicate
                        the window-relative boundary points of the object's bounding rectangle. The rectangle defined
                        here is used for colission detection, among other things.
                </para><para>
                        The algorithm employed by FreeSCI to determine these values appears to be either identical or
                        very close to the original algorithm; it depends several of the object's selectors (x, y, z,
	        	ystep, view) the width and height of the view indicated by its (view, loop, cel) selectors, and
			that view's horizontal and vertical pixel offset modifyers (xmod, ymod).
			The algorithm works as follows:
<programlisting>
	brLeft := x - xmod - width / 2
	brRight := brLeft + width
	brBottom := y - z - ymod + 1
	brTop := brBottom - ystep
</programlisting>
		</para>
	</sect3>

	<sect3>
	<Title/Kernel function 0x50: DirLoop(HeapPtr, word)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x50: DirLoop
		</funcdef><paramdef>HeapPtr object, word angle</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(HeapPtr)/ object: The object whose loop selector is to be set</member>
                       <member><type/(word)/ angle: The angle which is to be used as a base to choose the loop angle</member>
                   </simplelist></para>
		<para>
			Returns: <type>(void)</type>
		</para><para>
			This function sets the loop selector of the specified object to a value implied by the 'angle' parameter,
			according to the following table:
			<informaltable>
				<tgroup cols="2">
					<thead>
						<row><entry><parameter/angle/</entry><entry/loop value/</row>
					</thead>
					<tbody>
						<row><entry/angle &lt; 45 || angle &gt;= 314/<entry/3/</row>
						<row><entry/angle &gt;= 45 &amp;&amp; angle &lt; 135/<entry/0/</row>
						<row><entry/angle &gt;= 135 &amp;&amp; angle &lt; 225/<entry/2/</row>
						<row><entry/angle &gt;= 225 &amp;&amp; angle &lt; 314/<entry/1/</row>
					</tbody>
				</tgroup>
			</informaltable>
		</para>
	</sect3>

	<sect3><Title/Kernel function 0x51: CanBeHere(HeapPtr [, DblList])/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x51: CanBeHere
		</funcdef><paramdef>HeapPtr obj [, DblList clip_list]</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(HeapPtr)/ obj: The object to test</member>
                       <member><type/(DblList)/ clip_list: An optional list of objects to test <parameter/obj/ against</member>
                   </simplelist></para>
		<para>
			Returns: <type>(int)</type>
                        1 if <parameter/obj/ can be where it is, 0 if not.
		</para><para>
			This function first retreives <parameter/obj/'s signal and illegalBits
			selectors, plus its brRect (boundary rectangle, consisting of brTop, brBottom,
			brLeft and brRight). If either of the DONT_RESTORE or IGNORE_ACTOR flags is set,
			the function returns 1, otherwise it proceeds with verifying that
                       <simplelist>
                           <member>illegalBits bitwise-AND the disjunction of all elements of { 2<superscript/n/ |
					&exist; a pixel with the color value n inside the control map zone
					delimited by obj's brRect} equals 0</member>
			   <member>&not;&exist;pic,pic&isin;clip_list. (pic::signal &amp; (DONT_RESTORE | IGNORE_ACTOR)) = 0
					&and; pic::brRect &cap; obj::brRect &ne; &empty;</member>
                       </simplelist>
			If both conditions are met, 1 is returned. Otherwise, 0 is returned.
		</para>
	</sect3>


  <sect3 ID="KONCONTROL">
         <title/Kernel function 0x52: OnControl(word, Point | Rect)/
       <funcsynopsis><funcprototype><funcdef>
kfunct 0x52: OnControl
       </funcdef><paramdef>word map, Point|Rect area</paramdef>
         </funcprototype></funcsynopsis>
       <para><simplelist>
          <member><type/(word)/ map: The map to check (bit 0: visual, bit 1: priority, bit 2: special)
            </member>
          <member><type/(Point) or (Rect)/ Area: The point or rectangle that is to be scanned</member>
       </simplelist></para>
       <para>
         Returns: <type/(word)/ The resulting bitfield
       </para>
       <para>
         This function scans the indicated point or area on the specified <parameter/map/, and sets
         the bit corresponding to each color value found correspondingly. For example, if scanning
         map 4 (special) would touch two areas, one with color value 1 and one with color value 10,
         the resulting return value would be 0x0402 (binary 0000010000000010).
         See also <xref linkend="LARSPICSANDMOVEMENT">.
       </para>
     </sect3>

        <sect3>
        <Title/Kernel function 0x53: InitBresen(HeapPtr [, word])/
                <funcsynopsis><funcprototype><funcdef>
                        kfunct 0x53: InitBresen
                </funcdef><paramdef>HeapPtr mover, word step_factor</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(HeapPtr)/ mover: The mover object to initialize</member>
                       <member><type/(word)/ step_factor: A factor to multiply the step size with (defaults to 1)</member>
                   </simplelist></para>
                <para>
                        Returns: <type>(void)</type>
                </para><para>
		  Initializes a mover object for bresenham movement from the object's client's coordinates to the coordinates
		  specified by its own pair of (x,y) selectors. To do this, it retreives the
		  mover's client, and calculates the result values according to the algorithm
		  for determining the initial values for iterative line drawing according to the Bresenham line algorithm:
<programlisting>
        client := mover::client
        &delta;x := mover::x - client::x
        &delta;y := mover::y - client::y

        vx<subscript/max/ := client::xStep * step_factor
        vy<subscript/max/ := client::yStep * step_factor

        numsteps<subscript/x/ := |&delta;x / vx<subscript/max/|
        numsteps<subscript/y/ := |&delta;y / vy<subscript/max/|

        IF numsteps<subscript/x/ > numsteps<subscript/y/ THEN
                numsteps := numsteps<subscript/x/
                mover::b_xAxis := 1
                &delta;<subscript/0/ := &delta;x
                &delta;<subscript/1/ := &delta;y
                s := client::yStep
        ELSE
                numsteps := numsteps<subscript/y/
                mover::b_xAxis := 0
                &delta;<subscript/1/ := &delta;x
                &delta;<subscript/0/ := &delta;y
                s := client::xStep
        FI

        mover::dx := &delta;x / numsteps
        mover::dy := &delta;y / numsteps

        mover::b_di := - |&delta;<subscript/0/|
        mover::b_i1 := 2 * (|&delta;<subscript/1/| - |s * numsteps|) * |&delta;<subscript/0/|
        mover::b_incr := &delta;<subscript/1/ / |&delta;<subscript/1/|
        mover::b_i2 := mover::b_d1 * 2
</programlisting>
                </para>
        </sect3>

<!-- fixme -->
<sect3><Title/Kernel function 0x54: DoBresen(?)/<para></para></sect3>

        <sect3>
        <title/Kernel function 0x55: DoAvoider()/
                <funcsynopsis><funcprototype><funcdef>
                        kfunct 0x55: DoAvoider
                </funcdef><paramdef></paramdef></funcprototype></funcsynopsis>
                <para>
                        Returns: <type>(void)</type>
                </para><para>
                        This function is a no-op.
                </para>
        </sect3>


<!-- fixme -->
<sect3><Title/Kernel function 0x56: SetJump(?)/<para></para></sect3>

  <sect3>
<Title/Kernel function 0x57: SetDebug()/
    <funcsynopsis><funcprototype><funcdef>
kfunct 0x57: SetDebug
    </funcdef><paramdef></paramdef></funcprototype></funcsynopsis><para>
    Returns: <type>
(void)
    </type>
    </para><para>
This function forces the interpreter to enter debug mode. It is equivalent
to pressing LShift-RShift-PadMinus.
    </para>
  </sect3>

<!-- fixme -->
<sect3><Title/Kernel function 0x58: InspectObj(?)/<para></para></sect3>

<!-- fixme -->
<sect3><Title/Kernel function 0x59: ShowSends(?)/<para></para></sect3>

<!-- fixme -->
<sect3><Title/Kernel function 0x5a: ShowObjs(?)/<para></para></sect3>

<!-- fixme -->
<sect3><Title/Kernel function 0x5b: ShowFree(?)/<para></para></sect3>

	<sect3>
	<Title/Kernel function 0x5c: MemoryInfo(word)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x5c: word mode
		</funcdef><paramdef>word mode</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(word)/ mode: 0 to 4 (see below)</member>
                   </simplelist></para>
		<para>
			Returns: <type>(word)</type> The amount of free memory on the heap, in bytes
		</para><para>
		  This function returns the total amount of free memory on the heap if mode == 0.
		  If mode equals 1, the total size of the largest chunk of heap memory is returned.
		  In mode 2, the size of the largest available hunk memory block is returned, and
		  mode 3 returns the total amount of free hunk memory, shiftet to the right by 4 bits.
		  </para><para>
		    Mode 4 was apparently introduced in SCI01 and reports the amount of free memory
		    provided by DOS in paragraphs.
		  </para>
	</sect3>

<!-- fixme -->
<sect3><Title/Kernel function 0x5d: StackUsage(?)/<para></para></sect3>

<!-- fixme -->
<sect3><Title/Kernel function 0x5e: Profiler(?)/<para></para></sect3>

<!-- fixme -->
<sect3><Title/Kernel function 0x5f: GetMenu(?)/<para></para></sect3>

<!-- fixme -->
<sect3><Title/Kernel function 0x60: SetMenu(?)/<para></para></sect3>

	<sect3>
	<Title/Kernel function 0x61: GetSaveFiles(String, String, HeapPtr*)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x61: GetSaveFiles
		</funcdef><paramdef>String game_id, String strspace, HeapPtr *ptrs</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(String)/ game_id: The game ID as a string</member>
                       <member><type/(String)/ strspace: The string which the result should be stored in</member>
                       <member><type/(HeapPtr *)/ ptrs: The array of pointers which the string pointers are to be stored in</member>
                   </simplelist></para>
		<para>
			Returns: <type>(word)</type>
                        The number of savegames for the specified game_id.
		</para><para>
                   Returns an array of strings describing the existing save games for game_id.
                   The strings are put into strspace one by one, and heap pointers to each of
                   them are put into the ptrs array.
                   The number of saved games is returned in the accumulator.
		</para>
	</sect3>


        <sect3>
        <Title/Kernel function 0x62: GetCWD(HeapPtr)/
                <funcsynopsis><funcprototype><funcdef>
                        kfunct 0x62: GetCWD
                </funcdef><paramdef>HeapPtr address</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(HeapPtr)/ address: The address to write to</member>
                   </simplelist></para>
                <para>
                        Returns: <type/(HeapPtr)/ The supplied address
                </para><para>
                        This function retreives the current working directory (CWD) and stores
                        its string representation at the location pointed to by the supplied
                        parameter.
                        <note><para>FreeSCI returns a sub-directory of the user's home directory,
                          if applicable, instead of the cwd.</para></note>
                </para>
        </sect3>
                

	<sect3>
	<Title/Kernel function 0x63: CheckFreeSpace(String)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x63: CheckFreeSpace
		</funcdef><paramdef>String path</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(String)/ path: The path to examine</member>
                   </simplelist></para>
		<para>
			Returns: <type>(word)</type>
                        1 if saving is possible, 0 otherwise
		</para><para>
                     Returns TRUE if there would be enough space left on the specified path to
                     save the current game (but doesn't actually save).
		</para>
	</sect3>

<!-- fixme -->
<sect3><Title/Kernel function 0x64: ValidPath(?)/<para></para></sect3>

<!-- fixme -->
<sect3><Title/Kernel function 0x65: CoordPri(?)/<para></para></sect3>

	<sect3>
	<Title/Kernel function 0x66: StrAt (String, word[, char])/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x66: StrAt
		</funcdef><paramdef>String src, word offset[, char replacement]</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(String)/ src: The string to read from</member>
                       <member><type/(word)/ offset: The offset inside the string</member>
                       <member><type/(char)/ replacement: An optional replacement value for the indexed character</member>
                   </simplelist></para>
		<para>
			Returns: <type>(char)</type>
			The character requested
		</para><para>
			This function retreives a single character from a string. Optionally, if
			<parameter/replacement/ is set, the source character will be replaced with
			the specified <parameter/replacement/.
		</para>
	</sect3>

	<sect3>
	<Title/Kernel function 0x67: DeviceInfo(word, String[, String])/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x67: DeviceInfo
		</funcdef><paramdef>word sub_function, String string1[, String string2]</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(word)/ sub_function: A numeric value from 0 to 3, inclusive. See below.</member>
                       <member><type/(String)/ string1: See below.</member>
                       <member><type/(String)/ string2: See below.</member>
                   </simplelist></para>
		<para>
			Returns: See below
		</para><para>
                        Depending on the value of sub_function, this system call executes one of
                        four defined actions:
                        <simplelist>
                          <member/0: GET_DEVICE/
                          <member/1: GET_CURRENT_DEVICE/
                          <member/2: PATHS_EQUAL/
                          <member/3: IS_FLOPPY/
                        </simplelist>
                        See the specific function definitions below for more information.
		</para>
	</sect3>


	<sect3>
	<Title/Kernel function 0x67: DeviceInfo(GET_DEVICE, String, String)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x67: DeviceInfo
		</funcdef><paramdef>word GET_DEVICE, String input, String output</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(word)/ GET_DEVICE: Constant sub-function identifier (0)</member>
                       <member><type/(String)/ input: A path whose device identifier should be extracted</member>
                       <member><type/(String)/ output: The destination of the device identifier</member>
                   </simplelist></para>
		<para>
			Returns: <type>(HeapPtr)</type>
                        Points to the terminating zero character of output
		</para><para>
                   GET_DEVICE returns the drive/device on which "input" resides in output
                   (and a pointer to the terminating NULL in the accumulator).
		</para>
	</sect3>

	<sect3>
	<Title/Kernel function 0x67: DeviceInfo(GET_CURRENT_DEVICE, String output)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x67: DeviceInfo
		</funcdef><paramdef>word GET_CURRENT_DEVICE, String output</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(word)/ GET_CURRENT_DEVICE: Constant sub-function identifier (1)</member>
                       <member><type/(String)/ output: The destination which the CWD device
                            identifier should be written to.</member>
                   </simplelist></para>
		<para>
			Returns: <type>(HeapPtr)</type>
                           Points to the terminating null character of output
		</para><para>
                       GET_CURRENT_DEVICE returns the drive/device that contains the current working
                       directory (and a pointer to the terminating NULL in the accumulator)
		</para>
	</sect3>

	<sect3>
	<Title/Kernel function 0x67: DeviceInfo(PATHS_EQUAL, String path1, String path2)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x67: DeviceInfo
		</funcdef><paramdef>word PATHS_EQUAL, String path1, String path2</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(word)/ PATHS_EQUAL: Constant sub-function identifier (2)</member>
                       <member><type/(String)/ path1: First path to compare</member>
                       <member><type/(String)/ path2: Second path to compare</member>
                   </simplelist></para>
		<para>
			Returns: <type>(word)</type>
                        1 if path1 and path2 point to the same physical location, 0 otherwise.
		</para><para>
                    PATHS_EQUAL returns TRUE if the two supplied paths point to the same place.
		</para>
	</sect3>

	<sect3>
	<Title/Kernel function 0x67: DeviceInfo(IS_FLOPPY, String path)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x67: DeviceInfo
		</funcdef><paramdef>word IS_FLOPPY, String path</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(word)/ IS_FLOPPY: Constant sub-function identifier (3)</member>
                       <member><type/(String)/ path:</member>
                   </simplelist></para>
		<para>
			Returns: <type>(word)</type>
                        1 if <parameter/path/ is on a floppy disk, 0 otherwise
		</para><para>
                     PATHS_EQUAL returns TRUE if the two supplied paths point to the same place.
		</para>
	</sect3>

	<sect3>
	<Title/Kernel function 0x68: GetSaveDir()/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x68: GetSaveDir
		</funcdef><paramdef></paramdef></funcprototype></funcsynopsis>
		<para>
			Returns: <type>(String)</type>
		</para><para>
			This function returns the heap position allocated to store the string
			representation of the save game directory. This heap space is
			allocated automatically during startup.
		</para>
	</sect3>


	<sect3>
	<Title/Kernel function 0x69: CheckSaveGame(String, word[, String])/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x69: CheckSaveGame
		</funcdef><paramdef>String game_id, word game_nr[, String version]</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(String)/ game_id: The savegame ID string</member>
                       <member><type/(word)/ game_nr: The savegame number</member>
		 	<member><type/(String)/ version: An optional game version string</member>
                   </simplelist></para>
		<para>
			Returns: <type>(word)</type>
                        1 if the savegame is loadable, 0 otherwise
		</para><para>
                      Returns TRUE if the specified save game is valid and loadable (i.e., not for
                      another game/interpreter/version).
		</para>
	</sect3>

<!-- fixme -->
<sect3><Title/Kernel function 0x6a: ShakeScreen(?)/<para></para></sect3>

<!-- fixme -->
<sect3><Title/Kernel function 0x6b: FlushResources(?)/<para></para></sect3>

<!-- fixme -->
<sect3><Title/Kernel function 0x6c: SinMult(?)/<para></para></sect3>

<!-- fixme -->
<sect3><Title/Kernel function 0x6d: CosMult(?)/<para></para></sect3>

<!-- fixme -->
<sect3><Title/Kernel function 0x6e: SinDiv(?)/<para></para></sect3>

<!-- fixme -->
<sect3><Title/Kernel function 0x6f: CosDiv(?)/<para></para></sect3>

<!-- fixme -->
<sect3><Title/Kernel function 0x70: Graph(?)/<para></para></sect3>


	<sect3>
	<Title/Kernel function 0x71: Joystick(word, word)/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x71: Joystick
		</funcdef><paramdef>word subfunction, word param</paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/(word)/ subfunction: Always 0x0c</member>
                       <member><type/(word)/ param: Parameter for the subfunction, purpose unknown.</member>
                   </simplelist></para>
		<para>
			Returns: <type>(void)</type>
		</para><para>
		</para>
	</sect3>

<!-- Template for kernel function entries (14 lines)
	<sect3>
	<Title/Kernel function 0x: ()/
		<funcsynopsis><funcprototype><funcdef>
			kfunct 0x: 
		</funcdef><paramdef></paramdef></funcprototype></funcsynopsis>
                <para>
                   <simplelist>
                       <member><type/()/ :</member>
                   </simplelist></para>
		<para>
			Returns: <type>()</type>
		</para><para>
		</para>
	</sect3>
-->




 </sect2>
</sect1>
</Chapter>


<Chapter>
  <Title/SCI in action/
  <sect1 ID="LarsEvents">
   <Title/Event handling in SCI/
    <para>
     By <Author><FirstName/Lars/<SurName/Skovlund/</author>
    </para><para/Version 1.0, 12. July 1999/
<para>
This article will deal with the event manager in SCI. Like several other
key parts of the interpreter, this one actively communicates with the SCI
application. It directly writes to objects of the Event class, but more on
that later.
</para><para>
The different input devices are polled differently:
<itemizedlist>
<listitem><para>The keyboard is typically polled at each timer tick (which is 60 hz).</para>
</listitem>
<listitem><para>SCI sets up a callback for the PC mouse driver, meaning that
the mouse driver "polls itself" and sends information to the interpreter.
On non-MS-DOS platforms, this would probably be done in the timer handler.
<footnote><para>The default FreeSCI event mechanism uses libgii, which is completely
event-based.</para></footnote></para></listitem>
<listitem><para>The joystick is only polled when the script wants to.</para></listitem>
</itemizedlist>
</para><para>
Some parts of the event mechanism (in particular, keyboard management) are
very PC specific, and a conversion will no doubt have to take place on other
platforms.
</para>
 <sect2>
  <title/Event types and modifiers/
   <para>
There are three types of events, distinguished by their "type" property.
The possible values are listed below; they are laid out as a bitfield to
allow for selective event retrieval, see later.
<simplelist>
  <member/0x00 - Null event/
  <member/0x01 - Mouse button event/
  <member/0x02 - Mouse button release event/
  <member/0x04 - Keyboard event/
  <member/0x40 - Movement (joystick) event/
</simplelist>
</para><para>
This type is returned to the SCI event managers by the input device drivers
along with a "message" and a set of "modifiers". This is the basic event
structure, although some event types contain extra information. The latter
field is a direct copy of the BIOS shift flags, laid out as follows:
</para><para>
<simplelist>
<member/bit 7 - Insert active/
<member/bit 6 - Caps lock active/
<member/bit 5 - Num lock active/
<member/bit 4 - Scroll lock active/
<member/bit 3 - Alt key pressed/
<member/bit 2 - Ctrl key pressed/
<member/bit 1 - Left shift key pressed/
<member/bit 0 - Right shift key pressed/
</simplelist>
</para><para>
It is obvious, then, that these keys by themselves don't generate any
keyboard events. They can, however, be combined with other keys or mouse
clicks to produce "shift-click" events, for instance.
</para>
<sect3><title/The null events/
<para>
These are generated when a script wants to see an event, but there isn't one
to give. The current tick count and mouse position. The tick count, as 
explained in
another document, is the time passed since the interpreter started, measured
in 1/60ths of a second. It doesn't seem to be copied into the event object,
however.
</para>
</sect3>

<sect3>
 <title/The mouse events/
<para>
The mouse position is returned in extra fields in the event record.
</para><para>
If the middle or right button is pressed, this is reflected by the 
modifiers,
in addition to the mouse event. The middle button is translated to the Ctrl
key (i.e. set modifiers bit 2), the right button "holds down" both shift 
keys
(setting bits 1 and 0). Every SCI interpreter (at least from 0.000.572 and
up) does this, but to my knowledge it is used only in QfG2, where either
a shift-click or a right-click is equivalent to typing "look ...".
</para></sect3>

<sect3><title/The keyboard event/
<para>
The keyboard driver also generates events. When a key is pressed, a keyboard
event is generated, with the message field set to the scan code of the
pressed key. It should be simple enough, right? Not quite so. The script may
want to know if a direction key was pressed, and if so, which. It may call
the KMapKeyToDir kernel function for this. KMapKeyToDir takes a keyboard
event as input and converts it to a movement event, which is described next.
</para>
</sect3>

<sect3>
<title/The movement event/
<para>
The movement event is only generated by the joystick driver. However, on
request, the keyboard driver can convert keyboard events into movement 
events
as described above. The message field is just a direction code, mapped as
follows:
<informaltable frame="all">
    <tgroup cols="3">
     <tbody>
       <row>
        <entry/8/
        <entry/1/
        <entry/2/
       </row>
       <row>
        <entry/7/
        <entry/Center/
        <entry/3/
       </row>
       <row>
        <entry/6/
        <entry/5/
        <entry/4/
       </row>
     </tbody>
    </tgroup>
   </informaltable>
</para><para>
That is, the direction code starts at straight up (code 1), increasing
with clockwise movement.
</para>
</sect3>

</sect2>
  </sect1>
  <sect1 ID="LarsDMParser">
     <Title/The Parser/
        <sect2>
          <Title/Vocabulary file formats/
             <para>By <author><firstname/Lars/<surname/Skovlund/</author>
</para><para>
Version 1.0, 30. July 1999
</para>
<sect3><title/The main vocabulary (VOCAB.000)/
<para>
The file begins with a list of 26 offsets. Each index corresponds to a 
letter
in the (English) alphabet, and points to the first word starting with that
letter. The offset is set to 0 if no words start with that letter.
If an input word starts with an alphabetical letter, this table is
used to speed up the vocabulary searching - though not strictly necessary,
this speeds up the lookup process somewhat.
</para><para>
After the offset table are the actual words. A word defition consists of
two parts: The actual text of the word, compressed in a special way, and a
24-bit (yes, three bytes) ID. The ID divided in 2 12-bit quantities, a
word class (grammatically speaking) mask, and a group number.
The class mask is used, among other things, for throwing away unnecessary
words. "Take book", for instance, is a valid sentence in parser'ese, while 
it
isn't in English.
</para><para>
The possible values are arranged as a bit field to allow for
class masks, see later. Only one bit is actually tested by the interpreter.
If a word class equals to 0xff ("anyword"), the word is excluded (allowing for
parser'ese). The values go like this:
<simplelist>
<member/0x001 - preposition/
<member/0x002 - article/
<member/0x004 - qualifying adjective/
<member/0x008 - relative pronoun/
<member/0x010 - noun/
<member/0x020 - indicative verb (such as "is", "went" as opposed to _do_ this or
that, which is imperative)/
<member/0x040 - adverb/
<member/0x080 - imperative verb/
<member/0x100 - number (not found in the vocabulary, set internally)/
<member/0x200 - special/
<member/0x400 - special/
<member>0x800 - special<footnote><para>The three special classes are apparently used for words
with very specific semantics, such as "if", "not", "and" etc. It is unknown as of yet whether they
receive special treatment by the parser.</para></footnote></member>
</simplelist>
</para><para>
The group number is used to implement synonyms (words with the same
meaning), as well as by the Said instruction to identify words. There is 
also
a way of using synonyms in code, see the appropriate document.
</para><para>
The compression works in this way: Each string starts with a byte-sized copy
count. This many characters are retained from the previous string. The
actual text comes after, in normal low-ascii. The last character in the text
has its high bit set (no null termination!).
</para><para>
Here is an example of the compression scheme:
<simplelist>
<member/  apple - 0,appl\0xE5/
</simplelist>
</para><para>
The byte count is 0 because we assume that "apple" is the first word
beginning with an a (not likely, though!). 0xE5 is 0x65 (the ascii value
for 'e') | 0x80. Watch now the next word:
<simplelist>
<member/  athlete - 1,thlet\0xE5/
</simplelist>
</para><para>
Here, the initial letter is identical to that of its predecessor, so the
copy count is 1. Another example:
<simplelist>
<member/  atrocious - 2,rociou\0xF3/
</simplelist>
</para>
</sect3>
<sect3>
<Title/The suffix vocabulary (VOCAB.901)/
<note><para/
Note: You may need to consult a grammar book to fully understand the
following discussion./</note>
<para>
The suffix vocabulary is structurally much simpler. It consists of
variably-sized records with this layout:
<informaltable frame="all">
    <tgroup cols="2">
     <tbody>
       <row>
        <entry/NULL-TERMINATED/
        <entry/Suffix string/
       </row>
       <row>
        <entry/WORD/
        <entry/The class mask for the suffix/
       </row>
       <row>
        <entry/NULL-TERMINATED/
        <entry/Reduced string/
       </row>
       <row>
        <entry/WORD/
        <entry/The output word class/
       </row>
     </tbody>
    </tgroup>
</informaltable>
</para><para>
The suffix vocabulary is used by the interpreter in order to parse compound
words, and other words which consist of more than one part. For
instance, a simple plural noun like "enemies" is reduced to its singular
form "enemy", "stunning" is converted to "stun" etc. The point is that the
interpreter gets a second chance at figuring out the meaning if the word
can not be identified as entered. A word which changes its class does
might end up as a different word class, the correct class is always 
retained.
Thus, "carefully", an adverb, is reduced to its adjectival form "careful",
and found in the vocabulary as such, but it is still marked as an adverb.
</para><para>
The suffix vocabulary consists of variably-sized records with this layout:
<informaltable frame="all">
    <tgroup cols="2">
     <tbody>
       <row>
         <entry/NULL-TERMINATED/
         <entry/Suffix string/
       </row>
       <row>
         <entry/WORD/
         <entry/The output word class/
       </row>
       <row>
         <entry/NULL-TERMINATED/
         <entry/Reduced string/
       </row>
       <row>
         <entry/WORD/
         <entry/The allowed class mask for the reduced word/
       </row>
     </tbody>
    </tgroup>
</informaltable>
</para><para>
An asterisk (*) represents the word stem. Taking the above example with
"enemies", the interpreter finds this record:
<simplelist>
<member/  *ies/
<member/  1/
<member/  *y/
<member/  1/
</simplelist>
word class 1 being a noun.
</para><para>
The interpreter then tries to replace "enemies" with "enemy" and finds that
word in the vocabulary. "Enemy" is a noun (class 1), which it is also
supposed to be, according to the suffix vocabulary. Since we succeeded,
the word class is set to the output value (which is, incidentally, also 1).
</para>
<sect4><Title/Numbers/
<para>
If the word turns out to be a number (written with numbers, that is), and
that number is not listed explicitly in the vocabulary, it gets an ID of
0xFFD, and a word class of 0x100.
</para>
</sect4>
</sect3>
<sect3><Title/The tree vocabulary (VOCAB.900)/
<para>
This vocabulary is used solely for building parse trees. It consists of a
series of word values which end up in the data nodes on the tree. It doesn't 
make much
sense without the original parsing code.
</para>
</sect3>   
    </sect2>
    <sect2><Title/The black box: The magic behind Sierra's text parser/
    <para>By <author><firstname/Lars/<surname/Skovlund/</author>
</para><para>
Version 0.1, 30. July 1999. Incomplete!
</para><para>
This document describes the process of parsing user input and relating it
to game actions. This document does not describe the process of the user
typing his command; only the "behind-the-scenes" work is described, hence
the title.
</para><para>
The process of parsing is two-fold, mainly for speed reasons. The Parse
kernel function takes the actual input string and generates a special
"said" event (type 0x80) from it. This function is only called once per
line. Parse can either accept or reject the input. <note><para/A rejection can only
occur if Parse fails to identify a word in the sentence./</note> Even if Parse
accepts the sentence, it does not need to make sense. Still, syntax checks
are made - see later.
</para><para>
Assuming that the parsing succeeded, the User object (which encapsulates the
parser) then goes on to call the relevant event handlers. These event hand-
lerrs in turn call the Said kernel function. This function is potentially
called hundreds or even thousands of times, so it must execute as quickly
as possible. Said simply determines from the pre-parsed input line whether
or not a specific command is desired.
</para><para>
The Parse function must always work on an internal copy of the actual 
string,
because the user must be able to recall his exact last input using the F3
key. The parser's first step is to convert the input line to pure lower 
case.
This is because the vocabulary words are entered in lower case. The parser
then searches the main vocabulary (VOCAB.000), hoping to find the word.
</para><para>
This doesn't necessarily happen yet. Consider, for example, the meaning of
the word "carefully", which does not appear in the vocabulary, but is found
anyway. This is due to the so-called suffix vocabulary, which is discussed
in another document.
</para><para>
If the word still can't be found, the interpreter copies the failing word
into a buffer temporarily allocated on the heap (remember, the interpreter
operates on its own local buffers). It then calls the Game::wordFail method
which prints an appropriate message. The interpreter then deallocates the
buffer and exits (it does, however, still return an event. The claimed
property of that event is set to TRUE to indicate that the event has already
been responded to (error message printed)).
</para><para>
If the interpreter succeeds in identifying all the words, it then goes on to
check the syntax of the sentence - it builds a parse tree. See the appropri-
ate document.
</para><para>
If the syntax of the sentence is invalid, the interpreter calls
Game::syntaxFail, passing the entire input line. As for the error situation,
the event is claimed.
</para><para>
As mentioned in the beginning of this text, this function generates an
event. This event, apart from its type id, does not contain any data. 
Rather,
all pertinent data is kept in the interpreter.
</para><para>
The Said kernel function is called for each command which the game might 
respond to at any given time. Its only parameter is a pointer to a said 
information block which resides in script space. This block is described below
(see <XREF LINKEND="CRSaidSpec">).
</para><para>
The Said function first does some sanity checking on the event pointer which
Parse stored earlier. It must be a said event (type property), and it must
not have been handled by an earlier call to Said (claimed property).
</para><para>
It then word-extends the passed said block into a temporary buffer
(command codes are byte-sized, remember?). This is supposedly just for
convenience/speed, and not really needed.
</para>
   </sect2>
	<sect2><Title/The Parse tree/
		<para>
			<note><para/This and the two following sections borrow some ideas and structures from abstract
			language theory. Readers might want to consider related literature./
			  <para>Most of the information explained here was gathered by Lars Skovlund, and, before that, Dark Minister.</para></note>
		</para>
		<para>
		  After tokenizing, looking up, and finally aliasing the data found in the
		  parsed input string, the interpreter proceeds to build a parse tree T<subscript/&Pi;/
		  from the input tokens
		  <blockquote><para>
		    I := w<subscript/0/, w<subscript/1/, w<subscript/2/ ... w<subscript/n-1/
		  </para></blockquote>
		  where
		  <blockquote><para>
		    w<subscript>j</subscript> &isin; W
		    &gamma;<subscript>j</subscript> &isin; &Gamma;
		    &mu;<subscript>j</subscript> &isin; 2<superscript>C</superscript>
		    w<subscript>j</subscript> := (&gamma;<subscript>j</subscript>, &mu;<subscript>j</subscript>)
		  </para></blockquote>
		  with W being the set of all words, &Gamma being the set of all word groups, C being the set of all class masks {1, 2, 4, 8, 10, 20, 40, 80, 100},
		  &gamma;<subscript>j</subscript> being the word group w<subscript>j</subscript> belongs to, and
		  &mu;<subscript>j</subscript> being its class mask, as described above.
		</para>
		<para>
		  For the following sections, we will define
		  <blockquote><para>
		    group: W &rarr; &Gamma;
		    	group((&gamma;, &mu;)) := &gamma;

		    classes: W &rarr; C
		    	classes((&gamma;, &mu;)) := &mu;

		    C<subscript>x</subscript> := { w | w &isin; W. x &isin; class(w) }
		  </para></blockquote>
			To do that, it uses the class masks M as input for a pushdown automaton (PDA) A
			built from a parser grammar; if M was accepted by A, the parse tree T<subscript/&Pi;/ will
			be built from the matching syntax tree to represent the semantics.
		</para>
		<para>
			The PDA is defined by a grammar G=(V, &Sigma, P, s), most of which, along with its semantics, is
			stored in vocab.900. This resource contains a parser rule at every 20 bytes, starting with a
			non-terminal symbol v (one word) and a null-terminated list of up to five tuples (&sigma;<subscript/i/, m<subscript/i/), both of which
			are words. In these tuples, m<subscript/i/ is a terminal or non-terminal symbol (determined by &sigma;<subscript/i/), and
			&sigma;<subscript/i/ is the meaning of m<subscript/i/:
			<informaltable frame="all">
				<tgroup cols="2">
					<thead>
						<row>
							<entry>&sigma;<subscript/i/</entry>
							<entry/Type/
							<entry/Meaning/
						</row>
					</thead>
					<tbody>
						<row>
							<entry/0x141/
							<entry/Non-terminal/
							<entry/Predicate part: This identifies the first part of a sentence/
						</row>
						<row>
							<entry/0x142/
							<entry/Non-terminal/
							<entry/Subject part: This identifies the second part of a sentence/
						</row>
						<row>
							<entry/0x143/
							<entry/Non-terminal/
							<entry/Suffix part: This identifies the third and last part of a sentence/
						</row>
						<row>
							<entry/0x144/
							<entry/Non-terminal/
							<entry/Reference part: This identifies words that reference another word in the same sentence part/
						</row>
						<row>
							<entry/0x146/
							<entry/Terminal/
							<entry>Match on class mask: Matches if (m<subscript/i/ &isin; classes(w<subscript/j/))</entry>
						</row>
						<row>
							<entry/0x14d/
							<entry/Terminal/
							<entry>Match on word group: Matches if (m<subscript/i/ = group(w<subscript/j/))</entry>
						</row>
						<row>
							<entry/0x154/
							<entry/Terminal/
							<entry/"Force storage": Apparently, this was only used for debugging./
						</row>
					</tbody>
				</tgroup>
			</informaltable>
			With the notable exception of the first rule, these rules constitute P.  V := { x | &exist;R, R &isin; P. x &isin; R }; typically,
			V := {0x12f ... 0x13f}. s := m<subscript/0/ of the first rule encountered; in all games observed, it was set to 0x13c. &Sigma contains
			all word groups and class masks. For the sake of simplicity, we will consider rules matching composite class masks to be several rules.
			Here is a simplified example of what such a grammar might look like (the hexadecimal prefix '0x' is omitted for brevity):
			<example>
			  <title>Parse grammar example</title>
			  <blockquote><para>
	    G := ({12f ... 13e}, {C<subscript/1/, C<subscript/2/, C<subscript/4/ ... C<subscript/100/}, P, 13c)
	    P := {
	  	13c &rarr; 13b 134
	  	13c &rarr; 13b 13d 133
	  	13c &rarr; 13b 13d
	  	13c &rarr; 13b
	  	13c &rarr; 13b 13d 13b 13d
	    	13b &rarr; 131 134
	    	13b &rarr; 131 13d 13d
		13b &rarr; 131
		13d &rarr; 134
	    	131 &rarr; C<subscript/80/
	    	133 &rarr; C<subscript/20/
	    	134 &rarr; C<subscript/10/
	    }
			  </para></blockquote>
			</example>
			In addition to this grammar, each right-hand non-terminal m<subscript/i/ carries its semantic value &rho;<subscript>i</subscript>, which is
			not relevant for constructing a syntax tree, but must be considered for the semantic tree T<subscript>&Pi;</subscript>. These values were omitted
			in the example above.
			As in the example above, the grammar is a context-free (type 2) grammar, almost in Chomsky Normal Form (<acronym>CNF</acronym>) in SCI; constructing a
			grammar with CNF rules from it would be trivial.
			<footnote><para>FreeSCI constructs a <acronym>GNF</acronym> (Greibach Normal Form) representation from these rules for parsing.</para></footnote>
			<example><title>Parser example</title>
			  <para>
			    Parse is called with "open door".
			    <blockquote><para>
	      "open" &isin; (842, {C<subscript>80</subscript>}) (an imperative word of the word group 0x842)
	      "door" &isin; (917, {C<subscript>10</subscript>}) (a substantive of the word group 0x917)

	      I := (842, {C<subscript>80</subscript>}), (917, (C<subscript>10</subscript>)
			    </para></blockquote>
			    I is clearly accepted by automatons based on the grammar described above. Here are two possible derivations:
			    <blockquote><para>
	      D<subscript>0</subscript>:
	      13c
			      (13c &rarr; 13b 134)
	      |- 13b 134
			      (13b &rarr; 131)
	      |- 131 134
			      (131 &rarr; C<subscript>80</subscript>)
	      |- C<subscript>80</subscript> 134
			      (134 &rarr; C<subscript>10</subscript>)
	      |- C<subscript>80</subscript> C<subscript>10</subscript>


	      D<subscript>1</subscript>:
	      13c
			      (13c &rarr; 13b)
	      |- 13b
			      (13b &rarr; 131 134)
	      |- 131 134
			      (131 &rarr; C<subscript>80</subscript>)
	      |- C<subscript>80</subscript> 134
			      (134 &rarr; C<subscript>10</subscript>)
	      |- C<subscript>80</subscript> C<subscript>10</subscript>
			    </para></blockquote>
			  </para>
			</example>
			Obviously, G is an ambiguous grammar. In SCI, rule precedence is implied by rule order, so the resulting left derivation tree is well-defined
			(in the example, it would be defined by D<subscript>0</subscript>)
			<footnote><para>In FreeSCI, you can use the "parse" console command to retreive all possible left derivation trees</para></footnote>.
			</para>
			<sect3>
			  <title>Semantics</title>
			  <para>
			    This is important, since the parser does much more than just accept or discard input. Using the semantic tags applied to each non-terminal
			    on the right-hand side of a rule, it constructs what I will call the semantic parse tree T<subscript>&Pi;</subscript>, which attempts to
			    describe what the input means. For each non-terminal rule
			    <blockquote><para>
			      r := v<subscript>0</subscript> &rarr; v<subscript>1</subscript> v<subscript>2</subscript> ... v<subscript>n</subscript>
			    </para></blockquote>
			    there are semantic tags &sigma;<subscript>r,1</subscript>, &sigma;<subscript>r,2</subscript> ... &sigma;<subscript>r,n</subscript> &isin; S, as explained above.
			    T<subscript>&Pi;</subscript> is now constructed from the resulting derivation and the semantic tags assiociated with each non-terminal of the rule used. The construction
			    algorithm is explained below with T<subscript>&Pi;</subscript> being constructed from nodes, which have the following structure:
			    <blockquote><para>
			      Nodes := {&diams;} &cup; S  V  (Nodes &cup; &Gamma;)&lowast;
			    </para></blockquote>
			    Where S is the set of possible semantic values, and V is the set of non-terminals as defined in the grammar. We will also use the sequence
			    &gamma;<subscript>0</subscript>, &gamma;<subscript>1</subscript>, &gamma;<subscript>2</subscript> ... &gamma;<subscript>k-1</subscript>, which will represent the word groups the input tokens
			    belonged to (in the exact order they were accepted), and the sequence r<subscript>0</subscript>, r<subscript>1</subscript>, r<subscript>2</subscript> ... r<subscript>l-1</subscript>,
			    which will be the list of rules used to create the left derivation tree as described in the previous section.
			    <programlisting>
	      Helper function sci_said_recursive: S  V  (V &cup; &Sigma;)&lowast &rarr; Node
	      Parameters: s &isin S, Rule r &isin; V  (V &cup; &Sigma;): v<subscript>0</subscript> &rarr; v<subscript>1</subscript> v<subscript>2</subscript> ... v<subscript>i</subscript>
	      cn<subscript>mr</subscript> = cn<subscript>r</subscript>
	      Node n := s, v<subscript/0/
	      FOR j := 1 TO i
	      		IF (v<subscript/j/ &isin; &Sigma;) THEN
	      			n := n, &gamma;<subscript>cn<subscript>&gamma;</subscript></subscript>
	      			cn<subscript>&gamma;</subscript> := cn<subscript>&gamma;</subscript> + 1
	      		ELSE
	      			cn<subscript>oldr</subscript> := cn<subscript>r</subscript>
	      			cn<subscript>r</subscript> := cn<subscript>r</subscript> + 1
	      			n := n, sci_said_recursive(&sigma;<subscript>r<subscript>mr</subscript>,j</subscript>, r<subscript>cn<subscript>oldr</subscript></subscript>)
	      		FI
	      ROF
	      RETURN (n)


	      Helper function get_children: Node &rarr; Nodes&lowast;
			      get_children((s, v, n<subscript>0</subscript>, n<subscript>1</subscript> ... n<subscript>m</subscript>)) := n<subscript>0</subscript>, n<subscript>1</subscript> ... n<subscript>m</subscript>


	      Algorithm SCI-SAID-TREE
	      cn<subscript>&gamma;</subscript> := 0;
	      cn<subscript>r</subscript> := 1;
	      n<subscript>temp</subscript> := n<subscript>temp</subscript>, SCI-SAID-RECURSIVE(0, r<subscript>0</subscript>)
	      root(T<subscript>&Pi;</subscript>) := (141, 13f, get_children(n<subscript>temp</subscript>))
			    </programlisting>
			    Here is an example, based on the previous one:
			    <example><title/Semantic tree example/<blockquote><para>
	      k = 2:
	      &gamma;<subscript>0</subscript> = 842, &gamma;<subscript>1</subscript> = 917

	      l = 4
	      r<subscript>0</subscript> = 13c &rarr; 13b 134
	      &sigma;<subscript>r<subscript/0/,1</subscript> = 141, &sigma;<subscript>r<subscript/0/,2</subscript> = 142
	      r<subscript>1</subscript> = 13b &rarr; 131
	      &sigma;<subscript>r<subscript/1/,1</subscript> = 141
	      r<subscript>2</subscript> = 131 &rarr; C<subscript>80</subscript>
	      r<subscript>3</subscript> = 134 &rarr; C<subscript>10</subscript>

	      The resulting tree would look like this:

	      	(141 13f
	      		(141 13b
	      			(141 131 842)
	      		)
	      		(142 134 917)
	      	)
			    </para></blockquote></example>
			  </para>
			</sect3>
	</sect2>
	<sect2 ID="CRSaidSpec"><Title/Said specs/
		<para>
		  To test what the player wanted to say, SCI compares T<subscript>&Pi;</subscript> with a second tree, T<subscript>&Sigma;</subscript>, which is built
		  from a so-called Said spec. A Said spec is a variable-sized block in SCI memory which consists of a set of byte-sized operators and special tokens
		  (stored in the range 0xf0 to 0xf9) and word groups (in big-endian notation, so that they don't conflict with the operators); it is terminated by
		  the speial token 0xff. The meanings of the operators and special tokens are as follows:
		  <informaltable frame="all">
		    <tgroup cols="3">
		      <thead>
			<row>
			  <entry>Operator</entry>
			  <entry>Byte representation</entry>
			  <entry>Meaning</entry>
			</row>
		      </thead>
		      <tbody>
			<row>
			  <entry>,</entry>
			  <entry>f0</entry>
			  <entry>"OR". Used to specify alternatives to words, such as "take , get".</entry>
			</row>
			<row>
			  <entry>&amp;</entry>
			  <entry>f1</entry>
			  <entry>Unknown. Probably used for debugging.</entry>
			</row>
			<row>
			  <entry>/</entry>
			  <entry>f2</entry>
			  <entry>Sentence part separator. Only two of these tokens may be used, since sentences are split into a maximum of three parts.</entry>
			</row>
			<row>
			  <entry>(</entry>
			  <entry>f3</entry>
			  <entry>Used together with ')' for grouping</entry>
			</row>
			<row>
			  <entry>)</entry>
			  <entry>f4</entry>
			  <entry>See '('</entry>
			</row>
			<row>
			  <entry>[</entry>
			  <entry>f5</entry>
			  <entry>Used together with '[' for optional grouping. "[ a ]" means "either a or nothing"</entry>
			</row>
			<row>
			  <entry>]</entry>
			  <entry>f6</entry>
			  <entry>See '['.</entry>
			</row>
			<row>
			  <entry>#</entry>
			  <entry>f7</entry>
			  <entry>Unknown. Assumed to have been used exclusively for debugging, if at all.</entry>
			</row>
			<row>
			  <entry>&lt;</entry>
			  <entry>f8</entry>
			  <entry>Semantic reference operator (as in "get < up").</entry>
			</row>
			<row>
			  <entry>&gt;</entry>
			  <entry>f9</entry>
			  <entry>Instructs Said() not to claim the event passed to the previous Parse() call on a match. Used for successive matching.</entry>
			</row>
		      </tbody>
		    </tgroup>
		  </informaltable>
		</para>
		<para>
		  This sequence of operators and word groups is now used to build the Said tree T<subscript>&Sigma;</subscript>.
		  I will describe the algorithm used to generate T<subscript>&Sigma</subscript> by providing a grammar G<subscript>&Sigma;</subscript>, with
		  L(G<subscript>&Sigma;</subscript>) containing all valid Said specs. The semantics will be provided under each rule with a double arrow:
		  <programlisting>
	G<subscript>&Sigma;</subscript> = ({saidspec, optcont, leftspec, midspec, rightspec, word, cwordset, wordset, expr, cwordrefset, wordrefset, recref}, &Gamma;, P, saidspec)

	P := {
	  saidspec &rarr;	 leftspec optcont
				&rArr; (141 13f leftspec optcont)
			| leftspec midspec optcont
				&rArr; (141 13f leftspec midspec optcont)
			| leftspec midspec rightspec optcont
				&rArr; (141 13f leftspec midspec rightspec optcont)



	  optcont &rarr;	e
				&rArr;
			| >
				&rArr; (14b f900 f900)



	  leftspec &rarr;	e
				&rArr;
			| expr
				&rArr; (141 149 expr)



	  midspec &rarr;	 / expr
				&rArr; (142 14a expr)
			| [ / expr ]
				&rArr; (152 142 (142 14a expr))
			| /
				&rArr;



	  rightspec &rarr;	 / expr
				&rArr; (143 14a expr)
			| [ / expr ]
				&rArr; (152 143 (143 14a expr))
			| /
				&rArr;


	  word &rarr;	 &gamma; &isin; &Gamma;
				&rArr; (141 153 &gamma)


	  cwordset &rarr;	 wordset
				&rArr; (141 14f wordset)
			| [ wordset ]
				&rArr; (141 14f (152 14c (141 14f wordset)))


	  wordset &rarr;	 word
				&rArr; word
			| ( expr )
				&rArr; (141 14c expr)
			| wordset , wordset
				&rArr; wordset wordset
			| wordset , [ wordset ]
				&rArr; wordset wordset


	  expr &rarr;		 cwordset cwordrefset
				&rArr; cwordset cwordrefset
			| cwordset
				&rArr; cwordset
			| cwordrefset
				&rArr; cwordrefset
	

	  cwordrefset &rarr;	 wordrefset
				&rArr; wordrefset
			| [ wordrefset ]
				&rArr; (152 144 wordrefset)


	  wordrefset &rarr;	< wordset recref
				&rArr; (144 14f word) recref
			| < wordset
				&rArr; (144 14f word)
		        | < [ wordset ]
		                &rArr; (152 144 (144 14f wordset))


	  recref &rarr;	< wordset recref
				&rArr; (141 144 (144 14f wordset) recref)
			| < wordset
				&rArr; (141 144 (144 14f wordset))
	}
		  </programlisting>
		</para>
	</sect2>
	<sect2><title/Matching the trees/
		<para>
		  The exact algorithm used to compare T<subscript>&Pi;</subscript> to T<subscript>&Sigma;</subscript> is not known yet. The one described here is based
		  on the approximation used in FreeSCI, which is very similar to the original SCI one.
		</para>
		<para>
		  First, we need to describe a set of functions for traversing the nodes of T<subscript>&Sigma;</subscript> and T<subscript>&Pi;</subscript>, and doing
		  some work. They will be
		  operating on the sets N := { 0, i | (i - 1) &isin N } (all non-negative integral numbers), B := {tt, ff} (the boolean lattice with two elements), and
		  Nodes (which we defined earlier).
		  <blockquote><para>
	first: Node &rarr; S
		    first((s, v, n<subscript>0</subscript>, n<subscript/1/ ... n<subscript/i/)) := s
	    </para><para>

	second : Node &rarr; V
		    second((s, v, n<subscript>0</subscript>, n<subscript/1/ ... n<subscript/i/)) := v
	    </para><para>

	word : Node &rarr; &Gamma;
		    word((s, v, &gamma)) := &gamma;
	    </para><para>

	children : Node &rarr; Node&lowast;
		    children((s, v, n<subscript>0</subscript>, n<subscript/1/ ... n<subscript/i/)) := { m | &forall;m.m&isin;{ n<subscript>0</subscript>, n<subscript>1</subscript> ... n<subscript>i</subscript> } &and; m&isin;Node }
	    </para><para>

	all_children : Node &rarr; Node&lowast;
		    all_children(n) := children(n) &cup; { m | &exist;l.l&isin;all_children(n).m&isin;l }
	    </para><para>

	is_word : Node &rarr; B
		    is_word((s, v, n<subscript>0</subscript>, n<subscript/1/ ... n<subscript/i/) = tt &hArr; (i = 0) &and; n<subscript>0</subscript> &isin; &Gamma;
	    </para><para>

	contains_word : Node  S  &Gamma; &rarr; B
		    contains_word(n, s, &gamma;) = tt &gamma = 0xfff<footnote><para>This is the so-called "anyword". Words with
	      a word group of 0xfff match any other word.</para></footnote> &or; (&hArr; &exist;m.m&isin;all_children(n).(s = second(m)) &and (is_word(m) &and; (word(m) = &gamma)))
	    </para><para>

	verify_sentence_part_elements : Node  Node &rarr; B
		    verify_sentence_part_elements(n<subscript/p/, n<subscript/s/) = tt &hArr;
		    	(first(n<subscript/s/ = 152)
				&and; ((&forall;m.m &isin; Node.verify_sentence_part_elements(m, n<subscript/s/) &hArr; { w | &exist;t.t &isin; all_children(m).w = word(t)} = &empty;)
		    			&or; &exist;m &isin; children(n<subscript/s/).verify_sentence_part_elements(m, n<subscript/s/))
		    	) &or; ((second(n<subscript/s/) = 153)
				&and; (&exist;m.m &isin; children(n<subscript/s/).(&exist;o &isin; all_children(n<subscript/s/).(first(o) = first(n<subscript/p/)) &and word(o) = word(m)))
			) &or; ((second(n<subscript/s/) &isin; {144, 14c})
				&and; (&exist;m.m &isin; children(n<subscript/s/).verify_sentence_part(m, n<subscript/s/)))
	    </para><para>

	verify_sentence_part : Node  Node &rarr; B
		    verify_sentence_part(n<subscript/p/, n<subscript/s/) = tt &hArr; &forall;n.n &isin; children(n<subscript/s/):&exist;m.m&isin;children(n<subscript/p/).(first(m) = first(n)) &and; verify_sentence_part_elements(n, m)
	    </para><para>

	verify_sentence_part_brackets : Node  Node &rarr; B
		    verify_sentence_part_brackets(n<subscript/p/, n<subscript/s/) = tt &hArr;
				(first(n<subscript/p/) = 152 &and;
					 (&forall;m.m&isin;Node.(first(m) = first(n<subscript/s/)) &and (second(m) = second(n<subscript/s/)).
						verify_sentence_part(n<subscript/p/, m) &hArr; { w | &exist;t.t &isin; all_children(m).w = word(t)} = &empty;))
				&or; ((first(n<subscript/p/) &isin; {141, 142, 143}) &and; verify_sentence_part(n<subscript/p/, n<subscript/s/))

		  </para></blockquote>
		  With these functions, we can now define an algorithm for augmenting T<subscript>&Pi;</subscript> and T<subscript>&Sigma;</subscript>:
		  <blockquote><para>
	Algorithm SCI-AUGMENT

	matched := tt
	claim_on_match := tt

	FOREACH n &isin; root(T<subscript>&Sigma</subscript>)
		IF ((first(n) = 14b) &and; (second(n) = f900)) THEN claim_on_match := ff
		ELSE IF &not;verify_sentence_part_brackets(n, root(T<subscript>&Pi;</subscript>)) THEN
			matched := ff
	HCAEROF

		  </para></blockquote>
		  Augmenting succeeded if matched = tt; in this case, T<subscript>&Pi;</subscript> is one of the trees accepted by the description provided by T<subscript>&Sigma</subscript>.
		  In this case, Said() will return 1. It will also claim the event previously provided to Parse(), unless claim_on_match = ff.
		</para>
	</sect2>


  </sect1>
  <sect1 ID="LarsAnim"><title/Views and animation in SCI/
    <para>by <author><firstname/Lars/<surname/Skovlund/</author>
</para><para>
Version 0.1, 8. August 1999
</para><para>
This chapter deals with a rather complex subject within SCI. The subsystem
described here is one of the "bad boys" in SCI, since it calls functions in
user space, as well as changing the value of various selectors. This
document is not necessarily complete. There are several things I have not
covered - because they are better off in a separate document, or simply
because I haven't yet figured that part out. IOW, this stuff is incomplete.
Things may change.
</para><para>
After drawing a pic on the screen (which is DrawPic's job, that doesn't
surprise now, does it?), some views have to be added to it. There are two
ways of doing this; the AddToPic and the Animate call. While AddToPic is
used for static views, Animate lets each animated view in the cast list
perform an "animation cycle".
</para><para>
An animation cycle is done entirely in SCI code (with the aid of some kernel
calls). It involves two other objects; the mover and the cycler. The mover
is responsible for controlling the motion of an actor towards a specific
point, while the cycler changes the image of the actor, making him appear to
walk, for instance.
</para><para>
The behaviour of a view is controlled by its signal property. This property
contains a bitfield which describes a lot of animation-related stuff. The
bits can be roughly divided into two groups; the script and interpreter bits
(I had called them Option and State bits at first, but that is not entirely
accurate). The first group allows the script to influence the drawing pro-
cess somewhat, the other are used internally by the interpreter. The two
groups overlap a bit, though.
<simplelist>
<member/bit 0 - A view updating process has ended/
<member/bit 1 - The view object is being updated/
<member/bit 2 (noUpd) - Don't actually draw the view/
<member/bit 3 - The view is hidden from sight. Often, if an actor is supposed to
enter and exit a room (such as the guards in the plazas in QfG2), this bit 
is
used. When he's supposed to enter the room, bit 3 in his signal is cleared.
When he leaves, bit 3 is set, but his SCI object is not deleted./
<member/bit 4 (fixPriOn) - if this bit is set, the priority of the view never
changes (if it isn't, the interpreter recalculates the priority
automagically)./
<member/bit 7 - The view should be removed from the screen (an interpreter bit -
its corresponding script bit is bit 3). If bit 3 isn't set as well, the
view reappears on the next frame./
<member/bit 8 - deactivates the mover object of the view (it is "frozen" - the view
can still turn, however)./
<member/bit 9 (isExtra) - ??? probably reserved for script use ???/
<member/bit 10 - the view hit an obstacle on the last animation cycle/
<member/bit 11 - Meaningful for actors only. Means that the actor does not turn, 
even
though he is walking the "wrong way"./
<member/bit 12 - the view cycler is disabled. This makes ego float instead of
walk./
<member/bit 13 (ignoreHorizon) - Meaningful for actors only. Moving the actor 
towards
the edges of the screen doesn't cause a room switch. At least, that's what I
thought it would do. It doesn't. Hmmm. :-(/
<member/bit 14 (ignrAct) - Actors can walk in the rectangle occupied by the view.
The behaviour of this bit is odd, and best expressed by example. The Guild
Master in QfG1 has his bit 14 set. This means that ego (or someone else) can
walk all the way to his chair (try sneaking in on him from behind). If we
clear this bit, we can't sneak in on him./
<member/bit 15 - The view should be disposed/
</simplelist>
The unlisted bits are probably all interpreter bits. They don't seem to have
an effect when set. Many bits seem to be involved in the decision whether to
display a view or not. I have not completely figured this out.
<footnote><para>
The bit names I have written come from some debug information I got from
QfG2 - type "suck blue frog" then Ctrl-W to save the cast list!</para></footnote>
</para>
<para>
Animate (see <XREF LINKEND="KAnimate">) can be called in two ways:
<simplelist>
<member/Animate(DblList cast, bool cycle)/
<member/Animate()/
</simplelist>
If the second syntax is used, the two parameters are assumed to be zero.
</para><para>
The cast list is just a list of the views to draw. Animate creates a backup
of this list for updating purposes. However, this backup cast list isn't 
just
a normal copy. The interpreter copies some selectors from the view
(view, loop, cel, nsRect) and places them in a special data structure. This
indicates to me that there is a possibility that the view objects may be
deleted even though an update is anticipated.
</para><para>
The general pseudocode for Animate goes as follows:
<programlisting>
  1. Kill the backup cast list.
  2. If the cast pointer is NULL, just redraw the current map and exit.
  3. For each non-frozen view (bit 8 clear), let it run an animation cycle
     (by calling View::doit)
  6. For all views, perform steps 7-9.
  7. If the loop or cel property has overflowed, it is reset to 0
  8. Recalculate the priority of the view (only if signal bit 4 is clear).
  9. If the signal property indicates that we need to, increase (not set)
     the PicNotValid flag (several bits are involved in this;
     the exact combinations are a mess to figure out, I'll do it on 
     request).
  10. If PicNotValid != 0, draw all the static views (PicViews).
  11. Draw all non-PicViews, saving their rectangles first and storing a 
      memory handle in the underBits selector.
  12. Create a backup of the cast data.
  13. Remove the appropriate views from screen.
  14. Dispose the views which have their signal bit 15 set (calling
      View::delete)
</programlisting>
</para><para>
The algorithm for drawing PicViews is basically several loops:
(repeat all of the steps for each view)
<programlisting>
  1. If signal bit 2 is clear, jump to 4
  2. If bit 0 is set, clear it and set bit 2 instead.
  3. Continue with the next view.
  4. If signal bit 7 is set, jump to 8.
  5. If PicNotValid == 1, jump to 7.
  6. Restore the view rectangle using the memory handle stored in UnderBits
     (must be != 0, of course).
  7. Free the memory used by underBits and zero out the selector afterwards.
  8. Clear bit 6 of the signal
  9. If bit 1 is set, clear it and bit 2.
</programlisting><programlisting>
  1. Load and draw the view
  2. Clear signal bits 0, 1, 2, 6.
  3. If signal bit 14 is set, skip to the next rectangle
  4. Copy the view nsRect into a temporary variable.
  5. Find the start of the priority band specified by the priority selector.
  6. If it is greater than the nsRect top, set the top of our temp rectangle
     to the nsRect top.
  7. If the top is now below the bottom, set the top = the bottom.
  8. Draw the temp rectangle onto the control map using white color.
</programlisting>
</para>
<note><para>
The ReAnimate subfunction (0x0D) of the Graph kernel call redraws parts of
the maps using the cast list created by Animate, whereas the ShowBits call
(0x0C) copies parts of the active map to the physical screen.
</para></note>

  </sect1>
</Chapter>


<Chapter>
  <Title/FreeSCI/
     <Sect1>
        <Title/Basic differences to Sierra's SCI/
       <para>
          Sierra's SCI engine, written back in the late 80s, was designed and built to be
          fast and efficient. Some evil compromises were made (especially in the animation
          cycle) that sacrificed cleanness for extra cycles. Also, it was designed to use only
          a very limited amount of memory, which led to more compromises.
       </para><para>
          The primary design goal of FreeSCI, on the other hand, was Portability. Written in
          the late 90s, memory constraints were practically nonexistant, since all game data
          could easily be stored in memory<footnote><para>This is not true for the speech support
          some of the later SCI1 and SCI32/SCIWin come with, of course. At the time of this writing,
          SCI1 support is still non-existant, but later versions of FreeSCI will have to allow
          for dynamical loading of cdaudio resources.</para></footnote>. Thus, resource loading
          and hunk memory management is of no importance to FreeSCI. The kernel call "Load", which
          is used to load a resource to hunk space, simply returns the resource identifier of the
          resource it is supposed to load, as opposed to a pointer to a pointer to hunk memory.
       </para><para>
          Apart from that, FreeSCI simply abuses the fact that SCI was designed to be used by
          various different graphics adapters and sound devices. The graphics and sound
          commands each had to be interpreted by the currently active sound and graphics drivers,
          and FreeSCI does nothing more than to interpret them in its own way.
       </para><para>
          Of course, FreeSCI has to accomodate for versions differences between different SCI builds.
          These are generally minor issues (like the default alignment of text), but they have to
          be taken care of in one single program, as opposed to several builds as in the case of
          Sierra's SCI (some SCI games still ship with old versions of the interpreter, because they
          assume default values that were changed later on).
       </para><para>
          Finally, there is the built-in debugger. Sierra SCI used a quick and efficient design, while
          FreeSCI provides a Command-line interface to the debugger, and several additional commands.
       </para>
     </Sect1>
     <Sect1>
        <Title/The built-in debugger/
           <sect2>
              <Title/Concepts and basic functionality/
              <para>
                 The built-in debugger takes advantage of a built-in command interpreter (which
                 is not to be confused with the SCI command interpreter). It's appearance is
                 going to vary in between versions (at the time of this writing, it runs on the
                 terminal FreeSCI was started on, in text mode; later versions will likely integrate
                 the debugger to the graphics screen), but all versions of FreeSCI will come with
                 a working debugger<footnote><para/That's what I hope, anyway./</footnote>. Consult the
                 documentation of your specific release for details on how to invoke it, if it is not
                 activated automatically.
              </para><para>
                 If activated, the debugger is called in between operation fetching and operation
                 execution. It will show the command that is to be executed next, predicting the
                 action done by send, super, and self calls where possible, and displaying any
                 parameters to calling operations. It will also display the current register values
                 and the number of operations that have been executed. It then waits for user input.
              </para><para>
                 In order to simply execute the next operation, execute the "<function/s/" command.
                 This will do one step of execution. If you want to execute more than one command,
                 invoke "<function/s [number-of-steps]/". Other ways to step forward are
                 "<function/snk/" (Step until the Next Kernel function is invoked) and "function/sret/"
                 (Step until the interpreter RETurns from this function).
              </para><para>
                 Speaking of functions, the FreeSCI interpreter also keeps a list of the call stack.
                 This is similar to what the Sierra SCI interpreter provides as the "send stack", but
                 it also includes call, calle and callb commands. Please note that callk commands are
                 not included (some kernel functions actually call functions in user space). To
                 display this list, invoke "<function/bt/". This function will list all calls on
                 the stack, the parameters they carried, from where they were invoked, and the called
                 object<footnote><para>This is note quite correct: The object listed is, in fact, the
                 object which is used as the base object for execution. This only makes a difference
                 if the <function/super/ operation is executed, but it may be confusing. Consider it
                 a bug.</para></footnote> and selector (where applicable).
              </para><para>
                 Selectors are not only used for functions, of course, they are also used as
                 variables. To inspect the selectors of the current object, use the "<function/obj/"
                 operation. Sometimes you might want to inspect how a send operation influenced an
                 object; do so by calling "<function/accobj/", which will show the selectors of the
                 object indexed by the accumulator register (as used in sends).
              </para><para>
                 For a complete listing of debugging commands, refer to the next chapter.
              </para>
           </Sect2>
           <Sect2>
              <Title/Debugger commands/
              <para>
                 The FreeSCI built-in debugger provides the following commands:
              </para>
              <sect3><Title/accobj/
                <para>
                   The send operation requires a target object, which needs to be stored in the
                   accumulator. This operation makes it possible to check if there is an object
                   at the location indexed by acc, and, if it is, dump the type of object (Class,
                   Object, or Clone), the object's name, and some other interesting stuff (selector
                   names and values, funcselector names and addresses).
                </para>
              </sect3>
              <sect3><title/bpdel (index)/
                <para>
                  Deletes a breakpoint from the specified index of the list of active breakpoints.
                </para>
              </sect3>
	      <sect3><title>bpe (script, index)</title>
	      <para>
		Add a breakpoint terminating when the specified exported function of a script is called
	      </para>
	      </sect3>
              <sect3><title/bplist/
                <para>
                  Lists all active breakpoints.
                </para>
              </sect3>
              <sect3><title/bpx (method)/
                <para>
                  Adds a breakpoint to the specified method.
                </para>
              </sect3>
              <sect3><Title/bt/
                <para>
                   Backtrace: Shows the execution stack, bundled with call parameters and selector
                   names where appropriate.
                </para>
              </sect3>
              <sect3><Title/classtable/
                <para>
                   One of the nice things about FreeSCI is that it doesn't hide its class table as
                   Sierra SCI appears to do. With this command, you have the power to unravel the
                   mysteries of classes and superclasses at your fingertips.
                </para>
              </sect3>
              <sect3><Title/clonetable/
                <para>
                   FreeSCI doesn't take Clone()ing lightly. It carefully notes which clone was
                   created and tracks its current position. This function allows you to find them
                   all, and in the darkness bind them.
                </para>
              </sect3>
              <sect3><title/debuglog [mode]/
                <para>
                   FreeSCI keeps an internal list of flags for specific areas of the game that
                   should be watched more closely. The 'debuglog' command activates or deactivates
                   debug output for each of those areas. Each area is described by a letter; to
                   activate debugging for that area, use "debuglog +x", where x is the area you
                   want to debug. "debuglog -x" deactivates debugging for that area. To activate or
                   deactivate multiple areas, concatenate their single-letter descriptions. Run
                   "debuglog" without parameters to get a listing of all active modes. The modes
                   and describing letters are listed below.
                    <simplelist>
                     <member/a: The audio subsystem/
                     <member/b: The Bresenham line algorithm functions/
                     <member/c: Character and string handling/
                     <member/d: System graphics display and management/
                     <member/f: Function calls/
		     <member/F: File IO/
                     <member/g: Graphics/
                     <member/l: List and node handling/
                     <member/m: Memory management/
                     <member/M: Menu system/
                     <member/p: The command parser/
                     <member/s: Base setter: Draws the bases of each actor as colored rectangles/
		     <member/S: Said specs/
		     <member/t: Time functions/
                     <member/u: Unimplemented functionality/
                     <member/*: Everything at once. Use with care./
                   </simplelist>
                </para>
              </sect3>
	      <sect3><title/die/
		<para>
		  Exits the interpreter ungracefully.
		</para>
	      </sect3>
              <sect3><Title/disasm (address) [number]/
                <para>
                   The debugger is able to disassemble code parts on the fly. Just give it an
                   <parameter/address/ to dissassemble (and a <parameter/number/ of commands to
                   dump, if you're feeling bold enough to look at more than one of them
                   simultaneously). Unfortunately, it can only do send prediction and parameter
                   resolution if it is disassembling the PC.
                </para>
              </sect3>
	      <sect3><title/dissectscript (script))/
		<para>
		  Dumps a script resource (with the specified number) and examines it. Lists classes,
		  static objects, relocation tables, and all the other stuff contained in scripts.
		</para>
	      </sect3>
	      <sect3>
		<title>dm_*</title>
		<para>
		  These are dmalloc utility functions. They are described in the
		  dmalloc section below.
	      </sect3>
	      <sect3>
		<title>draw_viewobj (object)</title>
		<para>
		  This operation draws the boundaries of the cel described by the
		  indicated SCI object to the screen. The nsRect is drawn in green,
		  the brRect in dark blue, and the position is marked by a small cross
		  in the cel's priority, within a black box.
		</para>
	      </sect3>
	      <sect3><title/dump (restype, resnr)/
		<para>
		  Displays a hex dump of the specified resource.
		</para>
	      </sect3>
              <sect3><title/dumpnodes (index)/
                <para>
                  Lists up to <parameter/index/ nodes of the parse tree.
                </para>
              </sect3>
	      <sect3><title>dumpwords</title>
	      <para>
		Lists all parser words
	      </para>
	      </sect3>
	      <sect3><title>gfx_current_port</title>
	      <para>
		Prints the port ID of the current port.
	      </para>
	      </sect3>
	      <sect3><title>gfx_draw_cel (view) (loop) (cel)</title>
	      <para>
		Draws a single cel to the center of the screen (augmented by the cel's delta-x and -y values). Depending on your
		graphics driver, you may have to refresh the screen for this to become visible.
	      </para>
	      </sect3>
	      <sect3><title>gfx_draw_rect (x) (y) (width) (height) (color)</title>
	      <para>
		Draws a single rectangle to the screen. The <literal>color</literal> parameter describes an EGA color (0-15) which
		will be the rectagle's color'
	      </para>
	      </sect3>
	      <sect3><title>gfx_drawpic (pic) [palette] [flags]</title>
	      <para>
		Renders a pic resource. The <emphasis>palette</emphasis> value specifies the pic's palette to use; if not specified, 0 will be assumed.
		<emphasis>flags</emphasis> set any of the pic drawing flags used in the operational layer (see <xref linkend="fsci-gfx-op"/>).
	      </para>
	      </sect3>
	      <sect3><title>gfx_fill_screen (color)</title>
	      <para>
		Fills the entire screen (visual back and front buffer) with an EGA color.
	      </para>
	      </sect3>
	      <sect3><title>gfx_free_widgets</title>
	      <para>
		This will free the main visual widget and all widgets it contains. Since it essentially invalidates the structured
		representation of the screen content, this will make the interpreter run into segfaults if you resume. It is intended
		for memory profiling and heap testing.
	      </para>
	      </sect3>
	      <sect3><title>gfx_print_dynviews</title>
	      <para>
		Prints the current dynview list. This list is generated by the Animate() kernel call and represents the visual state of
		all dynamical images on the screen.
		Documentation regarding the meaning of the widget descriptions can be found in <xref linkend="fsci-gfx-widgets-string">.
	      </para>
	      </sect3>
	      <sect3><title>gfx_print_port [port]</title>
	      <para>
		Dumps the contents of the port specified (or, if omitted, the current port) to the output stream.
		Documentation regarding the meaning of the widget descriptions can be found in <xref linkend="fsci-gfx-widgets-string">.
	      </para>
	      </sect3>
	      <sect3><title>gfx_print_visual</title>
	      <para>
		Prints the visual widget, and, recursively, its contents; this widget is the root widget, therefore, the structured
		representation of all graphical information will be print.
		Documentation regarding the meaning of the widget descriptions can be found in <xref linkend="fsci-gfx-widgets-string">.
	      </para>
	      </sect3>
	      <sect3><title>gfx_widget [widget]</title>
	      <para>
		(This function is only available if the interpreter was compiled with widget debugging enabled)
	      </para>
	      <para>
		If the parameter is not specified, this will print a list of all used widget debug slots (each widget goes into
		exactly one slot); if the parameter is specified, it is used as an index in the widget debug slot list, causing
		the corresponding widget to be print.
		Documentation regarding the meaning of the widget descriptions can be found in <xref linkend="fsci-gfx-widgets-string">.
	      </para>
	      </sect3>
	      <sect3><title>gfx_priority [priority]</title>
	      <para>
		If no parameter is supplied, the start and end values of the priority line list will be print. Otherwise, this function
		prints the first line of the specified priority region.
	      </para>
	      </sect3>
	      <sect3><title>gfx_show_map [nr]</title>
	      <para>
		Draws one of the screen maps to the visual back buffer and updates the front buffer. The maps are numbered as follows:
		<simplelist>
		  <member>0: Visual buffer</member>
		  <member>1: Priority buffer (z buffer)</member>
		  <member>2: Control buffer</member>
		</simplelist>
		Buffers 1 and 2 will be rendered in EGA colors, with color values representing the associated priority/control values
		(this is identical to Sierra SCI behaviour).
	      </para>
	      </sect3>
	      <sect3><title>gfx_update_zone (x) (y) (width) (height)</title>
	      <para>
		Propagates a rectangle from the back buffer to the front buffer; the rectangle's origin and dimensions are passed as
		parameters.
	      </para>
	      </sect3>
	      <sect3><title/gnf/
		<para>
		  Lists the rules of the GNF grammar used internally in FreeSCI to parse input.
		</para>
	      </sect3>
              <sect3><title/go/
                <para>
                  Deactivates debug mode and runs the game. Debug mode can be re-activated in the
                  usual ways.
                </para>
              </sect3>
              <sect3><Title/heapdump (address) (number)/
                <para>
                   Invoking this function will spit out <parameter/number/ bytes, starting at
                   <parameter/address/.
                </para>
              </sect3>
              <sect3><Title/heapdump_all/
                <para>
		  Prints all heap segments, including information whether they are allocated or not.
                </para>
              </sect3>
              <sect3><Title/heapfree/
                <para>
                   Dumps a list of the free heap space (free, not gratis).
                </para>
              </sect3>
              <sect3><Title/heapobj (address)/
                <para>
                   This is the same as <function/accobj/, but it can interpret any object on the
                   heap. Note that the "home" address of objects (as used here) are 8 bytes into
                   the object structure (which starts with the magic number 0x34 0x12), and points
                   to the first (zeroeth?) selector.
                </para>
              </sect3>
	      <sect3><title/hexgrep (resource, hex 2-tuples+)/
		<para>
		  Searches for a list of hexadecimal numbers inside a single resource (if specified
		  like "script.042"), or in a set of resources (if specified like "pic").
		</para>
	      </sect3>
	      <sect3><title/kernelnames/
		<para>
		  Lists all kernel function names
		</para>
	      </sect3>
	      <sect3><title/list (string+)/
		<para>
		  If called without parameters, it lists all things it can list. Among these
		  are:
		  <simplelist>
		    <member/vars: Global interpreter variables/
		    <member/cmds: All available commands/
		    <member/restypes: All resource types/
		    <member/[restype]: All resources of that type/
		  </simplelist>
		</para>
	      </sect3>
	      <sect3><title/list_sentence_fragments/
		<para>
		  Lists all parser rules in their normal almost-CNF representation.
		</para>
	      </sect3>
              <sect3><Title/listinfo (address)/
                <para>
                   So FreeSCI doesn't have an interactive list debugger as in Sierra SCI. But it has
                   something better<footnote><para/Well, this is debatable./</footnote>: A list
                   dumper, which lists all list elements, keys, and heap positions.
                </para>
              </sect3>
	      <sect3><title/man (command)/
		<para>
		  Shows a short descriptive message to the command.
		</para>
	      </sect3>
	      <sect3><title/meminfo/
		<para>
		  Prints information about heap and hunk memory allocation.
		</para>
	      </sect3>
              <sect3><Title/obj/
                <para>
                   This is, in essence, the same function as <function/accobj/, but it checks the
                   current base object as opposed to the object indexed by the accumulator.
                </para>
              </sect3>
	      <sect3><title/objs/
		<para>
		  Lists all objects, classes, and clones that are currently on the stack. They are
		  identified by their properties, and prefixed with an asterisk ('*') if they are clones,
		  or a percent sign ('%') if they are classes.
	      <sect3><title/parse (string)/
		<para>
		  Attempts to parse a single string, and displays the word groups, word classes
		  and the resulting parse tree, if successful.
		</para>
	      </sect3>
	      <sect3><title/print (variable)/
		<para>
		  Prints the contents of one global interpreter variable.
		</para>
	      </sect3>
	      <sect3><title/quit/
		<para>
		  Exits the interpreter gracefully, by shutting down all resources manually.
		</para>
	      </sect3>
              <sect3><Title/redraw_screen/
                <para>
                   This function retrieves the background picture, puts it on the foreground, and
                   redraws everything. It's not inherently useful, though.
                </para>
              </sect3>
              <sect3><Title/registers/
                <para>
                   This function will show the current values of the program counter, the
                   accumulator, the frame pointer, the stack pointer, the prev register,
                   and the &amp;rest modifier. It will also print the addresses of the current
                   base object, of the global variables, and of the stack.
                </para>
              </sect3>
              <sect3><Title/resource_id (number)/
                <para>
                   FreeSCI packs resource type and number into the usual resource id combination.
                   Use this little helper function to unpack it.
                </para>
              </sect3>
	      <sect3><title/restart [string]]/
		<para>
		  Forces a restart of the current game. The string parameter is meaningless now.
		</para>
	      </sect3>
              <sect3><title/restore_game (name)/
                <para>
                  Tries to restore a game state from the specified directory. See <xref
                  linkend="freesci-savegames"> for details about this.
                </para>
              </sect3>
              <sect3><Title/s [number]/
                <para>
                   This function will execute <parameter/number/ steps, or one if number was not
                   specified.
                </para>
              </sect3>
              <sect3><title/save_game (name)/
                <para>
                  Saves the current game state to a directory with the specified <parameter/name/.
                  The directory is created automatically; everything inside is deleted, and the
                  game data is stored. See <xref linkend="freesci-savegames"> for details about this.
                </para>
              </sect3>
	      <sect3><title/scripttable/
		<para>
		  Lists all scripts that have been loaded, their positions in memory, and the position
		  of their local variables and exports.
		</para>
	      </sect3>
	      <sect3><title>se</title>
		<para>
		  Steps forward until an SCI keyboard event is received.
		</para>
	      </sect3>
	      <sect3><title/selectornames/
		<para>
		  Displays the names of all selectors.
		</para>
	      </sect3>
	      <sect3><title/set (variable, int)/
		<para>
		  Sets the specified variable to a new value. Most commonly used to set color_mode.
		</para>
	      </sect3>
              <sect3><Title/set_acc (number)/
                <para>
                   Frobbing the accumulator is not recommended, but it may be fun at times. Use this
                   command to set your favourite register to an arbitrary value and watch things blow
                   up.
                </para>
              </sect3>
	      <sect3><title/set_parse_nodes/
		<para>
		  Sets the nodes of the parse tree, and shows the result in list representation.
		  Useful to display information gathered from a certain hacked version of Sierra's SCI
		  interpreter in a more readable fashion.
		</para>
	      </sect3>
              <sect3><title/set_vismap (mapnr)/
                <para>
                  Sets the visual display map. Mapnr can be any of the following:
                  <simplelist>
                    <member/0: Visual map/
                    <member/1: Priority map/
                    <member/2: Control map/
                    <member>4: Auxiliary map
                        <footnote><para/Not really meaningful; only used while pic
                                        resources are drawn./</footnote></member>
                  </simplelist>
		  This function is a no-op since FreeSCI 0.3.1.
                </para>
              </sect3>
              <sect3><title/simkey (keynr)/
                <para>
                  Simulates a keypress of a key with the specified key number. Modifiers are
                  not applied.
                </para>
              </sect3>
	      <sect3><title/size (restype, resnr)/
		<para>
		  Displays the total byte size of one single resource.
		</para>
	      </sect3>
	      <sect3>
		<title>snd ...</title>
		<para>
		  This executes a sound command. Due to the nature of pipelining
		  between the sound server and the interpreter, it is possible that
		  the result messages of those operations will not be print
		  immediately, so you may have to issue a second command in order
		  for the results of the first command to be displayed.
		</para>
		<para>
		  Also, please note that after entering the debug console, the sound
		  server is, by default, suspended, so you will have to issue an
		  explicit <userinput>snd resume</userinput> to do anything useful.
		</para>
	      </sect3>
	      <sect3>
		<title>snd stop</title>
		<para>
		  Suspends the sound server. This is the opposite of 'snd resume'.
		</para>
	      </sect3>
	      <sect3>
		<title>snd resume</title>
		<para>
		  Resumes the sound server after it has been suspended.
		</para>
	      </sect3>
	      <sect3>
		<title>snd play (song)</title>
		<para>
		  Instructs the sound server to play the indicated song with a handle
		  of 42.
		</para>
	      </sect3>
	      <sect3>
		<title>snd mute_channel (channel)</title>
		<para>
		  Mutes the indicated MIDI channel; events sent to this channel will be
		  discarded before they reach the sound hardware.
		</para>
	      </sect3>
	      <sect3>
		<title>snd unmute_channel (channel)</title>
		<para>
		  Undoes a previous 'mute_channel' command, or part of a previous 'snd mute'
		</para>
	      </sect3>
	      <sect3>
		<title>snd mute</title>
		<para>
		  Mutes all channels (as per 'snd mute_channel')
		</para>
	      </sect3>
	      <sect3>
		<title>snd unmute</title>
		<para>
		  Unmutes all channels (as per 'snd unmute_channel')
		</para>
	      </sect3>
	      <sect3>
		<title>snd solo (channel)</title>
		<para>
		  Mutes all but one channel
		</para>
	      </sect3>
	      <sect3>
		<title>snd printchannels</title>
		<para>
		  Lists all channels, and the instruments currently playing on them
		</para>
	      </sect3>
	      <sect3>
		<title>snd printmaps</title>
		<para>
		  Prints the instrument names and all General MIDI mappings for
		  the song currently playing. This operation will only work correctly
		  if MT-32 to General MIDI translation is being performed.
		</para>
	      </sect3>
	      <sect3>
		<title>sndmap ...</title>
		<para>
		  Executes sound mapping commands.
		</para>
	      </sect3>
	      <sect3>
		<title>snd songid</title>
		<para>
		  Retreives the numerical ID of the song currently playing from the sound
		  server. Songs started with 'snd play' have a song ID of 42.
		</para>
	      </sect3>
              <sect3><Title/snk [number]/
                <para>
                   Another step command: Step until the interpreter hits a callk command. If you're
                   hunting for a very specific kernel call, just add its number as a parameter.
                   Syscall hunting has never been so easy.
                </para>
              </sect3>
	      <sect3><title/so/
		<para>
		  "Steps over" one instruction, i.e. continues executing until that instruction
		  has been completed (useful for send, call, and related functions)
		</para>
	      </sect3>
              <sect3><Title/sret/
                <para>
                   Step until RETurning. If you're bored of the function you're debugging, just invoke
                   this command. It will step forward until the current function returns.
                </para>
              </sect3>
              <sect3><Title/stack (number)/
                <para>
                   Can't remember what you pushed on that stack, and in which order? This command
                   will display as many stack elements as you want, starting at the TOS.
                </para>
              </sect3>
	      <sect3><title/version/
		<para>
		  Displays the interpreter and SCI game versions
		</para>
	      </sect3>
              <sect3><Title/viewinfo (number)/
                <para>
                   Examines the specified view resource and displays the number of loops it has,
                   the number of cels for each loop, and the size for each cel.
                </para>
              </sect3>
	      <sect3><title/vmvarlist/
		<para>
		  Lists the heap positions of the current global, local, parameter, and temporary
		  variables.
		</para>
	      </sect3>
	      <sect3><title/vmvars (type) (index) [value])/
		<para>
		  Reads or sets a global, local, temporary, or parameter value. Type must be any of
		  'g', 'l', 'p', 't', to select global, local, parameter or temporary variables
		  (respectively), while index represents the variable index. If value is not provided,
		  that variable will be displayed; otherwise, it will be set to value.
		</para>
	      </sect3>
           </Sect2>
	   <sect2><title>Console interaction with dmalloc</title> 
	     <para>
	       The FreeSCI console proivdes an interface to the dmalloc memory debugger/profiler, if
	       the interpreter was compiled with dmalloc support enabled. The following commands are
	       provided:
	     </para>
	     <sect3><title>dm_log_heap</title>
	       <para>
		 Prints the current heap state into the dmalloc log file
	       </para>
	     </sect3>
	     <sect3><title>dm_stats</title>
	       <para>
		 Prints memory usage statistics to the output file
	       </para>
	     </sect3>
	     <sect3><title>dm_log_unfreed</title>
	       <para>
		 Lists unfreed pointers in the dmalloc output file
	       </para>
	     </sect3>
	     <sect3><title>dm_verify (pointer)</title>
	       <para>
		 Verifies a pointer and prints the result to the dmalloc output file. Specifying 0 instead
		 of a pointer will verify all pointers currently known to dmalloc.
	       </para>
	     </sect3>
	     <sect3><title>dm_debug (mode)</title>
	       <para>
		 Sets the dmalloc debug flags (please refer to the dmalloc documentation for a description)
	       </para>
	     </sect3>
	     <sect3><title>dm_mark</title>
	       <para>
		 Gets a mark describing the current heap situation (see also 'dm_chmark')
	       </para>
	     </sect3>
	     <sect3><title>dm_chmark (mark)</title>
	       <para>
		 Compares a mark retreived by 'dm_mark' with the current heap situation, and prints the
		 results to the dmalloc output file.
	       </para>
	     </sect3>
	     <sect3><title>dm_print (output)</title>
	       <para>
		 Prints arbitrary output to the dmalloc output file
	       </para>
	     </sect3>
	   </sect2>
     </Sect1>
     <sect1 id = "freesci-savegames">
        <title/Savegames/
        <para>
           FreeSCI attempts to store savegames portably; for this reason, most of the game data
           is saved as plain text, while the graphics are written to png<footnote>
           <para/Portable Network Graphics. A very portable graphics format with lossless compression,
           a free reference implementation, and dozens of useful features./</footnote> files.
        </para>
        <sect2><Title/Savegame directory policy/
           <para>
             The general FreeSCI directory policy is simple: If there is a $HOME, use
             ~/.freesci/[game name]/ as your playground, if there is no home, use the current
             working directory. Savegames are true to that policy. Each save game has a directory
             associated with itself, and this directory is relative to the directory mentioned above.
             For example, if you execute "save_game frobnitz" in SQ3 on your *BSD box while
             your $HOME is set to /home/rogerw, the save game files would be written to
             /home/rogerw/.freesci/SQ3/frobnitz/.
           </para>
        </sect2>
        <sect2><Title/Files/
           <sect3><Title/state/
             <para>
               This is the main save file. It contains huge amounts of text data, which are
               an almost-complete replication of the game internal state_t structure. The code
               used to read and write this file is automatically generated by a script called
               cfsml.pl, and it is believed to be rather flexible; i.e. you should be able to
               insert blank lines, comment lines, (Using the hash ('#') sign), move assignements
               around, and change values. The identifiers used in this file are identical to the
               identifiers used in the c code.
             </para>
           </sect3>
           <sect3><Title/heap/
             <para>
               This is a binary copy of the heap data. Heap data is internally structured to be
               identical to SCI heap data (little endian, 16 bit), so it is portable to all platforms.
             </para>
           </sect3>
           <sect3><Title/hunk*/
             <para>
               These files contain raw hunk data. SCI code may allocate raw hunk data, but
               it can't do anything with it (except unallocate it again). It is unlikely that you
               are going to encounter a hunk file in normal SCI code. This may change for later SCI
               versions.
             </para>
           </sect3>
	   <sect3><title>song.*</title>
	   <para>
	     Songs stored by the sound subsystem.
	   </para>
	 </sect3>
	   <sect3><title>sound</title>
	   <para>
	     Contains the state of the sound subsystem. The syntax is identical to the used in the "state" file.
	   </para>
	 </sect3>
	 <sect3><title>*.id</title>
	 <para>
	   Savegame name file for one SCI game. The file names are chosen by taking the game's "unique" identifier and
	   appending a suffix of ".id". This file contains the savegame name in plain text.
	 </sect2>
	 <sect2><title>Obsolete files</title>
	 <para>
	   The following files were generated by earlier versions of FreeSCI, but are no longer used:
	 <sect3><Title/*map.png/
             <para>
               The four maps of the main picture are stored in four separate png files:
               <simplelist>
                 <member/visual_map.png/
                 <member/priority_map.png/
                 <member/control_map.png/
                 <member/auxiliary_map.png/
               </simplelist>
               The meanings of those files should be rather obvious.
             </para>
             <para>
               visual_map.png contains regular palette or color information, so it is, in fact,
               a screenshot of the game (the mouse pointer is not shown, since it is not stored
               in the display maps). The other three png files each contain a greyscale gradient
               palette.
             </para>
           </sect3>
           <sect3><Title/buffer*/
             <para>
               These are png files containing the various graphical buffers used in the game.
               buffer_x.1 is the visual buffer, buffer_x.2 is the priority buffer, and buffer_x.4
               is the control buffer. Any combination of these three buffers is possible.
             </para>
             <para>
               Control and priority buffers contain a grayscale gradient palette.
             </para>
           </sect3>
	 </sect2>
        <sect2><Title/Caveats/
           <para>
               FreeSCI's file saving and restoration functionality isn't perfect. Please be aware
               of the following flaws and limitations before you dig out your flame thrower:
           </para>
           <sect3><Title/File handles/
              <para>
                Open file handles are NOT stored or loaded. If you try to save the game with
                the built-in debugger while file handles are still open, you will be warned
                about this and saving will abort, unless you preceed your save directory name
                with an underscore ('_').
              </para>
           </sect3>
           <sect3><Title/Kernel functions/
              <para>
                 SCI kernel functions are able to call the virtual machine. In practice, this
                 means that you may have two or more vm function calls on your system stack;
                 it is not easily possible to store the game state in this case. FreeSCI does not
                 allow it, and, as far as I know, no Sierra SCI code ever tries to do that.
              </para>
              <para>
                 To determine whether or not this applies to you, run
                 "bt" in the debugger; the "base" number in the first line must be zero, or you won't
                 be able to save the game (restoring should work, though).
              </para>
           </sect3>
        </sect2>
     </sect1>

     <sect1>
       <title>The graphics subsystem</title>
       <para>Christoph Reichenbach, April 2nd, 2000</para>
       <para>
	 Up until version 0.3.0, FreeSCI used a graphics subsystem which used per-pixel operations on
	 three 320x200 8 bit buffers. This concept, while being simple to implement for driver writers,
	 proved to have several disadvantages:
	 <simplelist>
	   <member>Non-native memory layout: Using a fixed 8bpp visual buffer meant that, for each
	     update, all graphics would have to be translated to the graphics driver's native format,
	     unless it already was running in 8bpp.</member>
	   <member>No use of accellerated drawing functions: Many of the targetted graphics drivers
	     supported hardware-accelerated drawing of rectangles or lines; this could not be taken
	     advantage of, due to the per-pixel access</member>
	   <member>Scalability moved to the drivers: Each driver would have to take care of
	     magnifying the resulting picture by itself (if it wanted to support it at all), since
	     the base buffer was at a fixed size.</member>
	   <member>Manual graphics buffer access: This was in fact used in many places, making it
	     hard to keep track of modifications, which, in turn, would have inhibited attempts to
	     track modifications of the visual buffer. However, without those, either each drawing
	     operation would have enforce an update, causing flickering in the general case, or
	     the full screen would have to be re-drawn each time (which was what actually was done),
	     resulting in major performance penalites, especially for remote displays.
	   </member>
	 </simplelist>
	 Combined with some cases of code rot, these problems suggested a re-write of the complete
	 graphics subsystem, and a more modular re-design in preparation for supporting later revisions
	 of SCI (and, possibly, related engines such as AGI).
       </para>
       <para>
	 This documentation section will describe the architecture and functionality of the new
	 graphics subsystem, which has been in operation since FreeSCI 0.3.1. I will start by giving
	 a general overview of the various components involved and how they interact, and then
	 give a more detailed description of each of those components in sequence.
       </para>
       <sect2><title>Architecture</title>
       <para>
	 In extension of the architecture used up until FreeSCI 0.3.0, the new graphics subsystem now
	 uses a total of six buffers:
	 <informaltable frame="none">
	   <tgroup cols="4">
	     <thead>
	       <row>
		 <entry>Map Name</entry>
		 <entry># of buffers</entry>
		 <entry>scaled</entry>
		 <entry>bpp</entry>
	       </row>
	     </thead>
	     <tbody>
	       <row>
		 <entry>visual</entry>
		 <entry>3</entry>
		 <entry>yes</entry>
		 <entry>determined by driver</entry>
	       </row>
	       <row>
		 <entry>priority</entry>
		 <entry>2</entry>
		 <entry>yes</entry>
		 <entry>8</entry>
	       </row>
	       <row>
		 <entry>control</entry>
		 <entry>1</entry>
		 <entry>no</entry>
		 <entry>8</entry>
	       </row>
	     </tbody>
	   </tgroup>
	 </informaltable>

	 Of these, the visual and priority buffers have to be provided by the graphics driver, since
	 they are relevant for display and may actually be present physically (since the priority map
	 is nothing other than a Z buffer). The control map, a special buffer used by the interpreter
	 to check whether moving objects hit obstacles on the screen or touch zones with special meanings,
	 is only relevant for the interpreter and therefore handled one level above the graphics driver.
       </para>
       <para>
	 I will refer to the level above as the "operational layer". This layer handles all of the primitive
	 graphical operations. It performs clipping, keeps track of modified regions, and emulates functions
	 required but not supported natively by the graphics driver.
       </para>
       <para>
	 The operational layer is also responsible for the four pixmap operations, which draw background
	 pictures, images, text, or mouse pointers. These pointers are only referred to by their respective
	 ID numbers; they are retreived from the graphical resource manager. This graphical resource manager
	 (GRM) is another separate subsystem- it retreives graphical resources in one of a set of standard
	 formats, and translates them to the graphics driver's native format in one of several possible ways.
	 It also receives hints from the operational layer to improve its caching strategy.
       </para>
       <para>
	 Finally, above the operational layer, another layer is situated: This widget layer provides abstract
	 descriptions of things on the screen as objects, so-called widgets. It provides the primary interface
	 for the interpreter to interact with.
       </para>
     </sect2>
     <sect2><title>Standard data types</title>
     <para>
       There are a number of standard data types defined in <filename>src/include/gfx_system.h</filename> which
       are used all over the place in the graphics subsystem; therefore, they warrant some special attention
       in order to understand how it works. 
     </para>
     <sect3><title>point_t</title>
     <para>
       This data type is nothing more than a tuple (<literal>x</literal>,<literal>y</literal>). It describes a coordinate on the screen; a one-line
       way to generate a <type>point_t</type> is to use the function <function>gfx_point(x,y)</function>.
     </para>
     <sect3><title>rect_t</title>
     <para>
       This type describes a rectangular area on the screen, as a four-tuple (<literal>x</literal>,<literal>y</literal>,<literal>xlen</literal>,
       <literal>ylen</literal>), where the point (<literal>x</literal>, <literal>y</literal>) describes the upper left point of the rectangle,
	 whereas <literal>xlen</literal> and <literal>ylen</literal> are the number of pixels the rectangle extends to the right on the x and
	 downwards on the y axis, respectively. A <type>rect_t</type> can be generated in-line by the function <function>gfx_rect(x,y,xl,yl)</function>.
       </para>
       <para>
	 A number of functions are available to operate on <type>rect_t</type>s. These functions are 'pure' in the functional sense, meaning that
	 they do not modify the original rectangle, but, rather, return a new one (of course, an optimizing compiler will make this a moot point
	 from a performance perspective).
       </para>
       <sect4><title>gfx_rect_equals(rect_a, rect_b)</title>
       <para>
	 This function is a predicate that returns non-zero iff <literal>rect_a</literal> describes the same rectangle as <literal>rect_b</literal>.
       </para>
       <sect4><title>gfx_rect_translate(rect, point)</title>
       <para>
	 Returns a rectangle which equals <literal>rect</literal> translated (moved) by the (<literal>x</literal>, <literal>y</literal>) tuple
	 described by the <literal>point</literal> parameter (i.e. <literal>point</literal> is interpreted as a relative coordinate).
       </para>
       <sect4><title>gfx_rect_subset(rect_a, rect_b)</title>
       <para>
	 A predicate to determine whether all pixels contained in the area described by <literal>rect_a</literal> are also
	 contained in the area described by <literal>rect_b</literal>. Reflexive and transitive.
       </para>
       <sect4><title>gfx_rects_overlap(rect_a, rect_b)</title>
       <para>
	 A predicate to test whether there exists a pixel in the area described by <literal>rect_a</literal> which is
	 contained in the area described by <literal>rect_b</literal>. Reflexive and symmetric.
       </para>
       <sect4><title>gfx_rects_merge(rect_a, rect_b)</title>
       <para>
	 Returns the smallest rectangle containing both <literal>rect_a</literal> and <literal>rect_b</literal>.
       </para>
       <sect3><title>gfx_pixmap_color_t</title>
       <para>
	 This structure describes a single color in a pixmap. It consists of 8 bit <literal>r</literal>, <literal>g</literal>, <literal>b</literal> values
	 to describe a color; when used in a pixmap, it is part of a palette of <type>gfx_pixmap_color_t</type>s where the entry at index <literal>i</literal>
	 describes the color of the respective color index <literal>i</literal> inside the pixmap.
       </para>
       <para>
	 In palette mode, the <literal>global_index</literal> entry is used to store the color index entry of the global palette that
	 correlates with the pixmap index (or <literal>GFX_COLOR_INDEX_UNMAPPED</literal> if this value has not been determined yet).
       </para>
       <sect3><title>gfx_color_t</title>
       <para>
	 <type>gfx_color_t</type> structures contain color information for all three color maps.
	   They consist of a <type>gfx_pixmap_color_t</type> structure, <literal>visual</literal>, which describes the effects of the
	   color on the visual map, an <literal>alpha</literal> entry to describe the color's transparency (0 means 'opaque', 255 means
	   'totally transparent', although graphics drivers may choose to slighly alter those meanings for performance considerations),
	   <literal>priority</literal> and <literal>control</literal> values for the respective maps, and a <literal>mask</literal>
	   to determine the maps affected.
	 </para>
	 <para>
	   This mask is a bitwise-OR of the constants <literal>GFX_MASK_VISUAL</literal> (meaning "draw to the visual map"),
	   <literal>GFX_MASK_PRIORITY</literal> ("draw to the priority map") and <literal>GFX_MASK_CONTROL</literal> (guess).
	   </para>
	   <sect3><title>gfx_mode_t</title>
	   <para>
	     The FreeSCI only supports a small subset of all possible graphics modes; specifically, it only supports modes where the integer
	     value of each pixel can be stored in 8, 16, 24, or 32 bits. Color index mode is supported, but non-indexed mode has additional
	     requirements: Each color aspect of red, green, and blue must be represented by a consecutive sub-vector 
	     &lt;v<subscript>c</subscript>, v<subscript>c+1</subscript>, ... ,v<subscript>c+n-1</subscript>&gt; of the total color vector
	     &lt;v<subscript>0</subscript>, v<subscript>1</subscript>, ... ,v<subscript>b-1</subscript>&gt;, where <literal>n</literal> and
	     <literal>c</literal> are non-negative integers, and c+n &le; b holds. With v<subscript>b</subscript> being the most significant
	       bit of the total bit vector, we also require that for each <literal>m</literal> where 0 &lt; m &lt; n the bit v<subscript>c+m</subscript>
	       should, if set, increase brightness about twice as much as setting v<subscript>c+m-1</subscript> would. This allows us to
	       represent each color aspect by means of an AND bitmask and an integer shift value.
	     </para>
	     <para>
	       This, along with a global palette and the scaling factors, is the core of the <type>gfx_mode_t</type> data. It also contains
	       a shift values and an AND bitmask for alpha values; if these values are set to non-zero by the graphics driver, alpha channel
	       information will be written to the same block of data the color values are written to when pixmaps are calculated. If they
	       are not set, a separate 8bpp alpha data block will be added to the pixmaps.
	     </para>
	   <sect3><title>gfx_pixmap_t</title>
	   <para>
	     The <type>gfx_pixmap_t</type> structure is another fundamental element of the graphics subsystem. It describes a single
	     pixmap, such as a background picture, a cel, a mouse pointer, or a single line of text. It contains up to two references to
	     the graphical data it describes: One unscaled block of color-indexed data (<literal>index_data</literal>, and another block
	     scaled and in the graphics driver's native format (<literal>data</literal>).
	   </para>
	   <para>
	     Each pixmap contains a local palette of <literal>colors_nr</literal> <type>gfx_pixmap_color_t</type> entries,
	     called <literal>colors</literal>. This palette is allocated dynamically and may be NULL if no <literal>index_data</literal> block
	     is present.
	   </para>
	   <para>
	     Also, a tuple (<literal>xoffset</literal>, <literal>yoffset</literal>) describes the pixmap's 'hot spot'. This is a relative offset
	     into the unscaled data; it is used to describe the point which drawing operations will refer to. This means that pixmap
	     draw operations on this pixmap will cause it to be drawn <literal>xoffset</literal> pixels (unscaled) to the left of the coordinate
	     specified.
	   </para>
	   <para>
	     Next comes the unscaled pixmap data, called <literal>index_data</literal>, which occupies a size of <literal>index_xl</literal> *
	   <literal>index_yl</literal> bytes. Each byte is either a reference into the palette, or <literal>GFX_COLOR_INDEX_TRANSPARENT</literal> (0xff),
	     which means that it describes a transparent pixel, unless 256 colors are indeed present in the palette<footnote>
	     <para>This may cause a problem for SCI1 support, which explicitly allows for 256 separate colors to be used alongside with transparency.
	       Possible solutions include a separate transparency bitmap or increasing the number of bits per <literal>index_data</literal>
	       entry to 16bpp.</para></footnote>
	     </para>
	     <para>
	       The pointer <literal>data</literal>, unless NULL, points to a block of data allocated to contain the translated graphical data
	       in the graphics driver's native format. The number of bytes per pixel equals the <literal>bytespp</literal> property of the
	       <type>gfx_mode_t</type> structure it was allocated for, whereas its horizontal and vertical extensions are stored in the
	       <literal>xl</literal> and <literal>yl</literal> properties. Unless the graphics mode indicated that it supports an alpha
	       channel itself, a separate <literal>alpha_map</literal> is also provided, at 8bpp.
	     </para>
	     <para>
	       Each pixmap also comes with a <literal>pixmap_internal</literal> block, which may be used by graphics drivers to store
	       internal information (like pixmap repository handles).
	     </para>
	     <para>
	       Finally, each pixmap comes with a set of <literal>flags</literal> with the following meanings:
	       <itemizedlist>
		 <listitem><para><literal>GFX_PIXMAP_FLAG_SCALED_INDEX</literal>: The pixmaps index data is already scaled; any algorithm for calculating
		   <literal>data</literal> (and, possibly, <literal>alpha_map</literal>) therefore must not scale it again.</para></listitem>
		 <listitem><para><literal>GFX_PIXMAP_FLAG_EXTERNAL_PALETTE</literal>: The palette supplied with the pixmap is stored externally, meaning
		   that it must not be freed when the pixmap itself is freed</para></listitem>
	         <listitem><para><literal>GFX_PIXMAP_FLAG_INSTALLED</literal>: The pixmap has been installed in the pixmap repository (used by the
		   operational layer, although graphics drivers may choose to verify this if they don't trust that layer</para></listitem>
		 <listitem><para><literal>GFX_PIXMAP_FLAG_PALETTE_ALLOCATED</literal>: (only relevant for color index mode) The pixmap's palette colors
		   have been allocated in the internal palette listing and have been set appropriately in the palette</para></listitem>
		 <listitem><para><literal>GFX_PIXMAP_FLAG_PALETTE_SET</literal>: (only relevant in color index mode) The pixmap's palette colors have been
		   propagated to the graphics driver</para></listitem>
	         <listitem><para><literal>GFX_PIXMAP_FLAG_DONT_UNALLOCATE_PALETTE</literal>: (only relevant in color index mode) Instructs the pixmap
		   freeing operations not to free the palette colors allocated by the pixmap. This is used in cases where the palette is stored
		   externally.</para></listitem>
	       </itemizedlist>
	     </para>
	     <para>
	   <filename>src/include/gfx_tools.h</filename> defines many functions for creating pixmaps, allocating index data blocks, copying pixmap
	     regions etc.
	 </para>
       <sect3><title>gfx_bitmap_font_t</title>
         <para>
	   These structures provide a bitmap lookup table intended for up to 256 entries. In practice, they are used to store
	   font data. There is little surprising about this structure, with the possible exception of the difference between the
	   <literal>height</literal> and <literal>line_height</literal> variables: <literal>height</literal> describes the actual
	     character size, whereas <literal>line_height</literal> only describes how many pixels the text rendering functions
	     should leave in between text lines.
	 </para>
       </sect2>
       <sect2><title>Graphics drivers</title>
       <para>
	 Every FreeSCI graphics driver provides an individual implementation for one specific target platform,
	 such as the X Window System. In order to work correctly, it needs to implement the interface outlined
	 in <filename>src/include/gfx_driver.h</filename> and list itself in <filename>src/include/gfx_drivers.h</filename>.
	 Drivers have some freedom in determining which features they want to provide and which they want to have
	 emulated. These features are determined by flags contained in its variable <literal>capabilities</literal>.
       </para>
       <para>
	 Graphics drivers must provide at least five buffers: Both priority buffers, and the three visual buffers.
	 They are grouped in three sets labelled the Front Buffer (only one visual buffer), the Back Buffer,
	 and the Static Buffer (both containing both a priority and a visual buffer). Most graphical operations
	 operate on the back buffer, with their results being propagated to the front buffer by means of explicit
	 buffer operations<footnote><para>These operations operate on partial buffer contents and expect the back buffer's
	 contents to be unmodified after the transfer. This is unlike the OpenGL back buffer concept.</para></footnote>.
       </para>
       <para>
	 Driver implementations with limited or no hardware accelleration support, such as those operating on
	 plain frame buffers, may use some shared functionality exported for their benefit. Those functions are listed
	 in the appropriate function definitions below.
       </para>
       <para>
	 Unless specified differently, each function must return <literal>GFX_OK</literal> on success, <literal>GFX_ERROR</literal>
	 on failure, and <literal>GFX_FATAL</literal>
	 if and only if a fatal and unrecoverable error occured, such as the target display being closed by external means. 
       </para>
       <para>
	 Functions that receive color parameters must respect those parameters' mask values for <literal>GFX_MAP_MASK</literal>.
       </para>
       <sect3>
	 <title>I/O and debug functionality</title>
	 <para>
	   For basic input and output, the <function>GFXDEBUG()</function>, <function>GFXWARN()</function> and <function>GFXERROR()</function> macros defined in
	   <filename>src/include/gfx_system.h</filename> can be used. Also, there is another variable, <literal>debug_flags</literal>
	   defined for drivers; while it cannot be changed during runtime (yet), it may be used in combination with the
	   various GFX_DEBUG_ constants to selectively enable and disable debugging for certain parts of the driver
	   during development.
	 </para>
	 <para>
	   For further debugging, the FreeSCI functions <function>sciprintf()</function> (a printf clone), <function>MEMTEST()</function>
	   (tries to detect heap corruption), and <function>BREAKPOINT()</function> (Sets a debugger breakpoint on Alpha, ia32 and SPARC) may be used.
	 </para>
       <sect3>
	<title>Initialization and shutdown functionality</title>
	 <para>
	   None of the functions defined in here are optional. They are called during startup or shutdown and need
	   not be considered performance critical.
	 </para>
	 <sect4><title>set_parameter(attribute, value)</title>
	   <para>
	     This function is completely driver specific. Drivers may use it to allow external configuration of
	     options not covered by the standard FreeSCI set of configuration options. It must be implemented
	     to operate correctly both if <function>init()</function> has already been called and if it hasn't, although it may choose
	     to ignore any options set afterwards.
	   </para>
	   <para>Documentation of this function's options is up to the graphics driver's maintainer.</para>
	 <sect4><title>init_specific(xscale, yscale, bytespp)</title>
	   <para>
	     Initializes a graphics driver to a pre-determined mode, where <literal>xscale</literal> and <literal>yscale</literal>
	     are the requested horizontal and vertical scaling factors (integers > 0), and <literal>bytespp</literal> is the number of bytes per
	     pixel on the target display.
	   </para>
	   <para>
	     The function may set a higher resolution, provided that no matching resolution is available. The <literal>mode</literal> structure
	     (stored locally to the driver structure) must be set by this function if it succeeds; for this, the function
	     <function>gfx_new_mode()</function>, defined in <filename>src/include/gfx_tools.h</filename>, may be used.
	   </para>
	   <para>
	     <literal>GFX_OK</literal> must be returned iff the initialization succeeded; otherwise, <literal>GFX_ERROR</literal>
	     must be reported, unless the graphics
	     target is not (or no longer) able to provide any of the supported modes (e.g. if a required external module was not found,
	     or if the driver detected during run-time that the target does not support any appropriate graphics mode).
	   </para>
	 <sect4 id="gfx-driver-init-specific"><title>init()</title>
	   <para>
	     This operation initializes the driver's default graphics mode. Determining this mode is up to the graphics
	     driver; if its target platform has no means for determining an appropriate mode, it may choose to invoke
	     init_specific() repeatedly with educated guesses. It must return one of <literal>GFX_OK</literal> or <literal>GFX_FATAL</literal>.
	   </para>
	   <para>See <xref linkend="gfx-driver-init-specific" /> for details.</para>
	  <sect4><title>exit()</title>
	    <para>
	      Deinitializes the graphics driver, frees all resources allocated by it and just generally performs clean-up. This function
	      must succeed (so it does not have a return value). It may use <function>gfx_free_mode()</function> (from <filename>src/include/gfx_tools.h</filename>)
	      to free the data allocated in the <type>gfx_mode_t</type> structure.
	    </para>
	  </sect4>
       </sect3>
       <sect3>
	<title>Primitive drawing operations</title>
	 <para>
	   "Primitive drawing operations" here are operations that draw primitives. FreeSCI uses only two graphics
	   primitives: Lines and solid boxes, both of which are commonly provided by graphics libraries. 
	   Both operations draw to the back buffer; they also must respect the priority aspect of the primary color used on them.
	 </para>
	 <sect4><title>draw_line(line, color, line_mode, line_style)</title>
	   <para>
	     Draws a single line. The <literal>line</literal> parameter describes the starting point and a relative coordinates
	     of the line to draw in the specified <literal>color</literal>, whereas <literal>line_mode</literal> specifies the
	     line mode to use. This value may be <literal>GFX_LINE_MODE_FAST</literal>, which means that the line's thickness
	     is roughly about the average of the horizontal and vertical scaling factors. The other two values need not be
	     supported (they should fall back to <literal>GFX_LINE_MODE_FAST</literal> if they're used'):
	     <simplelist>
	       <member><literal>GFX_LINE_MODE_FAST</literal>: Line thickness is averate of x and y scale factors</member>
	       <member><literal>GFX_LINE_MODE_CORRECT</literal>: Lines are scaled separately for x and y and have correct widths there</member>
	       <member><literal>GFX_LINE_MODE_THIN</literal>: Line has a width of 1</member>
	     </simplelist>
	   </para>
	   <para>
	     The other parameter, <literal>line_style</literal>, may be either of <literal>GFX_LINE_STYLE_NORMAL</literal> or
	     <literal>GFX_LINE_STYLE_STIPPLED</literal>, although the latter is used iff the capability flag <literal>GFX_CAPABILITY_STIPPLED_LINES</literal>
	     is set.
	   </para>
	   <para>
	     This function must return GFX_OK or GFX_FATAL.
	   </para>
	 <sect4><title>draw_filled_rect(rect, color1, color2, shade_mode)</title>
	   <para>
	   </para>
	 </sect4>
       </sect3>
       <sect3>
	<title>Pixmap operations</title>
	 <para>
	 </para>
       </sect3>
       <sect3>
	<title>Buffer operations</title>
	 <para>
	 </para>
       </sect3>
       <sect3>
	<title>The mouse pointer</title>
	 <para>
	 </para>
       </sect3>
       <sect3>
	<title>Palette</title>
	 <para>
	 </para>
       </sect3>
       <sect3>
	<title>Event management</title>
	 <para>
	 </para>
       </sect3>
       <sect3>
	<title>Capability flag summary</title>
	 <para>
	 </para>
       </sect3>
       <sect2><title>The graphical resource manager (GRM)</title>
       <para>
       </para>
       <sect2 id="fsci-gfx-op"><title>The operational layer</title>
       <para>
       </para>
       <sect2 id="fsci-gfx-widgets"><title>FreeSCI graphical widgets</title>
       <para>
       </para>
       <sect3 id="fsci-gfx-widgets-string"><title>Printing widgets</title>
       <para>
	 By means of each widget's <function>print</function> method, its state can be written to
	 the FreeSCI output stream. Output of the <emphasis>STATE</emphasis> is as follows:
<blockquote><para>
  <emphasis>STATE</emphasis> ::= <emphasis>VALIDITY</emphasis> "S"<emphasis>SERIAL</emphasis> <emphasis>ID</emphasis> [<emphasis>BOUNDS</emphasis>] <emphasis>FLAGS</emphasis> <emphasis>WIDGET-INFO</emphasis>

  <emphasis>VALIDITY</emphasis> ::= "v" /* widget is valid */
               | "NoVis" /* Valid, but does not have a visual- internal error, unless it's a visual itself */
               | "INVALID" /* Widget was invalidated */
               |  /* empty: Should never happen */

  <emphasis>SERIAL</emphasis> ::=  <function>HEXNUMBER</function> /* The widget's unique serial number */

  <emphasis>ID</emphasis> ::=  /* No ID */
               | "#"<emphasis>HEXNUMBER</emphasis> /* ID assigned to the widget- typically an SCI heap address */

  <emphasis>BOUNDS</emphasis> ::= (<emphasis>X-COORDINATE</emphasis>,<emphasis>Y-COORDINATE</emphasis>)(<emphasis>WIDTH</emphasis>,<emphasis>HEIGHT</emphasis>) /* Full extension of the graphics described by the widget */

</para></blockquote>

       The <emphasis>FLAGS</emphasis> are described by a sequence of characters;
       their meanings are listed below:
       <simplelist>
	 <member>V: Widget is visible</member>
	 <member>O: Widget is completely opaque, i.e. fully covers all area in its bounds</member>
	 <member>C: Widget is a container</member>
	 <member>D: Widget is "dirty", i.e. will be redrawn at the next update</member>
	 <member>T: Widget has been tagged for clean-up</member>
	 <member>M: The widget's ID is not considered to be unique</member>
	 <member>I: Widget will not be freed if a snapshot is resored</member>
       </simplelist>
       The widget's ID will generally be considered to be unique within the container
       it is appended to, unless the Multi-ID flag ('M') is set. Functionally, this
       means that a widget <literal>w</literal> is appended to a list containing one
       or more widgets with an ID identical to its own, it overwrites the first
       widget with a matching ID, unless <literal>w</literal> itself has the
       <emphasis>M</emphasis> flag set.
       </para>
       <para>
	 The <emphasis>WIDGET-DESCRIPTION</emphasis> part of a widget starts
	 with a string describing the widget's type; this is followed by widget-
	 specific information.
       </para>
       </sect3>
       <sect2><title>Interpreter interaction</title>
       <para>
       </para>
     </sect1>

     <sect1>
        <title/Kernel hacking/
        <para>
           Kernel functions are the bridge between the abstract virtual machine, and the world of
           real programs. The VM may be able to solve RPN equations in the blink of an eye, but
           what good is this if it can't read input or produce output?<footnote><para/It could be used
           to produce benchmarks./</footnote>
        </para><para>
           All of the kernel functions are stored in src/core/kernel.c. Since kernel function mapping
           is done during runtime by string comparison, each kernel function and its name have to be
           registered in the array kfunct_mappers[]. Note that each version of the SCI interpreter
           (at least each pre-1.000.000 version) comes with one unidentified kernel function, which
           is handled by <function/k_Unknown/.
        </para>
        <sect2>
           <Title/Kernel basics/
           <para>
              Each kernel function is declared like this:
              <programlisting>
              void
              kFooBar(state_t *s, int funct_nr, int argc, heap_ptr argp);
              </programlisting>
              So this is how you should start. The four parameters (think of them as the
              Four Accessories of a kernel function) mean the following:
              <simplelist>
                <member/state_t *s: A pointer to the state you are operating on./
                <member/int funct_nr: The number of this function. Mostly irrelevant./
                <member/int argc: The number of arguments./
                <member/heap_ptr argp: Heap pointer to the first argument./
              </simplelist>
              "s" contains a lot of important and interesting data. Have a look at src/include/engine.h
              for a complete description. What you will probably need mostly will be the heap,
              (s->heap), a unsigned char pointer, and the accumulator (s->acc), a word (guint16),
              which is used to return values to the SCI program.
           </para><para>
              Some kernel functions don't even need to refer to the heap. However, most of them are
              passed at least one, if not more parameters. This may sound shocking to you, but there
              is an easy way to work around the neccessity of peeling them off the heap manually:
              Use the PARAM macros. They are used as follows:
              <simplelist>
                <member/PARAM(x): Returns the value of the parameter x. Does not check for validity./
                <member/UPARAM(x): Same as PARAM(x), but casts the parameter to be unsigned./
                <member/PARAM_OR_ALT(x, y): Checks if PARAM(x) is valid and returns it, or returns
                        y if PARAM(x) is invalid./
                <member/UPARAM_OR_ALT(x, y): PARAM_OR_ALT(x, y) unsigned./ 
              </simplelist>
              Several kernel functions assume default values if a specific parameter is not present.
              Use the U?PARAM_OR_ALT(x, y) macros to detect this case, and you'll rarely have to care
              about using argc directly.
           </para>
        </sect2>
        <sect2>
           <Title/Hunk and heap/
           <para>
              Accessing the heap for both reading and writing is surprisingly important for the kernel,
              especially when it has to deal with functions that would usually belong into user space,
              like handling of doubly-linked lists. To ease this, three macros are available:
              <simplelist>
                 <member/GET_HEAP(x) - reads a signed SCI word (gint16) from heap address x/
                 <member/UGET_HEAP(x) - reads an unsigned SCI word (guint16)/
                 <member/PUT_HEAP(x, foo) - writes the value foo to the specified heap address/
              </simplelist>
           </para><para>
              Some kernel functions, especially graphical kernel functions, additionally require
              the usage of what Sierra referred to as "hunk space". This is dynamically allocated
              memory; it can even be allocated and unallocated manually from SCI scripts by using
              the Load() and UnLoad() system calls (this is the sci_memory resource). To allow usage
              of this kind of memory, three functions have been provided:
              <simplelist>
                 <member/int kalloc(state_t *, space) - allocate space bytes and return a handle/
                 <member/byte *kmem(state_t *, handle) - resolve a handle and return the memory
                         address it points to/
                 <member/int kfree(state_t *, handle) - unallocate memory associated with a handle.
                         Returns 0 on success, 1 otherwise/
              </simplelist>
           </para>
        </sect2>
        <sect2>
           <Title/Error handling and debugging/
           <para>
              Error handling and debugging probably are the most important aspects of program
              writing. FreeSCI provides three macros for printing debug output:
              <simplelist>
                  <member/SCIkwarn(text, ...) - Print a warning message/
                  <member/SCIkdebug(text, ...) - Print a debug message/
                  <member/CHECK_THIS_KERNEL_FUNCTION - print the function name and parameters/
              </simplelist>
              The difference between SCIkwarn and SCIkdebug is that the latter can be easily
              removed (by commenting out the #define SCI_KERNEL_DEBUG on or about line 39). In
              practice this means that SCIkwarn should be used for warning or error messages in cases
              where it is likely that the vm or the kernel function are doing something wrong;
              e.g. if the program refers to a non-existant resource file, if a node list command
              does not come with a pointer to a node list, or if the number of parameters is
              insufficient. These messages are important and may point to misperceptions of details
              of the SCI engine. SCIkdebug, on the other hand, is your every-day "flood me with
              information until I'm blind" debug macro.
           </para><para>
              Sometimes it may happen that something goes wrong inside the kernel; e.g. a kernel
              function runs out of memory handles, or an internal variable somehow was set to an
              invalid value. In this case, <function/kernel_oops(state_t *, char *)/ should be used.
              It prints an error message and halts the VM, which none of the macros does.
           </para>
        </sect2>
        <sect2>
           <Title/Selectors/
           <para>
              Selectors are very important for some of the kernel functions. BaseSetter(), Animate(),
              Display(), GetEvent() and others take data from or write directly to selectors of
              a specified object (passed as a parameter or retreived from a node list), or even
              call object methods from kernel space<footnote><para/Yes, this is evil. Don't do this
              at home, kids!/</footnote>
              To prepare the usage of
              selectors, a variable has do be declared (in src/include/vm.h, selector_map_t). This
              variable will carry the numeric selector ID during run time. Now, the selector has to
              be mapped- this is happens once during initialization, to save time. It is performed
              by script_map_selectors(), which is located at the end of src/core/script.c (just use
              the "FIND_SELECTOR" macro).
           </para><para>
              If everything went right, accessing selectors should be really easy now. Just use the
              GET_SELECTOR(obj, selector) and PUT_SELECTOR(obj, selector, value) macros, where obj
              is a heap_ptr pointing to the object you want to read from or write to, and selector
              is the name of the selector to use.
              <example><title/An example for PUT_SELECTOR and GET_SELECTOR/<programlisting>
              void
              kSwapXY(state_t *s, int funct_nr, int argc, heap_ptr argp)
              {
                int posx, posy;
                heap_ptr obj = PARAM(0);

                posx = GET_SELECTOR(obj, x);
                posy = GET_SELECTOR(obj, y); /* x and y are defined in selector_map_t */

                PUT_SELECTOR(obj, y, posx);
                PUT_SELECTOR(obj, x, posy);
              }
              </programlisting></example>
           </para><para>
              Also, it may be neccessary to invoke an actual method. To do this, a varargs macro
              has been provided: INVOKE_SELECTOR(obj, selector, argc...). In theory, this macro
              can be used to set and read selectors as well (it would even handle multiple sends
              correctly), but this is discouraged for the sake of clarity.
           </para><para>
              INVOKE_SELECTOR works very much like the other macros; it must be called directly
              from a kernel function (or from any function supplying valid argc, argp and s).
              <example><Title/An example for INVOKE_SELECTOR/<programlisting>
                INVOKE_SELECTOR(obj, doit, 0); /* Call doit() without any parameters */
                INVOKE_SELECTOR(s->game_obj, setCursor, 2, 999, 1);
                                /* Call game_obj::setCursor(999, 1) */
              </programlisting></example>
           </para>
        </sect2>
     </Sect1>
</Chapter>

</Book>
